/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.35
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package sml;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;

import org.jsoar.kernel.JSoarVersion;
import org.jsoar.kernel.RunType;
import org.jsoar.kernel.events.InputEvent;
import org.jsoar.kernel.events.StopEvent;
import org.jsoar.sml.JSoarRhsFunctionAdapter;
import org.jsoar.util.events.SoarEvent;
import org.jsoar.util.events.SoarEventListener;

import sml.connection.ErrorCode;

public class Kernel extends ClientErrors
{
    int        m_TimeTagCounter ;  // Used to generate time tags (we do them in the kernel not the agent, so ids are unique for all agents)
    int        m_IdCounter ;       // Used to generate unique id names
    int         m_CallbackIDCounter ;   // Used to generate unique callback IDs

    final ObjectMap<Agent>   m_AgentMap = new ObjectMap<Agent>();
    String         m_CommandLineResult;
    boolean                m_CommandLineSucceeded ;
    // TODO sock::SocketLib*    m_SocketLibrary ;

    // Info about all connections (have to explicitly request this)
    final LinkedList<ConnectionInfo> m_ConnectionInfoList = new LinkedList<ConnectionInfo>() ;
    boolean                m_ConnectionInfoChanged ;

    // When true, commands are sent to external filters (if they are registered) for filtering before execution.
    boolean                m_FilteringEnabled ;

    // The mapping from event number to a list of handlers to call when that event fires
    // Which handler functions to call when an event comes in
    final ListMap<smlSystemEventId, SystemEventHandlerPlusData>      m_SystemEventMap = new ListMap<smlSystemEventId, SystemEventHandlerPlusData>();
    final ListMap<smlAgentEventId, AgentEventHandlerPlusData> m_AgentEventMap = new ListMap<smlAgentEventId, AgentEventHandlerPlusData>();
    final ListMap<String, RhsEventHandlerPlusData> m_RhsEventMap = new ListMap<String, RhsEventHandlerPlusData>();
    final ListMap<smlUpdateEventId, UpdateEventHandlerPlusData> m_UpdateEventMap = new ListMap<smlUpdateEventId, UpdateEventHandlerPlusData>();
    final ListMap<smlStringEventId, StringEventHandlerPlusData> m_StringEventMap = new ListMap<smlStringEventId, StringEventHandlerPlusData>();

    // Class used to map events ids to and from strings
    Events             m_pEventMap ;
    
    // Keep a local copy of this flag so we can report
    // information directly about what the client is sending/receiving
    boolean m_bTracingCommunications ;
    boolean m_bShutdown ;

    // If true, don't register to get output link events
    boolean m_bIgnoreOutput ;

    // If true, commit all changes to working memory immediately after they occur
    // (that is send them over to kernelSML immediately, rather than collecting them up for a single commit)
    boolean m_bAutoCommit = true;

    private int nextRhsFunctionId = 0; 
    private Map<Integer, JSoarRhsFunctionAdapter> rhsFunctionHandlers = new HashMap<Integer, JSoarRhsFunctionAdapter>();
    private int nextUpdateHandlerId = 0;
    private final Map<Integer, UpdateEventHandlerPlusData> updateEventHandlers = new LinkedHashMap<Integer, UpdateEventHandlerPlusData>();
    
    // This thread is used to check for incoming events when the client goes to sleep
    // It ensures the client stays "alive" and is optional (there are other ways for clients to keep themselves
    // responsive).
    // TODO EventThread*        m_pEventThread ;
    
    protected Kernel()
    {
        m_TimeTagCounter = 0 ;
        m_IdCounter      = 0 ;
        // TODO m_SocketLibrary  = null ;
        m_LastError      = ErrorCode.kNoError ;
        m_CallbackIDCounter = 0 ;
        // TODO m_pEventThread  = 0 ;
        m_pEventMap     = new Events() ;
        m_bTracingCommunications = false ;
        m_bShutdown     = false ;
        m_ConnectionInfoChanged = false ;
        m_bIgnoreOutput = false ;
        m_FilteringEnabled = true ;

        // We're turning on auto commit by default, so clients are a bit slower but easier to write.
        // Power users are free to turn it off and use explicit commit calls.
        m_bAutoCommit   = true ;

        ClearError() ;
    }

    /*************************************************************
    * @brief Creates a new Agent* object (not to be confused
    *        with actually creating a Soar agent -- see CreateAgent for that)
    *************************************************************/
    protected Agent MakeAgent(String pAgentName)
    {
        if (pAgentName == null)
            return null;

        // If we already have an agent structure for this name just
        // return it.
        Agent agent = GetAgent(pAgentName) ;

        if (agent != null)
            return agent ;

        // Make a new client side agent object
        agent = new Agent(this, pAgentName) ;

        // Record this in our list of agents
        m_AgentMap.add(agent.GetAgentName(), agent) ;
        
        for(Map.Entry<Integer, JSoarRhsFunctionAdapter> e : rhsFunctionHandlers.entrySet())
        {
            agent.addRhsFunction(e.getKey(), e.getValue());
        }

        // Register to get output link events.  These won't come back as standard events.
        // Instead we'll get "output" messages which are handled in a special manner.
//        if (!m_bIgnoreOutput)
//            RegisterForEventWithKernel(smlWorkingMemoryEventId.smlEVENT_OUTPUT_PHASE_CALLBACK.ordinal(), agent.GetAgentName()) ;

        return agent ;
        
    }

    public synchronized void delete()
    {
        // If the user didn't call shutdown, we'll do it now.
        // It's better for the user to call it so we have a more stable state
        // for handling messages.
        if (!m_bShutdown)
            Shutdown() ;

        // When the agent map is deleted, it will delete its contents (the Agent objects)
        // Do this before we delete the connection, in case we need to send things to the kernel
        // during clean up.
        m_AgentMap.clear() ;

        // Must stop the event thread before deleting the connection
        // as it has a pointer to the connection.
// TODO       if (m_pEventThread)
//            m_pEventThread->Stop(true) ;

        // Clean up any connection info we have stored
        for (ConnectionInfo pInfo : m_ConnectionInfoList)
        {
            pInfo.delete();
        }
        m_ConnectionInfoList.clear() ;

        m_pEventMap.delete();
    }

    public interface SystemEventInterface
    {
        public void systemEventHandler(int eventID, Object data, Kernel kernel);
    }

    public interface UpdateEventInterface
    {
        public void updateEventHandler(int eventID, Object data, Kernel kernel, int runFlags);
    }

    public interface StringEventInterface
    {
        public String stringEventHandler(int eventID, Object userData, Kernel kernel, String callbackData);
    }

    public interface AgentEventInterface
    {
        public void agentEventHandler(int eventID, Object data, String agentName);
    }

    public interface RhsFunctionInterface
    {
        public String rhsFunctionHandler(int eventID, Object data, String agentName, String functionName,
                String argument);
    }

    public interface ClientMessageInterface
    {
        public String clientMessageHandler(int eventID, Object data, String agentName, String functionName,
                String argument);
    }

    public int RegisterForSystemEvent(smlSystemEventId id, SystemEventInterface handlerObject, Object callbackData)
    {
        // TODO throw new UnsupportedOperationException("RegisterForSystemEvent");
        return 0;
    }

    public boolean UnregisterForSystemEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int RegisterForUpdateEvent(smlUpdateEventId id, UpdateEventInterface handlerObject, Object callbackData)
    {
        final int handlerId = nextUpdateHandlerId++;
        final UpdateEventHandlerPlusData plusData = new UpdateEventHandlerPlusData();
        plusData.eventId = id;
        plusData.m_Handler = handlerObject;
        plusData.m_UserData = callbackData;
        
        updateEventHandlers.put(handlerId, plusData);
        return handlerId;
    }

    public boolean UnregisterForUpdateEvent(int callbackReturnValue)
    {
        return null != updateEventHandlers.remove(callbackReturnValue);
    }

    public int RegisterForStringEvent(smlStringEventId id, StringEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForStringEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int RegisterForAgentEvent(smlAgentEventId id, AgentEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForAgentEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int AddRhsFunction(final String functionName, final RhsFunctionInterface handlerObject, final Object callbackData)
    {
        final int id = nextRhsFunctionId++;
        final JSoarRhsFunctionAdapter prototype = JSoarRhsFunctionAdapter.create(null, functionName, handlerObject, callbackData);
        rhsFunctionHandlers.put(id, prototype);
        
        for(final Agent a : m_AgentMap.values())
        {
            a.addRhsFunction(id, prototype.copy(a.GetAgentName()));
        }
        return id;
    }

    public boolean RemoveRhsFunction(int callbackReturnValue)
    {
        final boolean result = null != rhsFunctionHandlers.remove(callbackReturnValue);
        for(Agent a : m_AgentMap.values())
        {
            a.removeRhsFunction(callbackReturnValue);
        }
        return result;
    }

    public int RegisterForClientMessageEvent(String functionName, ClientMessageInterface handlerObject,
            Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForClientMessageEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    // In Java we want to explicitly delete the C++ kernel object after calling
    // shutdown so that the user
    // doesn't have to call ".delete()" on their Java object (or wait for the
    // garbage collector to do it which may never run--leading to
    // reports of memory leaks on shutdown). In C++ users expect to have to
    // delete their kernel pointer but not in Java.
    public void Shutdown()
    {
        m_bShutdown = true ;

        delete();
    }

    // Allow a user to avoid deleting the kernel object immediately, if they
    // have some special reason.
    public void ShutdownNoDelete()
    {
        throw new UnsupportedOperationException("");
    }

    public static String getKDefaultLibraryName()
    {
        throw new UnsupportedOperationException("");
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName, boolean optimized, int portToListenOn)
    {
        return new Kernel();
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName, boolean optimized)
    {
        return CreateKernelInCurrentThread(pLibraryName, optimized, kDefaultSMLPort);
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName)
    {
        return CreateKernelInCurrentThread(pLibraryName, false);
    }

    public static Kernel CreateKernelInCurrentThread()
    {
        return CreateKernelInCurrentThread(kDefaultLibraryName);
    }

    public static Kernel CreateKernelInNewThread(String pLibraryName, int portToListenOn)
    {
        return new Kernel(); // TODO
    }

    public static Kernel CreateKernelInNewThread(String pLibraryName)
    {
        return CreateKernelInNewThread(pLibraryName, kDefaultSMLPort);
    }

    public static Kernel CreateKernelInNewThread()
    {
        return CreateKernelInNewThread(kDefaultLibraryName);
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress, int port,
            boolean ignoreOutput)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress, int port)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection()
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    /**
     * @return
     */
    public static int GetDefaultPort()
    {
        return 12121; // smlJNI.Kernel_GetDefaultPort();
    }

    /**
     * @return
     */
    public static String GetDefaultLibraryName()
    {
        return "SoarKernelSML"; // smlJNI.Kernel_GetDefaultLibraryName();
    }

    public void SetAutoCommit(boolean state)
    {
        m_bAutoCommit = state;
    }

    public boolean IsAutoCommitEnabled()
    {
        return m_bAutoCommit;
    }

    public boolean IsConnectionClosed()
    {
        return false;
    }

    public boolean IsRemoteConnection()
    {
        return false;
    }

    public boolean IsDirectConnection()
    {
        return true;
    }

    public void ShutdownInternal()
    {
        // TODO implement ShutdownInternal
        throw new UnsupportedOperationException("ShutdownInternal");
    }

    public void SetTraceCommunications(boolean state)
    {
        // We keep a local copy of this value so we can check it without
        // calling anywhere.
        m_bTracingCommunications = state ;
    }

    public boolean IsTracingCommunications()
    {
        return m_bTracingCommunications ;
    }

    public Agent CreateAgent(String pAgentName)
    {
        return MakeAgent(pAgentName);
    }

    public void UpdateAgentList()
    {
    }

    public int GetNumberAgents()
    {
        return m_AgentMap.size();
    }

    public boolean DestroyAgent(Agent pAgent)
    {
        // Remove the object from our map and delete it.
        m_AgentMap.remove(pAgent.GetAgentName(), true) ;
        return true ;
    }

    public Agent GetAgent(String pAgentName)
    {
        if (pAgentName == null)
            return null;

        return m_AgentMap.find(pAgentName) ;
    }

    public Agent GetAgentByIndex(int index)
    {
        return m_AgentMap.getIndex(index) ;
    }

    public boolean IsAgentValid(Agent pAgent)
    {
        // We check the current list of agent pointers and see if this value is in that list
        // to determine if it is still valid.
        return m_AgentMap.contains(pAgent) ;
    }

    public void EnableFiltering(boolean state)
    {
        m_FilteringEnabled = state ;
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName, boolean echoResults, boolean noFilter)
    {
        final Agent agent = GetAgent(pAgentName);
        if(agent != null)
        {
            return agent.ExecuteCommandLine(pCommandLine, echoResults, noFilter);
        }
        else
        {
            return "";
        }
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName, boolean echoResults)
    {
        return ExecuteCommandLine(pCommandLine, pAgentName, echoResults, false);
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName)
    {
        return ExecuteCommandLine(pCommandLine, pAgentName, false);
    }

    public boolean ExecuteCommandLineXML(String pCommandLine, String pAgentName, ClientAnalyzedXML pResponse)
    {
        throw new UnsupportedOperationException("ExecuteCommandLineXML");
    }

    public String RunAllAgents(long numberSteps, smlRunStepSize stepSize, smlRunStepSize interleaveStepSize)
    {
        runAllAgents(numberSteps, Agent.smlToJSoarRunType(stepSize));
        return "";
    }
    
    private void runAllAgents(long numberSteps, RunType runType)
    {
        // List of agents we're running here to avoid issues if agent list changes
        final List<Agent> agents = new ArrayList<Agent>(m_AgentMap.values());
        
        // counts down as each agent finishes running. We use this to make run into a blocking
        // call which is what SML wants
        final CountDownLatch stopLatch = new CountDownLatch(agents.size());
        
        // A barrier. All the agent threads meet here each decision cycle so we can have
        // a single synchronized kernel update callback, which is what SML wants.
        final CyclicBarrier updateBarrier = new CyclicBarrier(agents.size(), new Runnable() {

            @Override
            public void run()
            {
                for(UpdateEventHandlerPlusData handler : updateEventHandlers.values())
                {
                    handler.m_Handler.updateEventHandler(0, handler.m_UserData, Kernel.this, 0);
                }
            }});
        
        // Keep track of listeners we install so we can clean up later
        final Map<Agent, SoarEventListener> listeners = new HashMap<Agent, SoarEventListener>();
        for(final Agent agent : agents)
        {
            final SoarEventListener listener = new SoarEventListener() {

                @Override
                public void onEvent(SoarEvent event)
                {
                    if(event instanceof StopEvent)
                    {
                        stopLatch.countDown();
                        updateBarrier.reset(); // yuck. force everybody out of the barrier so they can stop
                    }
                    else if(event instanceof InputEvent)
                    {
                        try
                        {
                            updateBarrier.await();
                        }
                        catch (InterruptedException e)
                        {
                            Thread.currentThread().interrupt();
                        }
                        catch (BrokenBarrierException e)
                        {
                            return; // see updateBarrier.reset() above
                        }
                    }
                }};
            listeners.put(agent, listener);
            
            agent.agent.getEvents().addListener(StopEvent.class, listener);
            agent.agent.getEvents().addListener(InputEvent.class, listener);
            
            // start the agent running (returns immediately)
            agent.agent.runFor(numberSteps, runType);
        }
        
        try
        {
            // wait for the latch to go to zero, which means all the agents have stopped
            stopLatch.await();
        }
        catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
        finally
        {
            // Now clean up our listeners
            for(Map.Entry<Agent, SoarEventListener> e : listeners.entrySet())
            {
                e.getKey().agent.getEvents().removeListener(null, e.getValue());
            }
        }
    }

    public String RunAllAgents(long numberSteps, smlRunStepSize stepSize)
    {
        return RunAllAgents(numberSteps, stepSize, smlRunStepSize.sml_DECISION);
    }

    public String RunAllAgents(long numberSteps)
    {
        return RunAllAgents(numberSteps, smlRunStepSize.sml_DECISION);
    }

    public String RunAllAgentsForever(smlRunStepSize interleaveStepSize)
    {
        runAllAgents(1, RunType.FOREVER);
        return "";
    }

    public String RunAllAgentsForever()
    {
        return RunAllAgentsForever(smlRunStepSize.sml_DECISION);
    }

    public String RunAllTilOutput(smlRunStepSize interleaveStepSize)
    {
        // TODO implement RunAllTilOutput
        throw new UnsupportedOperationException();
    }

    public String RunAllTilOutput()
    {
        return RunAllTilOutput(smlRunStepSize.sml_DECISION);
    }

    public String StopAllAgents()
    {
        for(Agent a : m_AgentMap.values())
        {
            a.StopSelf();
        }
        return "";
    }

    public boolean IsSoarRunning()
    {
        for(Agent a : m_AgentMap.values())
        {
            if(a.agent.isRunning())
            {
                return true;
            }
        }
        return false;
    }

    public boolean GetAllConnectionInfo()
    {
        return false;
    }

    public int GetNumberConnections()
    {
        return m_ConnectionInfoList.size();
    }

    public boolean HasConnectionInfoChanged()
    {
        return m_ConnectionInfoChanged ;
    }

    public ConnectionInfo GetConnectionInfo(int i)
    {
        return m_ConnectionInfoList.get(i);
    }

    public String GetConnectionStatus(String pConnectionName)
    {
        for(ConnectionInfo info : m_ConnectionInfoList)
        {
            if(info.GetName() != null && info.GetName().equals(pConnectionName))
            {
                return info.GetConnectionStatus();
            }
        }
        return null;
    }

    public String GetAgentStatus(String pConnectionName)
    {
        for(ConnectionInfo info : m_ConnectionInfoList)
        {
            if(info.GetName() != null && info.GetName().equals(pConnectionName))
            {
                return info.GetAgentStatus();
            }
        }
        return null;
    }

    public boolean SetConnectionInfo(String pName, String pConnectionStatus, String pAgentStatus)
    {
        return true;
    }

    public boolean FireStartSystemEvent()
    {
        // TODO implement FireStartSystemEvent
        throw new UnsupportedOperationException();
    }

    public boolean FireStopSystemEvent()
    {
        // TODO implement FireStopSystemEvent
        throw new UnsupportedOperationException();
    }

    public boolean SuppressSystemStop(boolean state)
    {
        // TODO implement SuppressSystemStop
        throw new UnsupportedOperationException();
    }

    public String ExpandCommandLine(String pCommandLine)
    {
        // TODO implement ExpandCommandLine
        throw new UnsupportedOperationException();
    }

    public boolean GetLastCommandLineResult()
    {
        // TODO implement GetLastCommandLineResult
        throw new UnsupportedOperationException();
    }

    public boolean IsRunCommand(String pCommandLine)
    {
        // TODO implement IsRunCommand
        throw new UnsupportedOperationException();
    }

    public boolean IsStopCommand(String pCommandLine)
    {
        // TODO implement IsStopCommand
        throw new UnsupportedOperationException();
    }

    public boolean CheckForIncomingCommands()
    {
        // TODO implement CheckForIncomingCommands
        throw new UnsupportedOperationException();
    }

    public boolean CheckForIncomingEvents()
    {
        // TODO implement CheckForIncomingEvents
        throw new UnsupportedOperationException();
    }

    public boolean StartEventThread()
    {
        return true ;
    }

    public boolean StopEventThread()
    {
        return true ;
    }

    public boolean SetInterruptCheckRate(int newRate)
    {
        // TODO implement SetInterruptCheckRate
        throw new UnsupportedOperationException();
    }

    public int RegisterForClientMessageEvent(String pClientName,
            SWIGTYPE_p_f_sml__smlRhsEventId_p_void_p_sml__Agent_p_q_const__char_p_q_const__char__std__string handler,
            SWIGTYPE_p_void pUserData, boolean addToBack)
    {
        // TODO implement RegisterForClientMessageEvent
        throw new UnsupportedOperationException();
    }

    public int RegisterForClientMessageEvent(String pClientName,
            SWIGTYPE_p_f_sml__smlRhsEventId_p_void_p_sml__Agent_p_q_const__char_p_q_const__char__std__string handler,
            SWIGTYPE_p_void pUserData)
    {
        // TODO implement RegisterForClientMessageEvent
        throw new UnsupportedOperationException();
    }

    public String SendClientMessage(Agent pAgent, String pClientName, String pMessage)
    {
        // TODO implement SendClientMessage
        throw new UnsupportedOperationException();
    }

    public String GetLibraryLocation()
    {
        throw new UnsupportedOperationException();
    }

    public String GetSoarKernelVersion()
    {
        return "JSoar " + JSoarVersion.getInstance().getVersion();
    }

    public void CommitAll()
    {
        final int numberAgents = GetNumberAgents() ;

        for (int i = 0 ; i < numberAgents ; i++)
        {
            Agent pAgent = GetAgentByIndex(i) ;
            pAgent.Commit() ;
        }
    }

    public boolean IsCommitRequired()
    {
        final int numberAgents = GetNumberAgents() ;

        for (int i = 0 ; i < numberAgents ; i++)
        {
            Agent pAgent = GetAgentByIndex(i) ;
            if (pAgent.GetWM().IsCommitRequired())
                return true ;
        }

        return false ;
    }

    public String LoadExternalLibrary(String pLibraryCommand)
    {
        // TODO implement LoadExternalLibrary
        throw new UnsupportedOperationException();
    }

    public SWIGTYPE_p_sml__Connection GetConnection()
    {
        // TODO implement GetConnection
        throw new UnsupportedOperationException();
    }

    public final static int kDefaultSMLPort = 12121;
    private final static String kDefaultLibraryName = "SoarKernelSML";
    
}
