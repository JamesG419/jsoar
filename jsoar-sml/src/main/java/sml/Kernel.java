/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.35
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package sml;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.jsoar.kernel.JSoarVersion;
import org.jsoar.sml.JSoarRhsFunctionAdapter;

import sml.connection.ErrorCode;

public class Kernel extends ClientErrors
{
    int        m_TimeTagCounter ;  // Used to generate time tags (we do them in the kernel not the agent, so ids are unique for all agents)
    int        m_IdCounter ;       // Used to generate unique id names
    int         m_CallbackIDCounter ;   // Used to generate unique callback IDs

    final ObjectMap<Agent>   m_AgentMap = new ObjectMap<Agent>();
    String         m_CommandLineResult;
    boolean                m_CommandLineSucceeded ;
    // TODO sock::SocketLib*    m_SocketLibrary ;

    // Info about all connections (have to explicitly request this)
    LinkedList<ConnectionInfo> m_ConnectionInfoList ;
    boolean                m_ConnectionInfoChanged ;

    // When true, commands are sent to external filters (if they are registered) for filtering before execution.
    boolean                m_FilteringEnabled ;

    // The mapping from event number to a list of handlers to call when that event fires
    // Which handler functions to call when an event comes in
    final ListMap<smlSystemEventId, SystemEventHandlerPlusData>      m_SystemEventMap = new ListMap<smlSystemEventId, SystemEventHandlerPlusData>();
    final ListMap<smlAgentEventId, AgentEventHandlerPlusData> m_AgentEventMap = new ListMap<smlAgentEventId, AgentEventHandlerPlusData>();
    final ListMap<String, RhsEventHandlerPlusData> m_RhsEventMap = new ListMap<String, RhsEventHandlerPlusData>();
    final ListMap<smlUpdateEventId, UpdateEventHandlerPlusData> m_UpdateEventMap = new ListMap<smlUpdateEventId, UpdateEventHandlerPlusData>();
    final ListMap<smlStringEventId, StringEventHandlerPlusData> m_StringEventMap = new ListMap<smlStringEventId, StringEventHandlerPlusData>();

    // Class used to map events ids to and from strings
    Events             m_pEventMap ;
    
    // Keep a local copy of this flag so we can report
    // information directly about what the client is sending/receiving
    boolean m_bTracingCommunications ;
    boolean m_bShutdown ;

    // If true, don't register to get output link events
    boolean m_bIgnoreOutput ;

    // If true, commit all changes to working memory immediately after they occur
    // (that is send them over to kernelSML immediately, rather than collecting them up for a single commit)
    boolean m_bAutoCommit = true;

    private int nextRhsFunctionId = 0; 
    private Map<Integer, JSoarRhsFunctionAdapter> rhsFunctionHandlers = new HashMap<Integer, JSoarRhsFunctionAdapter>();
    
    // This thread is used to check for incoming events when the client goes to sleep
    // It ensures the client stays "alive" and is optional (there are other ways for clients to keep themselves
    // responsive).
    // TODO EventThread*        m_pEventThread ;
    
    protected Kernel()
    {
        m_TimeTagCounter = 0 ;
        m_IdCounter      = 0 ;
        // TODO m_SocketLibrary  = null ;
        m_LastError      = ErrorCode.kNoError ;
        m_CallbackIDCounter = 0 ;
        // TODO m_pEventThread  = 0 ;
        m_pEventMap     = new Events() ;
        m_bTracingCommunications = false ;
        m_bShutdown     = false ;
        m_ConnectionInfoChanged = false ;
        m_bIgnoreOutput = false ;
        m_FilteringEnabled = true ;

        // We're turning on auto commit by default, so clients are a bit slower but easier to write.
        // Power users are free to turn it off and use explicit commit calls.
        m_bAutoCommit   = true ;

        ClearError() ;
    }
    void InitEvents()
    {
        // TODO InitEvents
        throw new UnsupportedOperationException();
    }

    /*************************************************************
    * @brief Register for a particular event with the kernel.
    *        (This is a primitive function, should call one of the
    *         higher level methods which will call here if needed)
    *************************************************************/
    void    RegisterForEventWithKernel(int id, String pAgentName)
    {
        // TODO RegisterForEventWithKernel
        throw new UnsupportedOperationException();
    }

    /*************************************************************
    * @brief Unregister for a particular event with the kernel.
    *        (This is a primitive function, should call one of the
    *         higher level methods which will call here if needed)
    *************************************************************/
    void    UnregisterForEventWithKernel(int id, String pAgentName)
    {
        // TODO UnregisterForEventWithKernel
        throw new UnsupportedOperationException();
    }

    /*************************************************************
    * @brief Creates a new Agent* object (not to be confused
    *        with actually creating a Soar agent -- see CreateAgent for that)
    *************************************************************/
    protected Agent MakeAgent(String pAgentName)
    {
        if (pAgentName == null)
            return null;

        // If we already have an agent structure for this name just
        // return it.
        Agent agent = GetAgent(pAgentName) ;

        if (agent != null)
            return agent ;

        // Make a new client side agent object
        agent = new Agent(this, pAgentName) ;

        // Record this in our list of agents
        m_AgentMap.add(agent.GetAgentName(), agent) ;
        
        for(Map.Entry<Integer, JSoarRhsFunctionAdapter> e : rhsFunctionHandlers.entrySet())
        {
            agent.addRhsFunction(e.getKey(), e.getValue());
        }

        // Register to get output link events.  These won't come back as standard events.
        // Instead we'll get "output" messages which are handled in a special manner.
//        if (!m_bIgnoreOutput)
//            RegisterForEventWithKernel(smlWorkingMemoryEventId.smlEVENT_OUTPUT_PHASE_CALLBACK.ordinal(), agent.GetAgentName()) ;

        return agent ;
        
    }

    // TODO void SetSocketLib(sock::SocketLib* pLibrary) { m_SocketLibrary = pLibrary ; }

    int    GenerateNextID()        { return ++m_IdCounter ; }
    int    GenerateNextTimeTag()   { return --m_TimeTagCounter ; } // Count down so different from Soar kernel

    /***
    ***   RHS functions and message event handlers use the same internal logic, although they look rather different to the user
    ***/
    int InternalAddRhsFunction(smlRhsEventId id, String pRhsFunctionName, RhsFunctionInterface handler, Object pUserData, boolean addToBack)
    {
        // implement InternalAddRhsFunction
        throw new UnsupportedOperationException();
    }
    boolean InternalRemoveRhsFunction(smlRhsEventId id, int callbackID)
    {
        // implement InternalRemoveRhsFunction
        throw new UnsupportedOperationException();
    }

    /*************************************************************
    * @brief This function is called when an event is received
    *        from the Soar kernel.
    *
    * @param pIncoming  The event command
    * @param pResponse  The reply (no real need to fill anything in here currently)
    *************************************************************/
    void ReceivedEvent(AnalyzeXML pIncoming, ElementXML pResponse)
    {
        String pEventName = pIncoming.GetArgString(sml_Names.getKParamEventID()) ;

        // This event had no event id field
        if (pEventName == null)
        {
            return ;
        }

        // Convert from the string to an event ID
        int id = m_pEventMap.ConvertToEvent(pEventName) ;

        if (sml.IsSystemEventID(id))
        {
            ReceivedSystemEvent(smlSystemEventId.values()[id], pIncoming, pResponse) ;
        } else if (sml.IsAgentEventID(id))
        {
            ReceivedAgentEvent(smlAgentEventId.values()[id], pIncoming, pResponse) ;
        } else if (sml.IsRhsEventID(id))
        {
            ReceivedRhsEvent(smlRhsEventId.values()[id], pIncoming, pResponse) ;
        } else if (sml.IsUpdateEventID(id))
        {
            ReceivedUpdateEvent(smlUpdateEventId.values()[id], pIncoming, pResponse) ;
        } else if (sml.IsStringEventID(id))
        {
            ReceivedStringEvent(smlStringEventId.values()[id], pIncoming, pResponse) ;
        }
    } 
    
    void ReceivedSystemEvent(smlSystemEventId id, AnalyzeXML pIncoming, ElementXML pResponse)
    {
        // Look up the handler(s) from the map
        List<SystemEventHandlerPlusData> pHandlers = m_SystemEventMap.getList(id) ;

        if (pHandlers == null)
            return ;

        // Go through the list of event handlers calling each in turn
        for (SystemEventHandlerPlusData handlerWithData : pHandlers)
        {
            SystemEventInterface handler = handlerWithData.m_Handler ;
            Object pUserData = handlerWithData.m_UserData; //.getUserData() ;

            // Call the handler
            handler.systemEventHandler(id.ordinal(), pUserData, this) ;
        }
    }

    void ReceivedAgentEvent(smlAgentEventId id, AnalyzeXML pIncoming, ElementXML pResponse)
    {
        // Get the name of the agent this event refers to.
        String pAgentName = pIncoming.GetArgString(sml_Names.getKParamName()) ;

        // Look up the handler(s) from the map
        List<AgentEventHandlerPlusData> pHandlers = m_AgentEventMap.getList(id) ;

        if (pHandlers == null)
            return ;

        // See if we already have an Agent* for this agent.
        // We may not, because "agent created" events are included in the list that come here.
        Agent pAgent = GetAgent(pAgentName) ;

        // Agent name can be null for some agent manager events
        if (pAgent == null && pAgentName != null)
        {
            // Create a new client side agent object
            // We have to do this now because we'll be passing it back to the caller in a minute
            pAgent = MakeAgent(pAgentName) ;
        }

        // Go through the list of event handlers calling each in turn
        for (AgentEventHandlerPlusData handlerPlus : pHandlers)
        {
            AgentEventInterface handler = handlerPlus.m_Handler ;
            Object pUserData = handlerPlus.m_UserData; //getUserData() ;

            // Call the handler
            handler.agentEventHandler(id.ordinal(), pUserData, pAgentName) ;
        }
        
    }
    void ReceivedRhsEvent(smlRhsEventId id, AnalyzeXML pIncoming, ElementXML pResponse)
    {
        // Get the function name and the argument to the function
        // (We pass a single string but it could be parsed further to other values by the client)
        String pFunctionName = pIncoming.GetArgString(sml_Names.getKParamFunction()) ;
        String pArgument     = pIncoming.GetArgString(sml_Names.getKParamValue()) ;
        String pAgentName    = pIncoming.GetArgString(sml_Names.getKParamName()) ;

        if (pFunctionName == null)
        {
            // Should always include a function name
            SetError(ErrorCode.kInvalidArgument) ;
            return ;
        }

        // Look up the handler(s) from the map
        List<RhsEventHandlerPlusData> pHandlers = m_RhsEventMap.getList(pFunctionName) ;

        if (pHandlers == null)
            return ;

        // Look up the agent
        @SuppressWarnings("unused")
        Agent pAgent = pAgentName != null ? GetAgent(pAgentName) : null;

        // Go through the list of event handlers calling each in turn...except
        // we only execute the first handler (registering multipler handlers for the same RHS function is not supported
        // because these functions return a value -- it wouldn't be clear which to use.  We could change this to call all
        // registered handlers and only use the first or last value returned.)
        if (pHandlers.isEmpty())
            return ;

        RhsEventHandlerPlusData handlerWithData = pHandlers.get(0);

        RhsFunctionInterface handler = handlerWithData.m_Handler ;
        Object pUserData = handlerWithData.getUserData() ;

        // Call the handler
        String result = handler.rhsFunctionHandler(id.ordinal(), pUserData, pAgentName, pFunctionName, pArgument) ;

        // If we got back a result then fill in the value in the response message.
        //m_Connection.AddSimpleResultToSMLResponse(pResponse, result) ;
        
    }
    void ReceivedUpdateEvent(smlUpdateEventId id, AnalyzeXML pIncoming, ElementXML pResponse)
    {
        //unused(pResponse) ;

        // Retrieve the event arguments
        /*smlRunFlags*/ int runFlags = pIncoming.GetArgInt(sml_Names.getKParamValue(), 0);

        // Look up the handler(s) from the map
        List<UpdateEventHandlerPlusData> pHandlers = m_UpdateEventMap.getList(id) ;

        if (pHandlers == null)
            return ;

        // Go through the list of event handlers calling each in turn
        for (UpdateEventHandlerPlusData handlerWithData : pHandlers)
        {
            UpdateEventInterface handler = handlerWithData.m_Handler ;
            Object pUserData = handlerWithData.m_UserData; // getUserData() ;

            // Call the handler
            handler.updateEventHandler(id.ordinal(), pUserData, this, runFlags) ;
        }

    }
    void ReceivedStringEvent(smlStringEventId id, AnalyzeXML pIncoming, ElementXML pResponse)
    {
        String pValue = pIncoming.GetArgString(sml_Names.getKParamValue()) ;

        // Look up the handler(s) from the map
        List<StringEventHandlerPlusData> pHandlers = m_StringEventMap.getList(id) ;

        if (pHandlers == null)
            return ;

        // Go through the list of event handlers calling each in turn
        for (StringEventHandlerPlusData handlerWithData : pHandlers)
        {
            StringEventInterface handler = handlerWithData.m_Handler ;
            Object pUserData = handlerWithData.m_UserData; //getUserData() ;

            // Call the handler
            String result = handler.stringEventHandler(id.ordinal(), pUserData, this, pValue) ;

            // If we got back a result then fill in the value in the response message.
            //m_Connection.AddSimpleResultToSMLResponse(pResponse, result) ;
        }
        
    }

    /*************************************************************
    * @brief If this message is an XML trace message returns
    *        the agent pointer this message is for.
    *        Otherwise returns NULL.
    *        This function is just to boost performance on trace messages
    *        which are really performance critical.
    *************************************************************/
    Agent IsXMLTraceEvent(ElementXML pIncomingMsg)
    {
        //  The message we're looking for has this structure:
        //  <sml><command></command><trace></trace></sml>
        // This is deliberately unusual so this simple test screens out
        // almost all messages in one go.  It does make us more brittle (for detecting
        // xml trace messages) but I think that's a fair trade-off.
        if (pIncomingMsg.GetNumberChildren() != 2)
            return null ;

        ElementXML command = new ElementXML(null) ;
        ElementXML trace = new ElementXML(null) ;
        pIncomingMsg.GetChild(command, 0) ;
        pIncomingMsg.GetChild(trace, 1) ;

        if (trace.IsTag(sml_Names.getKTagTrace()) && command.IsTag(sml_Names.getKTagCommand()) && command.GetNumberChildren() > 0)
        {
            ElementXML agentArg = new ElementXML(null) ;
            command.GetChild(agentArg, 0) ;
/*
    #ifdef _DEBUG
            char const* pParam = agentArg.GetAttribute(sml_Names::kArgParam) ;
            assert (pParam && strcmp(pParam, sml_Names::kParamAgent) == 0) ;
    #endif
*/            // Get the agent's name
            String pAgentName = agentArg.GetCharacterData() ;

            if (pAgentName == null || pAgentName.length() == 0)
                return null ;

            // Look up the agent
            Agent pAgent = GetAgent(pAgentName) ;

            // If this fails, we got a trace event for a now deleted agent
            // (must have been flushed after the agent was destroyed).
            // Returning null is probably as good as we do here so
            // always return pAgent (even if it's null).
            return pAgent ;
        }

        return null ;
    }

    public synchronized void delete()
    {
        // If the user didn't call shutdown, we'll do it now.
        // It's better for the user to call it so we have a more stable state
        // for handling messages.
        if (!m_bShutdown)
            Shutdown() ;

        // When the agent map is deleted, it will delete its contents (the Agent objects)
        // Do this before we delete the connection, in case we need to send things to the kernel
        // during clean up.
        m_AgentMap.clear() ;

        // Must stop the event thread before deleting the connection
        // as it has a pointer to the connection.
// TODO       if (m_pEventThread)
//            m_pEventThread->Stop(true) ;

        // Clean up any connection info we have stored
        for (ConnectionInfo pInfo : m_ConnectionInfoList)
        {
            pInfo.delete();
        }
        m_ConnectionInfoList.clear() ;

        m_pEventMap.delete();
    }

    public interface SystemEventInterface
    {
        public void systemEventHandler(int eventID, Object data, Kernel kernel);
    }

    public interface UpdateEventInterface
    {
        public void updateEventHandler(int eventID, Object data, Kernel kernel, int runFlags);
    }

    public interface StringEventInterface
    {
        public String stringEventHandler(int eventID, Object userData, Kernel kernel, String callbackData);
    }

    public interface AgentEventInterface
    {
        public void agentEventHandler(int eventID, Object data, String agentName);
    }

    public interface RhsFunctionInterface
    {
        public String rhsFunctionHandler(int eventID, Object data, String agentName, String functionName,
                String argument);
    }

    public interface ClientMessageInterface
    {
        public String clientMessageHandler(int eventID, Object data, String agentName, String functionName,
                String argument);
    }

    public int RegisterForSystemEvent(smlSystemEventId id, SystemEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForSystemEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int RegisterForUpdateEvent(smlUpdateEventId id, UpdateEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForUpdateEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int RegisterForStringEvent(smlStringEventId id, StringEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForStringEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int RegisterForAgentEvent(smlAgentEventId id, AgentEventInterface handlerObject, Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForAgentEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    public int AddRhsFunction(final String functionName, final RhsFunctionInterface handlerObject, final Object callbackData)
    {
        final int id = nextRhsFunctionId++;
        final JSoarRhsFunctionAdapter prototype = JSoarRhsFunctionAdapter.create(null, functionName, handlerObject, callbackData);
        rhsFunctionHandlers.put(id, prototype);
        
        for(final Agent a : m_AgentMap.values())
        {
            a.addRhsFunction(id, prototype.copy(a.GetAgentName()));
        }
        return id;
    }

    public boolean RemoveRhsFunction(int callbackReturnValue)
    {
        final boolean result = null != rhsFunctionHandlers.remove(callbackReturnValue);
        for(Agent a : m_AgentMap.values())
        {
            a.removeRhsFunction(callbackReturnValue);
        }
        return result;
    }

    public int RegisterForClientMessageEvent(String functionName, ClientMessageInterface handlerObject,
            Object callbackData)
    {
        throw new UnsupportedOperationException("");
    }

    public boolean UnregisterForClientMessageEvent(int callbackReturnValue)
    {
        throw new UnsupportedOperationException("");
    }

    // In Java we want to explicitly delete the C++ kernel object after calling
    // shutdown so that the user
    // doesn't have to call ".delete()" on their Java object (or wait for the
    // garbage collector to do it which may never run--leading to
    // reports of memory leaks on shutdown). In C++ users expect to have to
    // delete their kernel pointer but not in Java.
    public void Shutdown()
    {
        m_bShutdown = true ;

        delete();
    }

    // Allow a user to avoid deleting the kernel object immediately, if they
    // have some special reason.
    public void ShutdownNoDelete()
    {
        throw new UnsupportedOperationException("");
    }

    public static String getKDefaultLibraryName()
    {
        throw new UnsupportedOperationException("");
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName, boolean optimized, int portToListenOn)
    {
        return new Kernel();
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName, boolean optimized)
    {
        return CreateKernelInCurrentThread(pLibraryName, optimized, kDefaultSMLPort);
    }

    public static Kernel CreateKernelInCurrentThread(String pLibraryName)
    {
        return CreateKernelInCurrentThread(pLibraryName, false);
    }

    public static Kernel CreateKernelInCurrentThread()
    {
        return CreateKernelInCurrentThread(kDefaultLibraryName);
    }

    public static Kernel CreateKernelInNewThread(String pLibraryName, int portToListenOn)
    {
        return new Kernel(); // TODO
    }

    public static Kernel CreateKernelInNewThread(String pLibraryName)
    {
        return CreateKernelInNewThread(pLibraryName, kDefaultSMLPort);
    }

    public static Kernel CreateKernelInNewThread()
    {
        return CreateKernelInNewThread(kDefaultLibraryName);
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress, int port,
            boolean ignoreOutput)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress, int port)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem, String pIPaddress)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection(boolean sharedFileSystem)
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    public static Kernel CreateRemoteConnection()
    {
        // TODO implement CreateRemoteConnection
        throw new UnsupportedOperationException();
    }

    /**
     * @return
     */
    public static int GetDefaultPort()
    {
        return 12121; // smlJNI.Kernel_GetDefaultPort();
    }

    /**
     * @return
     */
    public static String GetDefaultLibraryName()
    {
        return "SoarKernelSML"; // smlJNI.Kernel_GetDefaultLibraryName();
    }

    public void SetAutoCommit(boolean state)
    {
        m_bAutoCommit = state;
    }

    public boolean IsAutoCommitEnabled()
    {
        return m_bAutoCommit;
    }

    public boolean IsConnectionClosed()
    {
        return false;
    }

    public boolean IsRemoteConnection()
    {
        return false;
    }

    public boolean IsDirectConnection()
    {
        return true;
    }

    public void ShutdownInternal()
    {
        // TODO implement ShutdownInternal
        throw new UnsupportedOperationException("ShutdownInternal");
    }

    public void SetTraceCommunications(boolean state)
    {
        // We keep a local copy of this value so we can check it without
        // calling anywhere.
        m_bTracingCommunications = state ;
    }

    public boolean IsTracingCommunications()
    {
        return m_bTracingCommunications ;
    }

    public Agent CreateAgent(String pAgentName)
    {
        return MakeAgent(pAgentName);
    }

    public void UpdateAgentList()
    {
    }

    public int GetNumberAgents()
    {
        return m_AgentMap.size();
    }

    public boolean DestroyAgent(Agent pAgent)
    {
        // Remove the object from our map and delete it.
        m_AgentMap.remove(pAgent.GetAgentName(), true) ;
        return true ;
    }

    public Agent GetAgent(String pAgentName)
    {
        if (pAgentName == null)
            return null;

        return m_AgentMap.find(pAgentName) ;
    }

    public Agent GetAgentByIndex(int index)
    {
        return m_AgentMap.getIndex(index) ;
    }

    public boolean IsAgentValid(Agent pAgent)
    {
        // We check the current list of agent pointers and see if this value is in that list
        // to determine if it is still valid.
        return m_AgentMap.contains(pAgent) ;
    }

    public void EnableFiltering(boolean state)
    {
        m_FilteringEnabled = state ;
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName, boolean echoResults, boolean noFilter)
    {
        final Agent agent = GetAgent(pAgentName);
        if(agent != null)
        {
            return agent.ExecuteCommandLine(pCommandLine, echoResults, noFilter);
        }
        else
        {
            return "";
        }
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName, boolean echoResults)
    {
        return ExecuteCommandLine(pCommandLine, pAgentName, echoResults, false);
    }

    public String ExecuteCommandLine(String pCommandLine, String pAgentName)
    {
        return ExecuteCommandLine(pCommandLine, pAgentName, false);
    }

    public boolean ExecuteCommandLineXML(String pCommandLine, String pAgentName, ClientAnalyzedXML pResponse)
    {
        throw new UnsupportedOperationException("ExecuteCommandLineXML");
    }

    public String RunAllAgents(long numberSteps, smlRunStepSize stepSize, smlRunStepSize interleaveStepSize)
    {
        // TODO implement RunAllAgents
        throw new UnsupportedOperationException();
    }

    public String RunAllAgents(long numberSteps, smlRunStepSize stepSize)
    {
        // TODO implement RunAllAgents
        throw new UnsupportedOperationException();
    }

    public String RunAllAgents(long numberSteps)
    {
        // TODO implement RunAllAgents
        throw new UnsupportedOperationException();
    }

    public String RunAllAgentsForever(smlRunStepSize interleaveStepSize)
    {
        // TODO implement RunAllAgentsForever
        throw new UnsupportedOperationException();
    }

    public String RunAllAgentsForever()
    {
        // TODO implement RunAllAgentsForever
        throw new UnsupportedOperationException();
    }

    public String RunAllTilOutput(smlRunStepSize interleaveStepSize)
    {
        // TODO implement RunAllTilOutput
        throw new UnsupportedOperationException();
    }

    public String RunAllTilOutput()
    {
        // TODO implement RunAllTilOutput
        throw new UnsupportedOperationException();
    }

    public String StopAllAgents()
    {
        // TODO implement StopAllAgents
        throw new UnsupportedOperationException();
    }

    public boolean IsSoarRunning()
    {
        // TODO implement IsSoarRunning
        throw new UnsupportedOperationException();
    }

    public boolean GetAllConnectionInfo()
    {
        return false;
    }

    public int GetNumberConnections()
    {
        return m_ConnectionInfoList.size();
    }

    public boolean HasConnectionInfoChanged()
    {
        return m_ConnectionInfoChanged ;
    }

    public ConnectionInfo GetConnectionInfo(int i)
    {
        return m_ConnectionInfoList.get(i);
    }

    public String GetConnectionStatus(String pConnectionName)
    {
        for(ConnectionInfo info : m_ConnectionInfoList)
        {
            if(info.GetName() != null && info.GetName().equals(pConnectionName))
            {
                return info.GetConnectionStatus();
            }
        }
        return null;
    }

    public String GetAgentStatus(String pConnectionName)
    {
        for(ConnectionInfo info : m_ConnectionInfoList)
        {
            if(info.GetName() != null && info.GetName().equals(pConnectionName))
            {
                return info.GetAgentStatus();
            }
        }
        return null;
    }

    public boolean SetConnectionInfo(String pName, String pConnectionStatus, String pAgentStatus)
    {
        return true;
    }

    public boolean FireStartSystemEvent()
    {
        // TODO implement FireStartSystemEvent
        throw new UnsupportedOperationException();
    }

    public boolean FireStopSystemEvent()
    {
        // TODO implement FireStopSystemEvent
        throw new UnsupportedOperationException();
    }

    public boolean SuppressSystemStop(boolean state)
    {
        // TODO implement SuppressSystemStop
        throw new UnsupportedOperationException();
    }

    public String ExpandCommandLine(String pCommandLine)
    {
        // TODO implement ExpandCommandLine
        throw new UnsupportedOperationException();
    }

    public boolean GetLastCommandLineResult()
    {
        // TODO implement GetLastCommandLineResult
        throw new UnsupportedOperationException();
    }

    public boolean IsRunCommand(String pCommandLine)
    {
        // TODO implement IsRunCommand
        throw new UnsupportedOperationException();
    }

    public boolean IsStopCommand(String pCommandLine)
    {
        // TODO implement IsStopCommand
        throw new UnsupportedOperationException();
    }

    public boolean CheckForIncomingCommands()
    {
        // TODO implement CheckForIncomingCommands
        throw new UnsupportedOperationException();
    }

    public boolean CheckForIncomingEvents()
    {
        // TODO implement CheckForIncomingEvents
        throw new UnsupportedOperationException();
    }

    public boolean StartEventThread()
    {
        // This thread is used to listen for events from the kernel
        // when the client is sleeping
// TODO       if (m_pEventThread == null)
//            return false ;
//
//        m_pEventThread.Start() ;

        return true ;
    }

    public boolean StopEventThread()
    {
        // Shut down the event thread
// TODO       if (m_pEventThread == null)
//            return false ;
//
//        m_pEventThread.Stop(true) ;

        return true ;
    }

    public boolean SetInterruptCheckRate(int newRate)
    {
        // TODO implement SetInterruptCheckRate
        throw new UnsupportedOperationException();
    }

    public int RegisterForClientMessageEvent(String pClientName,
            SWIGTYPE_p_f_sml__smlRhsEventId_p_void_p_sml__Agent_p_q_const__char_p_q_const__char__std__string handler,
            SWIGTYPE_p_void pUserData, boolean addToBack)
    {
        // TODO implement RegisterForClientMessageEvent
        throw new UnsupportedOperationException();
    }

    public int RegisterForClientMessageEvent(String pClientName,
            SWIGTYPE_p_f_sml__smlRhsEventId_p_void_p_sml__Agent_p_q_const__char_p_q_const__char__std__string handler,
            SWIGTYPE_p_void pUserData)
    {
        // TODO implement RegisterForClientMessageEvent
        throw new UnsupportedOperationException();
    }

    public String SendClientMessage(Agent pAgent, String pClientName, String pMessage)
    {
        // TODO implement SendClientMessage
        throw new UnsupportedOperationException();
    }

    public String GetLibraryLocation()
    {
        throw new UnsupportedOperationException();
    }

    public String GetSoarKernelVersion()
    {
        return JSoarVersion.getInstance().getVersion();
    }

    public void CommitAll()
    {
        final int numberAgents = GetNumberAgents() ;

        for (int i = 0 ; i < numberAgents ; i++)
        {
            Agent pAgent = GetAgentByIndex(i) ;
            pAgent.Commit() ;
        }
    }

    public boolean IsCommitRequired()
    {
        final int numberAgents = GetNumberAgents() ;

        for (int i = 0 ; i < numberAgents ; i++)
        {
            Agent pAgent = GetAgentByIndex(i) ;
            if (pAgent.GetWM().IsCommitRequired())
                return true ;
        }

        return false ;
    }

    public String LoadExternalLibrary(String pLibraryCommand)
    {
        // TODO implement LoadExternalLibrary
        throw new UnsupportedOperationException();
    }

    public SWIGTYPE_p_sml__Connection GetConnection()
    {
        // TODO implement GetConnection
        throw new UnsupportedOperationException();
    }

    public final static int kDefaultSMLPort = 12121;
    private final static String kDefaultLibraryName = "SoarKernelSML";
    
}
