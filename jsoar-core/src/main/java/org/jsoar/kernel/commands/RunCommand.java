package org.jsoar.kernel.commands;

import org.jsoar.kernel.Agent;
import org.jsoar.kernel.RunType;
import org.jsoar.kernel.SoarException;
import org.jsoar.runtime.ThreadedAgent;
import org.jsoar.util.commands.SoarCommand;
import org.jsoar.util.commands.SoarCommandContext;

import picocli.CommandLine.Command;
import picocli.CommandLine.HelpCommand;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

/**
 * This is the implementation of the "run" command.
 * @author austin.brehob
 */
public class RunCommand implements SoarCommand
{
    private Agent agent;
    private ThreadedAgent tAgent;
    
    public RunCommand(Agent agent)
    {
        this.agent = agent;
    }
    
    public RunCommand(ThreadedAgent tAgent)
    {
        this.tAgent = tAgent;
    }

    @Override
    public Object getCommand()
    {
        return new Run(agent, tAgent);
    }

    @Override
    public String execute(SoarCommandContext context, String[] args) throws SoarException
    {
        // The agent is set here instead of in the constructor because the
        // Threaded Agent may not have an agent when this class is constructed
        if (tAgent != null)
        {
            this.agent = tAgent.getAgent();
        }
        Utils.parseAndRun(agent, new Run(agent, tAgent), args);

        return "";
    }


    @Command(name="run", description="Begin Soar's execution cycle",
            subcommands={HelpCommand.class})
    static public class Run implements Runnable
    {
        private Agent agent;
        private ThreadedAgent tAgent;

        public Run(Agent agent, ThreadedAgent tAgent)
        {
            this.agent = agent;
            this.tAgent = tAgent;
        }
        
        @Option(names={"-d", "--decision"}, description="Run Soar for <count> decision cycles")
        boolean runDecision = false;

        @Option(names={"-e", "--elaboration"}, description="Run Soar for <count> elaboration cycles")
        boolean runElaboration = false;

        @Option(names={"-p", "--phase"}, description="Run Soar for <count> phases")
        boolean runPhase = false;

        @Option(names={"-f", "--forever"}, description="Run forever")
        boolean runForever = false;

        @Option(names={"-o", "--output"}, description="Run Soar until "
                + "the <count>th time output is generated by the agent")
        boolean runOutput = false;

        @Parameters(arity="0..1", description="A single integer which "
                + "specifies the number of cycles to run Soar")
        Integer count = null;

        @Override
        public void run()
        {
            RunType type = null;

            if (runDecision)
            {
                type = RunType.DECISIONS;
            }
            else if (runElaboration)
            {
                type = RunType.ELABORATIONS;
            }
            else if (runPhase)
            {
                type = RunType.PHASES;
            }
            else if (runForever)
            {
                type = RunType.FOREVER;
            }
            else if (runOutput)
            {
                type = RunType.MODIFICATIONS_OF_OUTPUT;
            }
            else
            {
                type = RunType.FOREVER;
            }

            if (count == null)
            {
                count = 1;
            }

            if (tAgent != null)
            {
                tAgent.runFor(count, type);
            }
            else
            {
                agent.runFor(count, type);
            }
        }
    }
}
