Unified diff of tagged version and first update since smem port

#########################################################
# smem.h
#########################################################

Index: D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.h
===================================================================
--- D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.h	(.../trunk/SoarSuite/Core/SoarKernel/src/semantic_memory.h)	(revision 12072)
+++ D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.h	(.../tags/jsoar-epmem-root/Core/SoarKernel/src/semantic_memory.h)	(revision 13762)
@@ -46,8 +46,12 @@
 	public:
 		enum db_choices { memory, file };
 		enum cache_choices { cache_S, cache_M, cache_L };
+		enum page_choices { page_1k, page_2k, page_4k, page_8k, page_16k, page_32k, page_64k };
 		enum opt_choices { opt_safety, opt_speed };
 
+		enum merge_choices { merge_none, merge_add };
+		enum act_choices { act_recency, act_frequency, act_base };
+
 		soar_module::boolean_param *learning;
 		soar_module::constant_param<db_choices> *database;
 		smem_path_param *path;
@@ -55,11 +59,24 @@
 
 		soar_module::constant_param<soar_module::timer::timer_level> *timers;
 
-		soar_module::constant_param<cache_choices> *cache;
+		soar_module::constant_param<page_choices> *page_size;
+		soar_module::integer_param *cache_size;
 		soar_module::constant_param<opt_choices> *opt;
 
 		soar_module::integer_param *thresh;
 
+		soar_module::constant_param<merge_choices>* merge;
+		soar_module::boolean_param* activate_on_query;
+		soar_module::constant_param<act_choices>* activation_mode;
+		soar_module::decimal_param* base_decay;
+
+		enum base_update_choices { bupt_stable, bupt_naive, bupt_incremental };
+		soar_module::constant_param<base_update_choices>* base_update;
+
+		soar_module::int_set_param* base_incremental_threshes;
+
+		soar_module::boolean_param* mirroring;
+
 		smem_param_container( agent *new_agent );
 };
 
@@ -86,45 +103,63 @@
 // SMem Statistics
 //////////////////////////////////////////////////////////
 
+class smem_db_lib_version_stat;
 class smem_mem_usage_stat;
 class smem_mem_high_stat;
 
 class smem_stat_container: public soar_module::stat_container
 {
 	public:
+		smem_db_lib_version_stat* db_lib_version;
 		smem_mem_usage_stat *mem_usage;
 		smem_mem_high_stat *mem_high;
 
 		soar_module::integer_stat *expansions;
 		soar_module::integer_stat *cbr;
 		soar_module::integer_stat *stores;
+		soar_module::integer_stat *act_updates;
+		soar_module::integer_stat *mirrors;
 
-		soar_module::intptr_stat *chunks;
-		soar_module::intptr_stat *slots;
+		soar_module::integer_stat *chunks;
+		soar_module::integer_stat *slots;
 
 		smem_stat_container( agent *my_agent );
 };
 
-class smem_mem_usage_stat: public soar_module::intptr_stat
+//
+
+class smem_db_lib_version_stat: public soar_module::primitive_stat< const char* >
 {
 	protected:
+		agent* my_agent;
+
+	public:
+		smem_db_lib_version_stat( agent* new_agent, const char* new_name, const char* new_value, soar_module::predicate< const char* >* new_prot_pred );
+		const char* get_value();
+};
+
+//
+
+class smem_mem_usage_stat: public soar_module::integer_stat
+{
+	protected:
 		agent *my_agent;
 
 	public:
-		smem_mem_usage_stat( agent *new_agent, const char *new_name, intptr_t new_value, soar_module::predicate<intptr_t> *new_prot_pred );
-		intptr_t get_value();
+		smem_mem_usage_stat( agent *new_agent, const char *new_name, int64_t new_value, soar_module::predicate<int64_t> *new_prot_pred );
+		int64_t get_value();
 };
 
 //
 
-class smem_mem_high_stat: public soar_module::intptr_stat
+class smem_mem_high_stat: public soar_module::integer_stat
 {
 	protected:
 		agent *my_agent;
 
 	public:
-		smem_mem_high_stat( agent *new_agent, const char *new_name, intptr_t new_value, soar_module::predicate<intptr_t> *new_prot_pred );
-		intptr_t get_value();
+		smem_mem_high_stat( agent *new_agent, const char *new_name, int64_t new_value, soar_module::predicate<int64_t> *new_prot_pred );
+		int64_t get_value();
 };
 
 
@@ -191,14 +226,15 @@
 		soar_module::sqlite_statement *lti_get;
 		soar_module::sqlite_statement *lti_letter_num;
 		soar_module::sqlite_statement *lti_max;
+		soar_module::sqlite_statement *lti_access_get;
+		soar_module::sqlite_statement *lti_access_set;
+		soar_module::sqlite_statement *lti_get_t;
 
 		soar_module::sqlite_statement *web_add;
 		soar_module::sqlite_statement *web_truncate;
 		soar_module::sqlite_statement *web_expand;
 
-		soar_module::sqlite_statement *web_attr_ct;
-		soar_module::sqlite_statement *web_const_ct;
-		soar_module::sqlite_statement *web_lti_ct;
+		soar_module::sqlite_statement *web_all;
 
 		soar_module::sqlite_statement *web_attr_all;
 		soar_module::sqlite_statement *web_const_all;
@@ -230,7 +266,12 @@
 		soar_module::sqlite_statement *act_lti_set;
 		soar_module::sqlite_statement *act_lti_get;
 
+		soar_module::sqlite_statement *history_get;
+		soar_module::sqlite_statement *history_push;
+		soar_module::sqlite_statement *history_add;
+
 		soar_module::sqlite_statement *vis_lti;
+		soar_module::sqlite_statement *vis_lti_act;
 		soar_module::sqlite_statement *vis_value_const;
 		soar_module::sqlite_statement *vis_value_lti;
 
@@ -244,18 +285,24 @@
 
 enum smem_variable_key
 {
-	var_max_cycle, var_num_nodes, var_num_edges, var_act_thresh
+	var_max_cycle, var_num_nodes, var_num_edges, var_act_thresh, var_act_mode
 };
 
-#define SMEM_ACT_MAX static_cast<uintptr_t>( static_cast<uintptr_t>( 0 - 1 ) / static_cast<uintptr_t>(2) )
+#define SMEM_ACT_MAX static_cast<uint64_t>( static_cast<uint64_t>( 0 - 1 ) / static_cast<uint64_t>(2) )
 
 #define SMEM_LTI_UNKNOWN_LEVEL 0
 
+#define SMEM_WEB_NULL 0
+#define SMEM_WEB_NULL_STR "0"
+
+#define SMEM_ACT_HISTORY_ENTRIES 10
+#define SMEM_ACT_LOW -1000000000
+
 // provides a distinct prefix to be used by all
 // tables for two reasons:
 // - distinguish from other modules
 // - distinguish between smem versions
-#define SMEM_SCHEMA "smem3_"
+#define SMEM_SCHEMA "smem7_"
 
 // empty table used to verify proper structure
 #define SMEM_SIGNATURE SMEM_SCHEMA "signature"
@@ -266,10 +313,10 @@
 
 // represents the unique identification of a
 // long-term identifier
-typedef uintptr_t smem_lti_id;
+typedef uint64_t smem_lti_id;
 
 // represents a temporal hash
-typedef uintptr_t smem_hash_id;
+typedef uint64_t smem_hash_id;
 
 // represents a collection of long-term identifiers
 typedef std::list<smem_lti_id> smem_lti_list;
@@ -284,14 +331,27 @@
 // represents a list of wmes
 typedef std::list<wme *> smem_wme_list;
 
+// represents a set of symbols
+#ifdef USE_MEM_POOL_ALLOCATORS
+typedef std::set< Symbol*, std::less< Symbol* >, soar_module::soar_memory_pool_allocator< Symbol* > > smem_pooled_symbol_set;
+#else
+typedef std::set< Symbol* > smem_pooled_symbol_set;
+#endif
+
+// list used primarily like a stack
+#ifdef USE_MEM_POOL_ALLOCATORS
+typedef std::list< preference*, soar_module::soar_memory_pool_allocator< preference* > > smem_wme_stack;
+#else
+typedef std::list< preference* > smem_wme_stack;
+#endif
+
 // data associated with each state
 typedef struct smem_data_struct
 {
-	unsigned long last_cmd_time[2];			// last update to smem.command
-	unsigned long last_cmd_count[2];		// last update to smem.command
+	uint64_t last_cmd_time[2];			// last update to smem.command
+	uint64_t last_cmd_count[2];			// last update to smem.command
 
-	std::set<wme *> *cue_wmes;				// wmes in last cue
-	std::stack<preference *> *smem_wmes;	// wmes in last smem
+	smem_wme_stack* smem_wmes;			// wmes in last smem
 } smem_data;
 
 //
@@ -300,7 +360,7 @@
 
 typedef struct smem_weighted_cue_element_struct
 {
-	uintptr_t weight;
+	uint64_t weight;
 
 	struct wme_struct *cue_element;
 	smem_hash_id attr_hash;
@@ -308,6 +368,7 @@
 	smem_lti_id value_lti;
 
 	smem_cue_element_type element_type;
+	bool pos_element;
 
 } smem_weighted_cue_element;
 
@@ -322,7 +383,7 @@
 typedef std::priority_queue<smem_weighted_cue_element *, std::vector<smem_weighted_cue_element *>, smem_compare_weighted_cue_elements> smem_prioritized_weighted_cue;
 typedef std::list<smem_weighted_cue_element *> smem_weighted_cue_list;
 
-typedef std::pair< intptr_t, smem_lti_id > smem_activated_lti;
+typedef std::pair< double, smem_lti_id > smem_activated_lti;
 
 struct smem_compare_activated_lti
 {
@@ -381,7 +442,7 @@
 	public:
 		smem_lti_id lti_id;
 		std::string lti_name;
-		unsigned long level;
+		unsigned int level;
 } smem_vis_lti;
 
 //
@@ -399,7 +460,9 @@
 extern bool smem_parse_chunks( agent *my_agent, const char *chunks, std::string **err_msg );
 
 extern void smem_visualize_store( agent *my_agent, std::string *return_val );
-extern void smem_visualize_lti( agent *my_agent, smem_lti_id lti_id, unsigned long depth, std::string *return_val );
+extern void smem_visualize_lti( agent *my_agent, smem_lti_id lti_id, unsigned int depth, std::string *return_val );
+extern void smem_print_store( agent *my_agent, std::string *return_val );
+extern void smem_print_lti( agent *my_agent, smem_lti_id lti_id, unsigned int depth, std::string *return_val );
 
 typedef struct condition_struct condition;
 typedef struct action_struct action;
@@ -416,5 +479,6 @@
 
 // perform smem actions
 extern void smem_go( agent *my_agent, bool store_only );
+extern bool smem_backup_db( agent* my_agent, const char* file_name, std::string *err );
 
 #endif






#########################################################
# smem.cpp
#########################################################

Index: D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.cpp
===================================================================
--- D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.cpp	(.../trunk/SoarSuite/Core/SoarKernel/src/semantic_memory.cpp)	(revision 12124)
+++ D:/csoar-epmem-port-root/Core/SoarKernel/src/semantic_memory.cpp	(.../tags/jsoar-epmem-root/Core/SoarKernel/src/semantic_memory.cpp)	(revision 13762)

# comment changes

@@ -49,6 +49,7 @@
 
 // variables					smem::var
 // temporal hash				smem::hash
+// activation					smem::act
 // long-term identifiers		smem::lti
 
 // storage						smem::storage


############################
# smem_param_container()
# this probably goes in DefaultSemanticMemoryParams
@@ -100,12 +101,20 @@
 
 	//
 
-	// cache
-	cache = new soar_module::constant_param<cache_choices>( "cache", cache_L, new smem_db_predicate<cache_choices>( my_agent ) );
-	cache->add_mapping( cache_S, "small" );
-	cache->add_mapping( cache_M, "medium" );
-	cache->add_mapping( cache_L, "large" );
-	add( cache );
+	// page_size
+	page_size = new soar_module::constant_param<page_choices>( "page-size", page_8k, new smem_db_predicate<page_choices>( my_agent ) );
+	page_size->add_mapping( page_1k, "1k" );
+	page_size->add_mapping( page_2k, "2k" );
+	page_size->add_mapping( page_4k, "4k" );
+	page_size->add_mapping( page_8k, "8k" );
+	page_size->add_mapping( page_16k, "16k" );
+	page_size->add_mapping( page_32k, "32k" );
+	page_size->add_mapping( page_64k, "64k" );
+	add( page_size );
+	
+	// cache_size
+	cache_size = new soar_module::integer_param( "cache-size", 10000, new soar_module::gt_predicate<int64_t>( 1, true ), new smem_db_predicate<int64_t>( my_agent ) );
+	add( cache_size );
 
 	// opt
 	opt = new soar_module::constant_param<opt_choices>( "optimization", opt_speed, new smem_db_predicate<opt_choices>( my_agent ) );
@@ -114,8 +123,44 @@
 	add( opt );
 
 	// thresh
-	thresh = new soar_module::integer_param( "thresh", 100, new soar_module::predicate<long>(), new smem_db_predicate<long>( my_agent ) );
+	thresh = new soar_module::integer_param( "thresh", 100, new soar_module::predicate<int64_t>(), new smem_db_predicate<int64_t>( my_agent ) );
 	add( thresh );
+
+	// merge
+	merge = new soar_module::constant_param<merge_choices>( "merge", merge_add, new soar_module::f_predicate<merge_choices>() );
+	merge->add_mapping( merge_none, "none" );
+	merge->add_mapping( merge_add, "add" );
+	add( merge );
+	
+	// activate_on_query
+	activate_on_query = new soar_module::boolean_param( "activate-on-query", soar_module::on, new soar_module::f_predicate<soar_module::boolean>() );
+	add( activate_on_query );
+	
+	// activation_mode
+	activation_mode = new soar_module::constant_param<act_choices>( "activation-mode", act_recency, new soar_module::f_predicate<act_choices>() );
+	activation_mode->add_mapping( act_recency, "recency" );
+	activation_mode->add_mapping( act_frequency, "frequency" );
+	activation_mode->add_mapping( act_base, "base-level" );
+	add( activation_mode );
+
+	// base_decay
+	base_decay = new soar_module::decimal_param( "base-decay", 0.5, new soar_module::gt_predicate<double>( 0, false ), new soar_module::f_predicate<double>() );
+	add( base_decay );
+
+	// base_update_policy
+	base_update = new soar_module::constant_param<base_update_choices>( "base-update-policy", bupt_stable, new soar_module::f_predicate<base_update_choices>() );
+	base_update->add_mapping( bupt_stable, "stable" );
+	base_update->add_mapping( bupt_naive, "naive" );
+	base_update->add_mapping( bupt_incremental, "incremental" );
+	add( base_update );
+
+	// incremental update thresholds
+	base_incremental_threshes = new soar_module::int_set_param( "base-incremental-threshes", new soar_module::f_predicate< int64_t >() );
+	add( base_incremental_threshes );
+
+	// mirroring
+	mirroring = new soar_module::boolean_param( "mirroring", soar_module::off, new smem_db_predicate< soar_module::boolean >( my_agent ) );
+	add( mirroring );
 }
 
 //
 
 ############################
 # smem_stat_container()
 # # this probably goes in DefaultSemanticMemoryStatistics
 
@@ -160,53 +205,74 @@
 
 smem_stat_container::smem_stat_container( agent *new_agent ): soar_module::stat_container( new_agent )
 {
+	// db-lib-version
+	db_lib_version = new smem_db_lib_version_stat( my_agent, "db-lib-version", NULL, new soar_module::predicate< const char* >() );
+	add( db_lib_version );
+	
 	// mem-usage
-	mem_usage = new smem_mem_usage_stat( my_agent, "mem-usage", 0, new soar_module::predicate<intptr_t>() );
+	mem_usage = new smem_mem_usage_stat( my_agent, "mem-usage", 0, new soar_module::predicate<int64_t>() );
 	add( mem_usage );
 
 	// mem-high
-	mem_high = new smem_mem_high_stat( my_agent, "mem-high", 0, new soar_module::predicate<intptr_t>() );
+	mem_high = new smem_mem_high_stat( my_agent, "mem-high", 0, new soar_module::predicate<int64_t>() );
 	add( mem_high );
 
 	//
 
 	// expansions
-	expansions = new soar_module::integer_stat( "retrieves", 0, new soar_module::f_predicate<long>() );
+	expansions = new soar_module::integer_stat( "retrieves", 0, new soar_module::f_predicate<int64_t>() );
 	add( expansions );
 
 	// cue-based-retrievals
-	cbr = new soar_module::integer_stat( "queries", 0, new soar_module::f_predicate<long>() );
+	cbr = new soar_module::integer_stat( "queries", 0, new soar_module::f_predicate<int64_t>() );
 	add( cbr );
 
 	// stores
-	stores = new soar_module::integer_stat( "stores", 0, new soar_module::f_predicate<long>() );
+	stores = new soar_module::integer_stat( "stores", 0, new soar_module::f_predicate<int64_t>() );
 	add( stores );
 
+	// activations
+	act_updates = new soar_module::integer_stat( "act_updates", 0, new soar_module::f_predicate<int64_t>() );
+	add( act_updates );
+
+	// mirrors
+	mirrors = new soar_module::integer_stat( "mirrors", 0, new soar_module::f_predicate<int64_t>() );
+	add( mirrors );
+
 	//
 
 	// chunks
-	chunks = new soar_module::intptr_stat( "nodes", 0, new soar_module::f_predicate<intptr_t>() );
+	chunks = new soar_module::integer_stat( "nodes", 0, new smem_db_predicate< int64_t >( my_agent ) );
 	add( chunks );
 
 	// slots
-	slots = new soar_module::intptr_stat( "edges", 0, new soar_module::f_predicate<intptr_t>() );
+	slots = new soar_module::integer_stat( "edges", 0, new smem_db_predicate< int64_t >( my_agent ) );
 	add( slots );
 }
 
 //
 
-smem_mem_usage_stat::smem_mem_usage_stat( agent *new_agent, const char *new_name, intptr_t new_value, soar_module::predicate<intptr_t> *new_prot_pred ): soar_module::intptr_stat( new_name, new_value, new_prot_pred ), my_agent( new_agent ) {}
+smem_db_lib_version_stat::smem_db_lib_version_stat( agent* new_agent, const char* new_name, const char* new_value, soar_module::predicate< const char* >* new_prot_pred ): soar_module::primitive_stat< const char* >( new_name, new_value, new_prot_pred ), my_agent( new_agent ) {}
 
-intptr_t smem_mem_usage_stat::get_value()
+const char* smem_db_lib_version_stat::get_value()
 {
+	return my_agent->smem_db->lib_version();
+}
+
+//
+
+smem_mem_usage_stat::smem_mem_usage_stat( agent *new_agent, const char *new_name, int64_t new_value, soar_module::predicate<int64_t> *new_prot_pred ): soar_module::integer_stat( new_name, new_value, new_prot_pred ), my_agent( new_agent ) {}
+
+int64_t smem_mem_usage_stat::get_value()
+{
 	return my_agent->smem_db->memory_usage();
 }
 
 //
 
-smem_mem_high_stat::smem_mem_high_stat( agent *new_agent, const char *new_name, intptr_t new_value, soar_module::predicate<intptr_t> *new_prot_pred ): soar_module::intptr_stat( new_name, new_value, new_prot_pred ), my_agent( new_agent ) {}
+smem_mem_high_stat::smem_mem_high_stat( agent *new_agent, const char *new_name, int64_t new_value, soar_module::predicate<int64_t> *new_prot_pred ): soar_module::integer_stat( new_name, new_value, new_prot_pred ), my_agent( new_agent ) {}
 
-intptr_t smem_mem_high_stat::get_value()
+int64_t smem_mem_high_stat::get_value()
 {
 	return my_agent->smem_db->memory_highwater();
 }
@@ -282,13 +348,16 @@
 	add_structure( "CREATE TABLE " SMEM_SCHEMA "symbols_str (id INTEGER PRIMARY KEY, sym_const TEXT)" );
 	add_structure( "CREATE UNIQUE INDEX " SMEM_SCHEMA "symbols_str_const ON " SMEM_SCHEMA "symbols_str (sym_const)" );	
 
-	add_structure( "CREATE TABLE " SMEM_SCHEMA "lti (id INTEGER PRIMARY KEY, letter INTEGER, num INTEGER, child_ct INTEGER, act_cycle INTEGER)" );
+	add_structure( "CREATE TABLE " SMEM_SCHEMA "lti (id INTEGER PRIMARY KEY, letter INTEGER, num INTEGER, child_ct INTEGER, act_value REAL, access_n INTEGER, access_t INTEGER, access_1 INTEGER)" );
 	add_structure( "CREATE UNIQUE INDEX " SMEM_SCHEMA "lti_letter_num ON " SMEM_SCHEMA "lti (letter, num)" );
+	add_structure( "CREATE INDEX " SMEM_SCHEMA "lti_t ON " SMEM_SCHEMA "lti (access_t)" );
 
-	add_structure( "CREATE TABLE " SMEM_SCHEMA "web (parent_id INTEGER, attr INTEGER, val_const INTEGER, val_lti INTEGER, act_cycle INTEGER)" );
+	add_structure( "CREATE TABLE " SMEM_SCHEMA "history (id INTEGER PRIMARY KEY, t1 INTEGER, t2 INTEGER, t3 INTEGER, t4 INTEGER, t5 INTEGER, t6 INTEGER, t7 INTEGER, t8 INTEGER, t9 INTEGER, t10 INTEGER)" );
+
+	add_structure( "CREATE TABLE " SMEM_SCHEMA "web (parent_id INTEGER, attr INTEGER, val_const INTEGER, val_lti INTEGER, act_value REAL)" );
 	add_structure( "CREATE INDEX " SMEM_SCHEMA "web_parent_attr_val_lti ON " SMEM_SCHEMA "web (parent_id, attr, val_const, val_lti)" );
-	add_structure( "CREATE INDEX " SMEM_SCHEMA "web_attr_val_lti_cycle ON " SMEM_SCHEMA "web (attr, val_const, val_lti, act_cycle)" );
-	add_structure( "CREATE INDEX " SMEM_SCHEMA "web_attr_cycle ON " SMEM_SCHEMA "web (attr, act_cycle)" );
+	add_structure( "CREATE INDEX " SMEM_SCHEMA "web_attr_val_lti_cycle ON " SMEM_SCHEMA "web (attr, val_const, val_lti, act_value)" );
+	add_structure( "CREATE INDEX " SMEM_SCHEMA "web_attr_cycle ON " SMEM_SCHEMA "web (attr, act_value)" );
 
 	add_structure( "CREATE TABLE " SMEM_SCHEMA "ct_attr (attr INTEGER PRIMARY KEY, ct INTEGER)" );


#############################
# smem_statement_container()
# updates to SemanticMemoryDatabase and statements.properties (in resources)
@@ -386,7 +455,7 @@
 
 	//
 
-	lti_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "lti (letter,num,child_ct,act_cycle) VALUES (?,?,?,?)" );
+	lti_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "lti (letter,num,child_ct,act_value,access_n,access_t,access_1) VALUES (?,?,?,?,?,?,?)" );
 	add( lti_add );
 
 	lti_get = new soar_module::sqlite_statement( new_db, "SELECT id FROM " SMEM_SCHEMA "lti WHERE letter=? AND num=?" );
@@ -398,9 +467,18 @@
 	lti_max = new soar_module::sqlite_statement( new_db, "SELECT letter, MAX(num) FROM " SMEM_SCHEMA "lti GROUP BY letter" );
 	add( lti_max );
 
+	lti_access_get = new soar_module::sqlite_statement( new_db, "SELECT access_n, access_t, access_1 FROM " SMEM_SCHEMA "lti WHERE id=?" );
+	add( lti_access_get );
+
+	lti_access_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "lti SET access_n=?, access_t=?, access_1=? WHERE id=?" );
+	add( lti_access_set );
+
+	lti_get_t = new soar_module::sqlite_statement( new_db, "SELECT id FROM " SMEM_SCHEMA "lti WHERE access_t=?" );
+	add ( lti_get_t );
+
 	//
 
-	web_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "web (parent_id, attr, val_const, val_lti, act_cycle) VALUES (?,?,?,?,?)" );
+	web_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "web (parent_id, attr, val_const, val_lti, act_value) VALUES (?,?,?,?,?)" );
 	add( web_add );
 
 	web_truncate = new soar_module::sqlite_statement( new_db, "DELETE FROM " SMEM_SCHEMA "web WHERE parent_id=?" );
@@ -411,24 +489,18 @@
 
 	//
 
-	web_attr_ct = new soar_module::sqlite_statement( new_db, "SELECT attr, COUNT(*) AS ct FROM " SMEM_SCHEMA "web WHERE parent_id=? GROUP BY attr" );
-	add( web_attr_ct );
+	web_all = new soar_module::sqlite_statement( new_db, "SELECT attr, val_const, val_lti FROM " SMEM_SCHEMA "web WHERE parent_id=?" );
+	add( web_all );
 
-	web_const_ct = new soar_module::sqlite_statement( new_db, "SELECT attr, val_const, COUNT(*) AS ct FROM " SMEM_SCHEMA "web WHERE parent_id=? AND val_const IS NOT NULL GROUP BY attr, val_const" );
-	add( web_const_ct );
-
-	web_lti_ct = new soar_module::sqlite_statement( new_db, "SELECT attr, val_lti, COUNT(*) AS ct FROM " SMEM_SCHEMA "web WHERE parent_id=? AND val_const IS NULL GROUP BY attr, val_const, val_lti" );
-	add( web_lti_ct );
-
 	//
 
-	web_attr_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_cycle FROM " SMEM_SCHEMA "web w WHERE attr=? ORDER BY act_cycle DESC" );
+	web_attr_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_value FROM " SMEM_SCHEMA "web w WHERE attr=? ORDER BY act_value DESC" );
 	add( web_attr_all );
 
-	web_const_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_cycle FROM " SMEM_SCHEMA "web w WHERE attr=? AND val_const=? AND val_lti IS NULL ORDER BY act_cycle DESC" );
+	web_const_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_value FROM " SMEM_SCHEMA "web w WHERE attr=? AND val_const=? AND val_lti=" SMEM_WEB_NULL_STR " ORDER BY act_value DESC" );
 	add( web_const_all );
 
-	web_lti_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_cycle FROM " SMEM_SCHEMA "web w WHERE attr=? AND val_const IS NULL AND val_lti=? ORDER BY act_cycle DESC" );
+	web_lti_all = new soar_module::sqlite_statement( new_db, "SELECT parent_id, act_value FROM " SMEM_SCHEMA "web w WHERE attr=? AND val_const=" SMEM_WEB_NULL_STR " AND val_lti=? ORDER BY act_value DESC" );
 	add( web_lti_all );
 
 	//
@@ -439,7 +511,7 @@
 	web_const_child = new soar_module::sqlite_statement( new_db, "SELECT parent_id FROM " SMEM_SCHEMA "web WHERE parent_id=? AND attr=? AND val_const=?" );
 	add( web_const_child );
 
-	web_lti_child = new soar_module::sqlite_statement( new_db, "SELECT parent_id FROM " SMEM_SCHEMA "web WHERE parent_id=? AND attr=? AND val_const IS NULL AND val_lti=?" );
+	web_lti_child = new soar_module::sqlite_statement( new_db, "SELECT parent_id FROM " SMEM_SCHEMA "web WHERE parent_id=? AND attr=? AND val_const=" SMEM_WEB_NULL_STR " AND val_lti=?" );
 	add( web_lti_child );
 
 	//
@@ -455,13 +527,13 @@
 
 	//
 
-	ct_attr_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_attr (attr, ct) VALUES (?,0)" );
+	ct_attr_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_attr (attr, ct) VALUES (?,1)" );
 	add( ct_attr_add );
 
-	ct_const_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_const (attr, val_const, ct) VALUES (?,?,0)" );
+	ct_const_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_const (attr, val_const, ct) VALUES (?,?,1)" );
 	add( ct_const_add );
 
-	ct_lti_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_lti (attr, val_lti, ct) VALUES (?,?,0)" );
+	ct_lti_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "ct_lti (attr, val_lti, ct) VALUES (?,?,1)" );
 	add( ct_lti_add );
 
 	//
@@ -488,7 +560,7 @@
 
 	//
 
-	act_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "web SET act_cycle=? WHERE parent_id=?" );
+	act_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "web SET act_value=? WHERE parent_id=?" );
 	add( act_set );
 
 	act_lti_child_ct_get = new soar_module::sqlite_statement( new_db, "SELECT child_ct FROM " SMEM_SCHEMA "lti WHERE id=?" );
@@ -497,21 +569,33 @@
 	act_lti_child_ct_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "lti SET child_ct=? WHERE id=?" );
 	add( act_lti_child_ct_set );
 
-	act_lti_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "lti SET act_cycle=? WHERE id=?" );
+	act_lti_set = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "lti SET act_value=? WHERE id=?" );
 	add( act_lti_set );
 
-	act_lti_get = new soar_module::sqlite_statement( new_db, "SELECT act_cycle FROM " SMEM_SCHEMA "lti WHERE id=?" );
+	act_lti_get = new soar_module::sqlite_statement( new_db, "SELECT act_value FROM " SMEM_SCHEMA "lti WHERE id=?" );
 	add( act_lti_get );
 
+	history_get = new soar_module::sqlite_statement( new_db, "SELECT t1,t2,t3,t4,t5,t6,t7,t8,t9,t10 FROM " SMEM_SCHEMA "history WHERE id=?" );
+	add( history_get );
+
+	history_push = new soar_module::sqlite_statement( new_db, "UPDATE " SMEM_SCHEMA "history SET t10=t9,t9=t8,t8=t7,t8=t7,t7=t6,t6=t5,t5=t4,t4=t3,t3=t2,t2=t1,t1=? WHERE id=?" );
+	add( history_push );
+
+	history_add = new soar_module::sqlite_statement( new_db, "INSERT INTO " SMEM_SCHEMA "history (id,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10) VALUES (?,?,0,0,0,0,0,0,0,0,0)" );
+	add( history_add );
+
 	//
 
-	vis_lti = new soar_module::sqlite_statement( new_db, "SELECT id, letter, num FROM " SMEM_SCHEMA "lti" );
+	vis_lti = new soar_module::sqlite_statement( new_db, "SELECT id, letter, num, act_value FROM " SMEM_SCHEMA "lti ORDER BY letter ASC, num ASC" );
 	add( vis_lti );
 
+	vis_lti_act = new soar_module::sqlite_statement( new_db, "SELECT act_value FROM " SMEM_SCHEMA "lti WHERE id=?" );
+	add( vis_lti_act );
+
 	vis_value_const = new soar_module::sqlite_statement( new_db, "SELECT parent_id, tsh1.sym_type AS attr_type, tsh1.id AS attr_hash, tsh2.sym_type AS val_type, tsh2.id AS val_hash FROM " SMEM_SCHEMA "web w, " SMEM_SCHEMA "symbols_type tsh1, " SMEM_SCHEMA "symbols_type tsh2 WHERE (w.attr=tsh1.id) AND (w.val_const=tsh2.id)" );
 	add( vis_value_const );
 
-	vis_value_lti = new soar_module::sqlite_statement( new_db, "SELECT parent_id, tsh.sym_type AS attr_type, tsh.id AS attr_hash, val_lti FROM " SMEM_SCHEMA "web w, " SMEM_SCHEMA "symbols_type tsh WHERE (w.attr=tsh.id) AND (val_lti IS NOT NULL)" );
+	vis_value_lti = new soar_module::sqlite_statement( new_db, "SELECT parent_id, tsh.sym_type AS attr_type, tsh.id AS attr_hash, val_lti FROM " SMEM_SCHEMA "web w, " SMEM_SCHEMA "symbols_type tsh WHERE (w.attr=tsh.id) AND (val_lti<>" SMEM_WEB_NULL_STR ")" );
 	add( vis_value_lti );
 }


###############################
# new function _smem_process_buffered_wme_list()
# removed functions _smem_add_wme()

@@ -583,39 +667,47 @@
 
 //
 
-void _smem_add_wme( agent *my_agent, Symbol *state, Symbol *id, Symbol *attr, Symbol *value, bool meta )
+inline void _smem_process_buffered_wme_list( agent* my_agent, Symbol* state, soar_module::wme_set& cue_wmes, soar_module::symbol_triple_list& my_list, bool meta )
 {
-	// this fake preference is just for this state.
-	// it serves the purpose of simulating a completely
-	// local production firing to provide backtracing
-	// information, making the result wmes dependent
-	// upon the cue wmes.
-	preference *pref = soar_module::make_fake_preference( my_agent, state, id, attr, value, state->id.smem_info->cue_wmes );
+	if ( my_list.empty() )
+	{
+		return;
+	}
+	
+	instantiation* inst = soar_module::make_fake_instantiation( my_agent, state, &cue_wmes, &my_list );
 
-	// add the preference to temporary memory
-	add_preference_to_tm( my_agent, pref );
+	for ( preference* pref=inst->preferences_generated; pref; pref=pref->inst_next )
+	{
+		// add the preference to temporary memory
+		if ( add_preference_to_tm( my_agent, pref ) )
+		{
+			// and add it to the list of preferences to be removed
+			// when the goal is removed
+			insert_at_head_of_dll( state->id.preferences_from_goal, pref, all_of_goal_next, all_of_goal_prev );
+			pref->on_goal_list = true;
 
-	// and add it to the list of preferences to be removed
-	// when the goal is removed
-	insert_at_head_of_dll( state->id.preferences_from_goal, pref, all_of_goal_next, all_of_goal_prev );
-	pref->on_goal_list = true;
+			if ( meta )
+			{
+				// if this is a meta wme, then it is completely local
+				// to the state and thus we will manually remove it
+				// (via preference removal) when the time comes
+				state->id.smem_info->smem_wmes->push_back( pref );
+			}
+		}
+		else
+		{
+			preference_add_ref( pref );
+			preference_remove_ref( my_agent, pref );
+		}
+	}
 
-
-	if ( meta )
+	if ( !meta )
 	{
-		// if this is a meta wme, then it is completely local
-		// to the state and thus we will manually remove it
-		// (via preference removal) when the time comes
-		state->id.smem_info->smem_wmes->push( pref );
-	}
-	else
-	{
 		// otherwise, we submit the fake instantiation to backtracing
 		// such as to potentially produce justifications that can follow
 		// it to future adventures (potentially on new states)
-
 		instantiation *my_justification_list = NIL;
-		chunk_instantiation( my_agent, pref->inst, false, &my_justification_list );
+		chunk_instantiation( my_agent, inst, false, &my_justification_list );
 
 		// if any justifications are created, assert their preferences manually
 		// (copied mainly from assert_new_preferences with respect to our circumstances)
@@ -629,7 +721,7 @@
 				  my_justification=next_justification )
 			{
 				next_justification = my_justification->next;
-
+				
 				if ( my_justification->in_ms )
 				{
 					insert_at_head_of_dll( my_justification->prod->instantiations, my_justification, next, prev );
@@ -637,29 +729,39 @@
 
 				for ( just_pref=my_justification->preferences_generated; just_pref!=NIL; just_pref=just_pref->inst_next ) 
 				{
-					add_preference_to_tm( my_agent, just_pref );						
-					
-					if ( wma_enabled( my_agent ) )
+					if ( add_preference_to_tm( my_agent, just_pref ) )
 					{
-						wma_activate_wmes_in_pref( my_agent, just_pref );
+						if ( wma_enabled( my_agent ) )
+						{
+							wma_activate_wmes_in_pref( my_agent, just_pref );
+						}
 					}
+					else
+					{
+						preference_add_ref( just_pref );
+						preference_remove_ref( my_agent, just_pref );
+					}
 				}
 			}
 		}
 	}
 }


##################
# new functions: smem_process_buffered_wmes(), void smem_buffer_add_wme() 
# removed functions: smem_add_retrieved_wme(), smem_add_meta_wme()

-void smem_add_retrieved_wme( agent *my_agent, Symbol *state, Symbol *id, Symbol *attr, Symbol *value )
+inline void smem_process_buffered_wmes( agent* my_agent, Symbol* state, soar_module::wme_set& cue_wmes, soar_module::symbol_triple_list& meta_wmes, soar_module::symbol_triple_list& retrieval_wmes )
 {
-	_smem_add_wme( my_agent, state, id, attr, value, false );
+	_smem_process_buffered_wme_list( my_agent, state, cue_wmes, meta_wmes, true );
+	_smem_process_buffered_wme_list( my_agent, state, cue_wmes, retrieval_wmes, false );
 }
 
-void smem_add_meta_wme( agent *my_agent, Symbol *state, Symbol *id, Symbol *attr, Symbol *value )
+inline void smem_buffer_add_wme( soar_module::symbol_triple_list& my_list, Symbol* id, Symbol* attr, Symbol* value )
 {
-	_smem_add_wme( my_agent, state, id, attr, value, true );
+	my_list.push_back( new soar_module::symbol_triple( id, attr, value ) );
+
+	symbol_add_ref( id );
+	symbol_add_ref( attr );
+	symbol_add_ref( value );
 }
 
-
 //////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////
 // Variable Functions (smem::var)
 
 
#####################
# function args and return vals updated -- no change in jsoar

@@ -672,7 +774,7 @@
 //////////////////////////////////////////////////////////
 
 // gets an SMem variable from the database
-inline bool smem_variable_get( agent *my_agent, smem_variable_key variable_id, intptr_t *variable_value )
+inline bool smem_variable_get( agent *my_agent, smem_variable_key variable_id, int64_t *variable_value )
 {
 	soar_module::exec_result status;
 	soar_module::sqlite_statement *var_get = my_agent->smem_stmts->var_get;
@@ -691,7 +793,7 @@
 }
 
 // sets an existing SMem variable in the database
-inline void smem_variable_set( agent *my_agent, smem_variable_key variable_id, intptr_t variable_value )
+inline void smem_variable_set( agent *my_agent, smem_variable_key variable_id, int64_t variable_value )
 {
 	soar_module::sqlite_statement *var_set = my_agent->smem_stmts->var_set;
 	
@@ -702,7 +804,7 @@
 }
 
 // creates a new SMem variable in the database
-inline void smem_variable_create( agent *my_agent, smem_variable_key variable_id, intptr_t variable_value )
+inline void smem_variable_create( agent *my_agent, smem_variable_key variable_id, int64_t variable_value )
 {
 	soar_module::sqlite_statement *var_create = my_agent->smem_stmts->var_create;
 	
@@ -736,7 +838,7 @@
 	return static_cast<smem_hash_id>( my_agent->smem_db->last_insert_rowid() );
 }
 
-inline smem_hash_id smem_temporal_hash_int( agent *my_agent, intptr_t val, bool add_on_fail = true )
+inline smem_hash_id smem_temporal_hash_int( agent *my_agent, int64_t val, bool add_on_fail = true )
 {
 	smem_hash_id return_val = NIL;
 	
@@ -863,9 +965,9 @@
 	return return_val;
 }
 
-inline intptr_t smem_reverse_hash_int( agent* my_agent, smem_hash_id hash_value )
+inline int64_t smem_reverse_hash_int( agent* my_agent, smem_hash_id hash_value )
 {
-	intptr_t return_val = NIL;
+	int64_t return_val = NIL;
 	
 	my_agent->smem_stmts->hash_rev_int->bind_int( 1, hash_value );
 	soar_module::exec_result res = my_agent->smem_stmts->hash_rev_int->execute();
 	

####################
# cast removed -- no effect in jsoar

@@ -914,7 +1016,7 @@
 			break;
 
 		case INT_CONSTANT_SYMBOL_TYPE:
-			return_val = make_int_constant( my_agent, static_cast<long>( smem_reverse_hash_int( my_agent, hash_value ) ) );
+			return_val = make_int_constant( my_agent, smem_reverse_hash_int( my_agent, hash_value ) );
 			break;
 
 		case FLOAT_CONSTANT_SYMBOL_TYPE:
 		
 		

########################
# new activation functions smem_lti_calc_base()
# smem_lti_activate() moved up from below? (don't know yet if any significant changes or just moved)

@@ -932,6 +1034,212 @@
 
 //////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////
+// Activation Functions (smem::act)
+//////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////
+
+inline double smem_lti_calc_base( agent *my_agent, smem_lti_id lti, int64_t time_now, uint64_t n = 0, uint64_t access_1 = 0 )
+{
+	double sum = 0.0;
+	double d = my_agent->smem_params->base_decay->get_value();
+	uint64_t t_k;
+	uint64_t t_n = ( time_now - access_1 );
+	
+	if ( n == 0 )
+	{
+		my_agent->smem_stmts->lti_access_get->bind_int( 1, lti );
+		my_agent->smem_stmts->lti_access_get->execute();
+
+		n = my_agent->smem_stmts->lti_access_get->column_int( 0 );
+		access_1 = my_agent->smem_stmts->lti_access_get->column_int( 2 );
+		
+		my_agent->smem_stmts->lti_access_get->reinitialize();
+	}
+
+	// get all history
+	my_agent->smem_stmts->history_get->bind_int( 1, lti );
+	my_agent->smem_stmts->history_get->execute();
+	{
+		int available_history = static_cast<int>( ( SMEM_ACT_HISTORY_ENTRIES<n )?(SMEM_ACT_HISTORY_ENTRIES):(n) );
+		t_k = static_cast<uint64_t>( time_now - my_agent->smem_stmts->history_get->column_int( available_history-1 ) );
+
+		for ( int i=0; i<available_history; i++ )
+		{
+			sum += pow( static_cast<double>( time_now - my_agent->smem_stmts->history_get->column_int( i ) ), 
+						static_cast<double>( -d ) );
+		}
+	}
+	my_agent->smem_stmts->history_get->reinitialize();
+
+	// if available history was insufficient, approximate rest
+	if ( n > SMEM_ACT_HISTORY_ENTRIES )
+	{
+		double apx_numerator = ( static_cast<double>( n - SMEM_ACT_HISTORY_ENTRIES ) * ( pow( static_cast<double>( t_n ), 1.0-d ) - pow( static_cast<double>( t_k ), 1.0-d ) ) );
+		double apx_denominator = ( ( 1.0-d ) * static_cast<double>( t_n - t_k ) );
+
+		sum += ( apx_numerator / apx_denominator );
+	}
+
+	return ( ( sum > 0 )?( log(sum) ):( SMEM_ACT_LOW ) );
+}
+
+// activates a new or existing long-term identifier
+// note: optional num_edges parameter saves us a lookup 
+//       just when storing a new chunk (default is a 
+//       big number that should never come up naturally
+//       and if it does, satisfies thresholding behavior).
+inline double smem_lti_activate( agent *my_agent, smem_lti_id lti, bool add_access, uint64_t num_edges = SMEM_ACT_MAX )
+{
+	////////////////////////////////////////////////////////////////////////////
+	my_agent->smem_timers->act->start();
+	////////////////////////////////////////////////////////////////////////////
+
+	int64_t time_now;
+	if ( add_access )
+	{
+		time_now = my_agent->smem_max_cycle++;
+
+		if ( ( my_agent->smem_params->activation_mode->get_value() == smem_param_container::act_base ) && 
+			 ( my_agent->smem_params->base_update->get_value() == smem_param_container::bupt_incremental ) )
+		{
+			int64_t time_diff;
+			
+			for ( std::set< int64_t >::iterator b=my_agent->smem_params->base_incremental_threshes->set_begin(); b!=my_agent->smem_params->base_incremental_threshes->set_end(); b++ )
+			{
+				if ( *b > 0 )
+				{
+					time_diff = ( time_now - *b );
+
+					if ( time_diff > 0 )
+					{
+						std::list< smem_lti_id > to_update;
+
+						my_agent->smem_stmts->lti_get_t->bind_int( 1, time_diff );
+						while ( my_agent->smem_stmts->lti_get_t->execute() == soar_module::row )
+						{
+							to_update.push_back( static_cast< smem_lti_id >( my_agent->smem_stmts->lti_get_t->column_int(0) ) );
+						}
+						my_agent->smem_stmts->lti_get_t->reinitialize();
+
+						for ( std::list< smem_lti_id >::iterator it=to_update.begin(); it!=to_update.end(); it++ )
+						{
+							smem_lti_activate( my_agent, (*it), false );
+						}
+					}
+				}
+			}
+		}
+	}
+	else
+	{
+		time_now = my_agent->smem_max_cycle;
+
+		my_agent->smem_stats->act_updates->set_value( my_agent->smem_stats->act_updates->get_value() + 1 );
+	}
+
+	// access information
+	uint64_t prev_access_n = 0;
+	uint64_t prev_access_t = 0;
+	uint64_t prev_access_1 = 0;
+	{
+		// get old (potentially useful below)
+		{
+			my_agent->smem_stmts->lti_access_get->bind_int( 1, lti );
+			my_agent->smem_stmts->lti_access_get->execute();
+
+			prev_access_n = my_agent->smem_stmts->lti_access_get->column_int( 0 );
+			prev_access_t = my_agent->smem_stmts->lti_access_get->column_int( 1 );
+			prev_access_1 = my_agent->smem_stmts->lti_access_get->column_int( 2 );
+
+			my_agent->smem_stmts->lti_access_get->reinitialize();
+		}
+
+		// set new
+		if ( add_access )
+		{
+			my_agent->smem_stmts->lti_access_set->bind_int( 1, ( prev_access_n + 1 ) );
+			my_agent->smem_stmts->lti_access_set->bind_int( 2, time_now );
+			my_agent->smem_stmts->lti_access_set->bind_int( 3, ( ( prev_access_n == 0 )?( time_now ):( prev_access_1 ) ) );
+			my_agent->smem_stmts->lti_access_set->bind_int( 4, lti );
+			my_agent->smem_stmts->lti_access_set->execute( soar_module::op_reinit );
+		}
+	}
+	
+	// get new activation value (depends upon bias)
+	double new_activation = 0.0;
+	smem_param_container::act_choices act_mode = my_agent->smem_params->activation_mode->get_value();
+	if ( act_mode == smem_param_container::act_recency )
+	{
+		new_activation = static_cast<double>( time_now );
+	}
+	else if ( act_mode == smem_param_container::act_frequency )
+	{
+		new_activation = static_cast<double>( prev_access_n + ( ( add_access )?(1):(0) ) );
+	}
+	else if ( act_mode == smem_param_container::act_base )
+	{
+		if ( prev_access_n == 0 )
+		{
+			if ( add_access )
+			{
+				my_agent->smem_stmts->history_add->bind_int( 1, lti );
+				my_agent->smem_stmts->history_add->bind_int( 2, time_now );
+				my_agent->smem_stmts->history_add->execute( soar_module::op_reinit );
+			}
+
+			new_activation = 0;
+		}
+		else
+		{
+			if ( add_access )
+			{
+				my_agent->smem_stmts->history_push->bind_int( 1, time_now );
+				my_agent->smem_stmts->history_push->bind_int( 2, lti );
+				my_agent->smem_stmts->history_push->execute( soar_module::op_reinit );
+			}
+
+			new_activation = smem_lti_calc_base( my_agent, lti, time_now+( ( add_access )?(1):(0) ), prev_access_n+( ( add_access )?(1):(0) ), prev_access_1 );
+		}
+	}
+
+	// get number of augmentations (if not supplied)
+	if ( num_edges == SMEM_ACT_MAX )
+	{
+		my_agent->smem_stmts->act_lti_child_ct_get->bind_int( 1, lti );
+		my_agent->smem_stmts->act_lti_child_ct_get->execute();
+
+		num_edges = my_agent->smem_stmts->act_lti_child_ct_get->column_int( 0 );
+
+		my_agent->smem_stmts->act_lti_child_ct_get->reinitialize();
+	}
+
+	// only if augmentation count is less than threshold do we associate with edges
+	if ( num_edges < static_cast<uint64_t>( my_agent->smem_params->thresh->get_value() ) )
+	{
+		// act_value=? WHERE lti=?
+		my_agent->smem_stmts->act_set->bind_double( 1, new_activation );
+		my_agent->smem_stmts->act_set->bind_int( 2, lti );
+		my_agent->smem_stmts->act_set->execute( soar_module::op_reinit );
+	}
+
+	// always associate activation with lti
+	{
+		// act_value=? WHERE lti=?
+		my_agent->smem_stmts->act_lti_set->bind_double( 1, new_activation );
+		my_agent->smem_stmts->act_lti_set->bind_int( 2, lti );
+		my_agent->smem_stmts->act_lti_set->execute( soar_module::op_reinit );
+	}
+	
+	////////////////////////////////////////////////////////////////////////////
+	my_agent->smem_timers->act->stop();
+	////////////////////////////////////////////////////////////////////////////
+
+	return new_activation;
+}
+
+
+//////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////
 // Long-Term Identifier Functions (smem::lti)
 //////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////
 
 

#################
# function smem_count_ltis()
# does not exist in jsoar (was unnecessary), so ignore

@@ -1091,46 +1399,13 @@
 
 	if ( id->id.smem_lti != NIL )
 	{
-		unsigned long *counter = reinterpret_cast<unsigned long *>( userdata );
+		uint64_t* counter = reinterpret_cast<uint64_t*>( userdata );
 		(*counter)++;
 	}
 
 	return false;
 }

################
# smem_lti_activate() moved up above (don't know if there are any significant changes)

-
-// activates a new or existing long-term identifier
-inline void smem_lti_activate( agent *my_agent, smem_lti_id lti )
-{
-	////////////////////////////////////////////////////////////////////////////
-	my_agent->smem_timers->act->start();
-	////////////////////////////////////////////////////////////////////////////
-
-	my_agent->smem_stmts->act_lti_child_ct_get->bind_int( 1, lti );
-	my_agent->smem_stmts->act_lti_child_ct_get->execute();
-
-	if ( my_agent->smem_stmts->act_lti_child_ct_get->column_int( 0 ) >= my_agent->smem_params->thresh->get_value() )
-	{
-		// cycle=? WHERE lti=?
-		my_agent->smem_stmts->act_lti_set->bind_int( 1, ( my_agent->smem_max_cycle++ ) );
-		my_agent->smem_stmts->act_lti_set->bind_int( 2, lti );
-		my_agent->smem_stmts->act_lti_set->execute( soar_module::op_reinit );
-	}
-	else
-	{
-		// cycle=? WHERE lti=?
-		my_agent->smem_stmts->act_set->bind_int( 1, ( my_agent->smem_max_cycle++ ) );
-		my_agent->smem_stmts->act_set->bind_int( 2, lti );
-		my_agent->smem_stmts->act_set->execute( soar_module::op_reinit );
-	}
-
-	my_agent->smem_stmts->act_lti_child_ct_get->reinitialize();
-
-	////////////////////////////////////////////////////////////////////////////
-	my_agent->smem_timers->act->stop();
-	////////////////////////////////////////////////////////////////////////////
-}
-

####################
# smem_lti_get_id()
# cast changes can be ignored in jsoar

 // gets the lti id for an existing lti letter/number pair (or NIL if failure)
 smem_lti_id smem_lti_get_id( agent *my_agent, char name_letter, uint64_t name_number )
 {
@@ -1140,8 +1415,8 @@
 	smem_attach( my_agent );
 	
 	// letter=? AND number=?
-	my_agent->smem_stmts->lti_get->bind_int( 1, static_cast<uintptr_t>( name_letter ) );
-	my_agent->smem_stmts->lti_get->bind_int( 2, static_cast<uintptr_t>( name_number ) );
+	my_agent->smem_stmts->lti_get->bind_int( 1, static_cast<uint64_t>( name_letter ) );
+	my_agent->smem_stmts->lti_get->bind_int( 2, static_cast<uint64_t>( name_number ) );
 
 	if ( my_agent->smem_stmts->lti_get->execute() == soar_module::row )
 	{

########################
# smem_lti_add_id()
# some cast changes that can be ignored, but also real changes that need to be ported

@@ -1158,11 +1433,14 @@
 {
 	smem_lti_id return_val;
 
-	// create lti: letter, number
-	my_agent->smem_stmts->lti_add->bind_int( 1, static_cast<uintptr_t>( name_letter ) );
-	my_agent->smem_stmts->lti_add->bind_int( 2, static_cast<uintptr_t>( name_number ) );
-	my_agent->smem_stmts->lti_add->bind_int( 3, static_cast<uintptr_t>( 0 ) );
-	my_agent->smem_stmts->lti_add->bind_int( 4, static_cast<uintptr_t>( 0 ) );
+	// create lti: letter, number, child_ct, act_value, access_n, access_t, access_1
+	my_agent->smem_stmts->lti_add->bind_int( 1, static_cast<uint64_t>( name_letter ) );
+	my_agent->smem_stmts->lti_add->bind_int( 2, static_cast<uint64_t>( name_number ) );
+	my_agent->smem_stmts->lti_add->bind_int( 3, static_cast<uint64_t>( 0 ) );
+	my_agent->smem_stmts->lti_add->bind_double( 4, static_cast<double>( 0 ) );
+	my_agent->smem_stmts->lti_add->bind_int( 5, static_cast<uint64_t>( 0 ) );
+	my_agent->smem_stmts->lti_add->bind_int( 6, static_cast<uint64_t>( 0 ) );
+	my_agent->smem_stmts->lti_add->bind_int( 7, static_cast<uint64_t>( 0 ) );
 	my_agent->smem_stmts->lti_add->execute( soar_module::op_reinit );
 
 	return_val = static_cast<smem_lti_id>( my_agent->smem_db->last_insert_rowid() );
 	
##########################
# smem_lti_soar_add()

@@ -1189,6 +1467,7 @@
 
 			id->id.smem_time_id = my_agent->epmem_stats->time->get_value();
 			id->id.smem_valid = my_agent->epmem_validation;
+			epmem_schedule_promotion( my_agent, id );
 		}
 	}


##########################
# smem_disconnect_chunk()

@@ -1273,54 +1552,53 @@
 
 void smem_disconnect_chunk( agent *my_agent, smem_lti_id parent_id )
 {
-	// adjust attribute counts
+	// adjust attr, attr/value counts
 	{
-		intptr_t counter = 0;
+		uint64_t pair_count = 0;
 		
-		// get all old counts
-		my_agent->smem_stmts->web_attr_ct->bind_int( 1, parent_id );
-		while ( my_agent->smem_stmts->web_attr_ct->execute() == soar_module::row )
+		smem_lti_id child_attr = 0;
+		std::set<smem_lti_id> distinct_attr;
+		
+		// pairs first, accumulate distinct attributes and pair count
+		my_agent->smem_stmts->web_all->bind_int( 1, parent_id );
+		while ( my_agent->smem_stmts->web_all->execute() == soar_module::row )
 		{
-			counter += my_agent->smem_stmts->web_attr_ct->column_int( 1 );
-			
-			// adjust in opposite direction ( adjust, attribute )
-			my_agent->smem_stmts->ct_attr_update->bind_int( 1, -( my_agent->smem_stmts->web_attr_ct->column_int( 1 ) ) );
-			my_agent->smem_stmts->ct_attr_update->bind_int( 2, my_agent->smem_stmts->web_attr_ct->column_int( 0 ) );
-			my_agent->smem_stmts->ct_attr_update->execute( soar_module::op_reinit );
-		}
-		my_agent->smem_stmts->web_attr_ct->reinitialize();
+			pair_count++;
 
-		my_agent->smem_stats->slots->set_value( my_agent->smem_stats->slots->get_value() - counter );
-	}
+			child_attr = my_agent->smem_stmts->web_all->column_int( 0 );
+			distinct_attr.insert( child_attr );
 
-	// adjust const counts
-	{
-		// get all old counts
-		my_agent->smem_stmts->web_const_ct->bind_int( 1, parent_id );
-		while ( my_agent->smem_stmts->web_const_ct->execute() == soar_module::row )
-		{
-			// adjust in opposite direction ( adjust, attribute, const )
-			my_agent->smem_stmts->ct_const_update->bind_int( 1, -( my_agent->smem_stmts->web_const_ct->column_int( 2 ) ) );
-			my_agent->smem_stmts->ct_const_update->bind_int( 2, my_agent->smem_stmts->web_const_ct->column_int( 0 ) );
-			my_agent->smem_stmts->ct_const_update->bind_int( 3, my_agent->smem_stmts->web_const_ct->column_int( 1 ) );
-			my_agent->smem_stmts->ct_const_update->execute( soar_module::op_reinit );
+			// null -> attr/lti
+			if ( my_agent->smem_stmts->web_all->column_int( 1 ) != SMEM_WEB_NULL )
+			{
+				// adjust in opposite direction ( adjust, attribute, const )
+				my_agent->smem_stmts->ct_const_update->bind_int( 1, -1 );
+				my_agent->smem_stmts->ct_const_update->bind_int( 2, child_attr );
+				my_agent->smem_stmts->ct_const_update->bind_int( 3, my_agent->smem_stmts->web_all->column_int( 1 ) );
+				my_agent->smem_stmts->ct_const_update->execute( soar_module::op_reinit );
+			}
+			else
+			{
+				// adjust in opposite direction ( adjust, attribute, lti )
+				my_agent->smem_stmts->ct_lti_update->bind_int( 1, -1 );
+				my_agent->smem_stmts->ct_lti_update->bind_int( 2, child_attr );
+				my_agent->smem_stmts->ct_lti_update->bind_int( 3, my_agent->smem_stmts->web_all->column_int( 2 ) );
+				my_agent->smem_stmts->ct_lti_update->execute( soar_module::op_reinit );
+			}
 		}
-		my_agent->smem_stmts->web_const_ct->reinitialize();
-	}
+		my_agent->smem_stmts->web_all->reinitialize();
 
-	// adjust lti counts
-	{
-		// get all old counts
-		my_agent->smem_stmts->web_lti_ct->bind_int( 1, parent_id );
-		while ( my_agent->smem_stmts->web_lti_ct->execute() == soar_module::row )
+		// now attributes
+		for (std::set<smem_lti_id>::iterator a=distinct_attr.begin(); a!=distinct_attr.end(); a++)
 		{
-			// adjust in opposite direction ( adjust, attribute, lti )
-			my_agent->smem_stmts->ct_lti_update->bind_int( 1, -( my_agent->smem_stmts->web_lti_ct->column_int( 2 ) ) );
-			my_agent->smem_stmts->ct_lti_update->bind_int( 2, my_agent->smem_stmts->web_lti_ct->column_int( 0 ) );
-			my_agent->smem_stmts->ct_lti_update->bind_int( 3, my_agent->smem_stmts->web_lti_ct->column_int( 1 ) );
-			my_agent->smem_stmts->ct_lti_update->execute( soar_module::op_reinit );
+			// adjust in opposite direction ( adjust, attribute )
+			my_agent->smem_stmts->ct_attr_update->bind_int( 1, -1 );
+			my_agent->smem_stmts->ct_attr_update->bind_int( 2, *a );
+			my_agent->smem_stmts->ct_attr_update->execute( soar_module::op_reinit );
 		}
-		my_agent->smem_stmts->web_lti_ct->reinitialize();
+
+		// update local statistic
+		my_agent->smem_stats->slots->set_value( my_agent->smem_stats->slots->get_value() - pair_count );
 	}
 
 	// disconnect
@@ -1330,218 +1608,298 @@
 	}
 }
 
#####################
# smem_store_chunk() significant changes, re-port from scratch?

-void smem_store_chunk( agent *my_agent, smem_lti_id parent_id, smem_slot_map *children, bool remove_old_children = true )
-{
-	smem_slot_map::iterator s;
-	smem_slot::iterator v;
-
-	smem_hash_id attr_hash = 0;
-	smem_hash_id value_hash = 0;
-	smem_lti_id value_lti = 0;
-
-	std::map<smem_hash_id, unsigned long> attr_ct_adjust;
-	std::map<smem_hash_id, std::map<smem_hash_id, unsigned long> > const_ct_adjust;
-	std::map<smem_hash_id, std::map<smem_lti_id, unsigned long> > lti_ct_adjust;
-	intptr_t stat_adjust = 0;
-
-	intptr_t next_act_cycle = ( my_agent->smem_max_cycle++ );
-	
-	// clear web, adjust counts
-	unsigned long child_ct = 0;
+void smem_store_chunk( agent *my_agent, smem_lti_id parent_id, smem_slot_map *children, bool remove_old_children = true, Symbol* print_id = NULL )
+{	
+	// if remove children, disconnect chunk -> no existing edges
+	// else, need to query number of existing edges
+	uint64_t existing_edges = 0;
 	if ( remove_old_children )
 	{
 		smem_disconnect_chunk( my_agent, parent_id );
+		
+		// provide trace output
+		if ( my_agent->sysparams[ TRACE_SMEM_SYSPARAM ] && ( print_id ) )
+		{
+			char buf[256];
+			
+			snprintf_with_symbols( my_agent, buf, 256, "<=SMEM: (%y ^* *)\n", print_id );
+			
+			print( my_agent, buf );
+			xml_generate_warning( my_agent, buf );
+		}
 	}
 	else
 	{
 		my_agent->smem_stmts->act_lti_child_ct_get->bind_int( 1, parent_id );
 		my_agent->smem_stmts->act_lti_child_ct_get->execute();
 
-		child_ct = static_cast<unsigned long>( my_agent->smem_stmts->act_lti_child_ct_get->column_int(0) );
+		existing_edges = static_cast<uint64_t>( my_agent->smem_stmts->act_lti_child_ct_get->column_int(0) );
 
 		my_agent->smem_stmts->act_lti_child_ct_get->reinitialize();
 	}
 
-	// already above threshold?
-	unsigned long thresh = static_cast<unsigned long>( my_agent->smem_params->thresh->get_value() );
-	bool before_above = ( child_ct >= thresh );
+	// get new edges
+	// if didn't disconnect, entails lookups in existing edges
+	std::set<smem_hash_id> attr_new;
+	std::set< std::pair<smem_hash_id, smem_hash_id> > const_new;
+	std::set< std::pair<smem_hash_id, smem_lti_id> > lti_new;
+	{
+		smem_slot_map::iterator s;
+		smem_slot::iterator v;
 
-	// get final count
-	{
+		smem_hash_id attr_hash = 0;
+		smem_hash_id value_hash = 0;
+		smem_lti_id value_lti = 0;
+		
 		for ( s=children->begin(); s!=children->end(); s++ )
 		{
-			for ( v=s->second->begin(); v!=s->second->end(); v++ )
+			attr_hash = smem_temporal_hash( my_agent, s->first );
+			if ( remove_old_children )
 			{
-				child_ct++;
+				attr_new.insert( attr_hash );
 			}
-		}
-	}
-
-	// above threshold now?
-	bool after_above = ( child_ct >= thresh );
-	intptr_t web_act_cycle = ( ( after_above )?( SMEM_ACT_MAX ):( next_act_cycle ) );
-
-	// if didn't clear and wasn't already above, need to update kids
-	if ( ( !remove_old_children ) && ( !before_above ) )
-	{
-		my_agent->smem_stmts->act_set->bind_int( 1, web_act_cycle );
-		my_agent->smem_stmts->act_set->bind_int( 2, parent_id );
-		my_agent->smem_stmts->act_set->execute( soar_module::op_reinit );
-	}
-
-	// if above threshold, update parent activation
-	if ( after_above )
-	{
-		my_agent->smem_stmts->act_lti_set->bind_int( 1, next_act_cycle );
-		my_agent->smem_stmts->act_lti_set->bind_int( 2, parent_id );
-		my_agent->smem_stmts->act_lti_set->execute( soar_module::op_reinit );
-	}
-
-	// for all slots
-	for ( s=children->begin(); s!=children->end(); s++ )
-	{
-		// get attribute hash and contribute to count adjustment
-		attr_hash = smem_temporal_hash( my_agent, s->first );
-		attr_ct_adjust[ attr_hash ]++;
-		stat_adjust++;
-
-		// for all values in the slot
-		for ( v=s->second->begin(); v!=s->second->end(); v++ )
-		{			
-			// most handling is specific to constant vs. identifier
-			if ( (*v)->val_const.val_type == value_const_t )
+			else
 			{
-				value_hash = smem_temporal_hash( my_agent, (*v)->val_const.val_value );
-
-				// parent_id, attr, val_const, val_lti, act_cycle
-				my_agent->smem_stmts->web_add->bind_int( 1, parent_id );
-				my_agent->smem_stmts->web_add->bind_int( 2, attr_hash );
-				my_agent->smem_stmts->web_add->bind_int( 3, value_hash );
-				my_agent->smem_stmts->web_add->bind_null( 4 );
-				my_agent->smem_stmts->web_add->bind_int( 5, web_act_cycle );
-				my_agent->smem_stmts->web_add->execute( soar_module::op_reinit );
-
-				const_ct_adjust[ attr_hash ][ value_hash ]++;
+				// parent_id, attr
+				my_agent->smem_stmts->web_attr_child->bind_int( 1, parent_id );
+				my_agent->smem_stmts->web_attr_child->bind_int( 2, attr_hash );
+				if ( my_agent->smem_stmts->web_attr_child->execute( soar_module::op_reinit ) != soar_module::row )
+				{
+					attr_new.insert( attr_hash );
+				}
 			}
-			else
+			
+			for ( v=s->second->begin(); v!=s->second->end(); v++ )
 			{
-				value_lti = (*v)->val_lti.val_value->lti_id;
-				if ( value_lti == NIL )
+				if ( (*v)->val_const.val_type == value_const_t )
 				{
-					value_lti = smem_lti_add_id( my_agent, (*v)->val_lti.val_value->lti_letter, (*v)->val_lti.val_value->lti_number );
-					(*v)->val_lti.val_value->lti_id = value_lti;
+					value_hash = smem_temporal_hash( my_agent, (*v)->val_const.val_value );
 
-					if ( (*v)->val_lti.val_value->soar_id != NIL )
+					if ( remove_old_children )
 					{
-						(*v)->val_lti.val_value->soar_id->id.smem_lti = value_lti;
-
-						(*v)->val_lti.val_value->soar_id->id.smem_time_id = my_agent->epmem_stats->time->get_value();
-						(*v)->val_lti.val_value->soar_id->id.smem_valid = my_agent->epmem_validation;
+						const_new.insert( std::make_pair< smem_hash_id, smem_hash_id >( attr_hash, value_hash ) );
 					}
+					else
+					{
+						// parent_id, attr, val_const
+						my_agent->smem_stmts->web_const_child->bind_int( 1, parent_id );
+						my_agent->smem_stmts->web_const_child->bind_int( 2, attr_hash );
+						my_agent->smem_stmts->web_const_child->bind_int( 3, value_hash );
+						if ( my_agent->smem_stmts->web_const_child->execute( soar_module::op_reinit ) != soar_module::row )
+						{
+							const_new.insert( std::make_pair< smem_hash_id, smem_hash_id >( attr_hash, value_hash ) );
+						}
+					}
+					
+					// provide trace output
+					if ( my_agent->sysparams[ TRACE_SMEM_SYSPARAM ] && ( print_id ) )
+					{
+						char buf[256];
+						
+						snprintf_with_symbols( my_agent, buf, 256, "=>SMEM: (%y ^%y %y)\n", print_id, s->first, (*v)->val_const.val_value );
+						
+						print( my_agent, buf );
+						xml_generate_warning( my_agent, buf );
+					}
 				}
+				else
+				{
+					value_lti = (*v)->val_lti.val_value->lti_id;
+					if ( value_lti == NIL )
+					{
+						value_lti = smem_lti_add_id( my_agent, (*v)->val_lti.val_value->lti_letter, (*v)->val_lti.val_value->lti_number );
+						(*v)->val_lti.val_value->lti_id = value_lti;
 
-				// parent_id, attr, val_const, val_lti, act_cycle
-				my_agent->smem_stmts->web_add->bind_int( 1, parent_id );
-				my_agent->smem_stmts->web_add->bind_int( 2, attr_hash );
-				my_agent->smem_stmts->web_add->bind_null( 3 );
-				my_agent->smem_stmts->web_add->bind_int( 4, value_lti );
-				my_agent->smem_stmts->web_add->bind_int( 5, web_act_cycle );
-				my_agent->smem_stmts->web_add->execute( soar_module::op_reinit );
+						if ( (*v)->val_lti.val_value->soar_id != NIL )
+						{
+							(*v)->val_lti.val_value->soar_id->id.smem_lti = value_lti;
 
-				// add to counts
-				lti_ct_adjust[ attr_hash ][ value_lti ]++;
+							(*v)->val_lti.val_value->soar_id->id.smem_time_id = my_agent->epmem_stats->time->get_value();
+							(*v)->val_lti.val_value->soar_id->id.smem_valid = my_agent->epmem_validation;
+							epmem_schedule_promotion( my_agent, (*v)->val_lti.val_value->soar_id );
+						}
+					}
+
+					if ( remove_old_children )
+					{
+						lti_new.insert( std::make_pair< smem_hash_id, smem_lti_id >( attr_hash, value_lti ) );
+					}
+					else
+					{
+						// parent_id, attr, val_lti
+						my_agent->smem_stmts->web_lti_child->bind_int( 1, parent_id );
+						my_agent->smem_stmts->web_lti_child->bind_int( 2, attr_hash );
+						my_agent->smem_stmts->web_lti_child->bind_int( 3, value_lti );
+						if ( my_agent->smem_stmts->web_lti_child->execute( soar_module::op_reinit ) != soar_module::row )
+						{
+							lti_new.insert( std::make_pair< smem_hash_id, smem_lti_id >( attr_hash, value_lti ) );
+						}
+					}
+					
+					// provide trace output
+					if ( my_agent->sysparams[ TRACE_SMEM_SYSPARAM ] && ( print_id ) )
+					{
+						char buf[256];
+						
+						snprintf_with_symbols( my_agent, buf, 256, "=>SMEM: (%y ^%y %y)\n", print_id, s->first, (*v)->val_lti.val_value->soar_id );
+						
+						print( my_agent, buf );
+						xml_generate_warning( my_agent, buf );
+					}
+				}
 			}
 		}
 	}
 
-	// update stat
+	// activation function assumes proper thresholding state
+	// thus, consider four cases of augmentation counts (w.r.t. thresh)
+	// 1. before=below, after=below: good (activation will update web)
+	// 2. before=below, after=above: need to update web->inf
+	// 3. before=after, after=below: good (activation will update web, free transition)
+	// 4. before=after, after=after: good (activation won't touch web)
+	//
+	// hence, we detect + handle case #2 here
+	uint64_t new_edges = ( existing_edges + const_new.size() + lti_new.size() );
+	bool after_above;
+	double web_act = static_cast<double>( SMEM_ACT_MAX );
 	{
-		my_agent->smem_stats->slots->set_value( my_agent->smem_stats->slots->get_value() + stat_adjust );
+		uint64_t thresh = static_cast<uint64_t>( my_agent->smem_params->thresh->get_value() );
+		after_above = ( new_edges >= thresh );
+		
+		// if before below
+		if ( existing_edges < thresh )
+		{
+			if ( after_above )
+			{
+				// update web to inf
+				my_agent->smem_stmts->act_set->bind_double( 1, web_act );
+				my_agent->smem_stmts->act_set->bind_int( 2, parent_id );
+				my_agent->smem_stmts->act_set->execute( soar_module::op_reinit );
+			}
+		}
 	}
 
-	// update attribute counts
+	// update edge counter
 	{
-		std::map<smem_hash_id, unsigned long>::iterator p;
+		my_agent->smem_stmts->act_lti_child_ct_set->bind_int( 1, new_edges );
+		my_agent->smem_stmts->act_lti_child_ct_set->bind_int( 2, parent_id );
+		my_agent->smem_stmts->act_lti_child_ct_set->execute( soar_module::op_reinit );
+	}
 
-		for ( p=attr_ct_adjust.begin(); p!= attr_ct_adjust.end(); p++ )
+	// now we can safely activate the lti
+	{
+		double lti_act = smem_lti_activate( my_agent, parent_id, true, new_edges );
+
+		if ( !after_above )
 		{
-			// check if counter exists (and add if does not): attr
-			my_agent->smem_stmts->ct_attr_check->bind_int( 1, p->first );
-			if ( my_agent->smem_stmts->ct_attr_check->execute( soar_module::op_reinit ) != soar_module::row )
-			{
-				my_agent->smem_stmts->ct_attr_add->bind_int( 1, p->first );
-				my_agent->smem_stmts->ct_attr_add->execute( soar_module::op_reinit );
-			}
-
-			// adjust count (adjustment, attr)
-			my_agent->smem_stmts->ct_attr_update->bind_int( 1, p->second );
-			my_agent->smem_stmts->ct_attr_update->bind_int( 2, p->first );
-			my_agent->smem_stmts->ct_attr_update->execute( soar_module::op_reinit );
+			web_act = lti_act;
 		}
 	}
 
-	// update constant counts
+	// insert new edges, update counters
 	{
-		std::map<smem_hash_id, std::map<smem_hash_id, unsigned long> >::iterator p1;
-		std::map<smem_hash_id, unsigned long>::iterator p2;
-
-		for ( p1=const_ct_adjust.begin(); p1!=const_ct_adjust.end(); p1++ )
+		// attr/const pairs
 		{
-			for ( p2=(p1->second).begin(); p2!=(p1->second).end(); p2++ )
+			for ( std::set< std::pair< smem_hash_id, smem_hash_id > >::iterator p=const_new.begin(); p!=const_new.end(); p++ )
 			{
-				// check if counter exists (and add if does not): attr, val
-				my_agent->smem_stmts->ct_const_check->bind_int( 1, p1->first );
-				my_agent->smem_stmts->ct_const_check->bind_int( 2, p2->first );
-				if ( my_agent->smem_stmts->ct_const_check->execute( soar_module::op_reinit ) != soar_module::row )
+				// insert
 				{
-					my_agent->smem_stmts->ct_const_add->bind_int( 1, p1->first );
-					my_agent->smem_stmts->ct_const_add->bind_int( 2, p2->first );
-					my_agent->smem_stmts->ct_const_add->execute( soar_module::op_reinit );
+					// parent_id, attr, val_const, val_lti, act_value
+					my_agent->smem_stmts->web_add->bind_int( 1, parent_id );
+					my_agent->smem_stmts->web_add->bind_int( 2, p->first );
+					my_agent->smem_stmts->web_add->bind_int( 3, p->second );
+					my_agent->smem_stmts->web_add->bind_int( 4, SMEM_WEB_NULL );
+					my_agent->smem_stmts->web_add->bind_double( 5, web_act );
+					my_agent->smem_stmts->web_add->execute( soar_module::op_reinit );
 				}
 
-				// adjust count (adjustment, attr, val)
-				my_agent->smem_stmts->ct_const_update->bind_int( 1, p2->second );
-				my_agent->smem_stmts->ct_const_update->bind_int( 2, p1->first );
-				my_agent->smem_stmts->ct_const_update->bind_int( 3, p2->first );
-				my_agent->smem_stmts->ct_const_update->execute( soar_module::op_reinit );
+				// update counter
+				{
+					// check if counter exists (and add if does not): attr, val
+					my_agent->smem_stmts->ct_const_check->bind_int( 1, p->first );
+					my_agent->smem_stmts->ct_const_check->bind_int( 2, p->second );
+					if ( my_agent->smem_stmts->ct_const_check->execute( soar_module::op_reinit ) != soar_module::row )
+					{
+						my_agent->smem_stmts->ct_const_add->bind_int( 1, p->first );
+						my_agent->smem_stmts->ct_const_add->bind_int( 2, p->second );
+						my_agent->smem_stmts->ct_const_add->execute( soar_module::op_reinit );
+					}
+					else
+					{
+						// adjust count (adjustment, attr, val)
+						my_agent->smem_stmts->ct_const_update->bind_int( 1, 1 );
+						my_agent->smem_stmts->ct_const_update->bind_int( 2, p->first );
+						my_agent->smem_stmts->ct_const_update->bind_int( 3, p->second );
+						my_agent->smem_stmts->ct_const_update->execute( soar_module::op_reinit );
+					}
+				}
 			}
 		}
-	}
 
-	// update lti counts
-	{
-		std::map<smem_hash_id, std::map<smem_lti_id, unsigned long> >::iterator p1;
-		std::map<smem_lti_id, unsigned long>::iterator p2;
-
-		for ( p1=lti_ct_adjust.begin(); p1!=lti_ct_adjust.end(); p1++ )
+		// attr/lti pairs
 		{
-			for ( p2=(p1->second).begin(); p2!=(p1->second).end(); p2++ )
+			for ( std::set< std::pair< smem_hash_id, smem_lti_id > >::iterator p=lti_new.begin(); p!=lti_new.end(); p++ )
 			{
-				// check if counter exists (and add if does not): attr, val
-				my_agent->smem_stmts->ct_lti_check->bind_int( 1, p1->first );
-				my_agent->smem_stmts->ct_lti_check->bind_int( 2, p2->first );
-				if ( my_agent->smem_stmts->ct_lti_check->execute( soar_module::op_reinit ) != soar_module::row )
+				// insert
 				{
-					my_agent->smem_stmts->ct_lti_add->bind_int( 1, p1->first );
-					my_agent->smem_stmts->ct_lti_add->bind_int( 2, p2->first );
-					my_agent->smem_stmts->ct_lti_add->execute( soar_module::op_reinit );
+					// parent_id, attr, val_const, val_lti, act_value
+					my_agent->smem_stmts->web_add->bind_int( 1, parent_id );
+					my_agent->smem_stmts->web_add->bind_int( 2, p->first );
+					my_agent->smem_stmts->web_add->bind_int( 3, SMEM_WEB_NULL );
+					my_agent->smem_stmts->web_add->bind_int( 4, p->second );
+					my_agent->smem_stmts->web_add->bind_double( 5, web_act );
+					my_agent->smem_stmts->web_add->execute( soar_module::op_reinit );
 				}
 
-				// adjust count (adjustment, attr, lti)
-				my_agent->smem_stmts->ct_lti_update->bind_int( 1, p2->second );
-				my_agent->smem_stmts->ct_lti_update->bind_int( 2, p1->first );
-				my_agent->smem_stmts->ct_lti_update->bind_int( 3, p2->first );
-				my_agent->smem_stmts->ct_lti_update->execute( soar_module::op_reinit );
+				// update counter
+				{
+					// check if counter exists (and add if does not): attr, val
+					my_agent->smem_stmts->ct_lti_check->bind_int( 1, p->first );
+					my_agent->smem_stmts->ct_lti_check->bind_int( 2, p->second );
+					if ( my_agent->smem_stmts->ct_lti_check->execute( soar_module::op_reinit ) != soar_module::row )
+					{
+						my_agent->smem_stmts->ct_lti_add->bind_int( 1, p->first );
+						my_agent->smem_stmts->ct_lti_add->bind_int( 2, p->second );
+						my_agent->smem_stmts->ct_lti_add->execute( soar_module::op_reinit );
+					}
+					else
+					{
+						// adjust count (adjustment, attr, lti)
+						my_agent->smem_stmts->ct_lti_update->bind_int( 1, 1 );
+						my_agent->smem_stmts->ct_lti_update->bind_int( 2, p->first );
+						my_agent->smem_stmts->ct_lti_update->bind_int( 3, p->second );
+						my_agent->smem_stmts->ct_lti_update->execute( soar_module::op_reinit );
+					}
+				}
 			}
 		}
+		
+		// update attribute count
+		{
+			for ( std::set< smem_hash_id >::iterator a=attr_new.begin(); a!=attr_new.end(); a++ )
+			{
+				// check if counter exists (and add if does not): attr
+				my_agent->smem_stmts->ct_attr_check->bind_int( 1, *a );
+				if ( my_agent->smem_stmts->ct_attr_check->execute( soar_module::op_reinit ) != soar_module::row )
+				{
+					my_agent->smem_stmts->ct_attr_add->bind_int( 1, *a );
+					my_agent->smem_stmts->ct_attr_add->execute( soar_module::op_reinit );
+				}
+				else
+				{
+					// adjust count (adjustment, attr)
+					my_agent->smem_stmts->ct_attr_update->bind_int( 1, 1 );
+					my_agent->smem_stmts->ct_attr_update->bind_int( 2, *a );
+					my_agent->smem_stmts->ct_attr_update->execute( soar_module::op_reinit );
+				}
+			}
+		}
+		
+		// update local edge count
+		{
+			my_agent->smem_stats->slots->set_value( my_agent->smem_stats->slots->get_value() + ( const_new.size() + lti_new.size() ) );
+		}
 	}
-
-	// update child count
-	{
-		my_agent->smem_stmts->act_lti_child_ct_set->bind_int( 1, child_ct );
-		my_agent->smem_stmts->act_lti_child_ct_set->bind_int( 2, parent_id );
-		my_agent->smem_stmts->act_lti_child_ct_set->execute( soar_module::op_reinit );
-	}
 }


#########################
# smem_soar_store()

 void smem_soar_store( agent *my_agent, Symbol *id, smem_storage_type store_type = store_level, tc_number tc = NIL )
@@ -1551,11 +1909,16 @@
 	{
 		tc = get_new_tc_number( my_agent );
 	}
+	smem_sym_list shorties;
 
 	// get level
 	smem_wme_list *children = smem_get_direct_augs_of_id( id, tc );
 	smem_wme_list::iterator w;
 
+	// make the target an lti, so intermediary data structure has lti_id
+	// (takes care of short-term id self-referencing)
+	smem_lti_soar_add( my_agent, id );
+
 	// encode this level
 	{
 		smem_sym_to_chunk_map sym_to_chunk;
@@ -1596,6 +1959,12 @@
 					(*c)->lti_number = (*w)->value->id.name_number;
 					(*c)->slots = NULL;
 					(*c)->soar_id = (*w)->value;
+					
+					// only traverse to short-term identifiers
+					if ( ( store_type == store_recursive ) && ( (*c)->lti_id == NIL ) )
+					{
+						shorties.push_back( (*c)->soar_id );
+					}
 				}
 
 				v->val_lti.val_value = (*c);
@@ -1605,7 +1974,7 @@
 			s->push_back( v );
 		}
 
-		smem_store_chunk( my_agent, smem_lti_soar_add( my_agent, id ), &( slots ) );
+		smem_store_chunk( my_agent, id->id.smem_lti, &( slots ), true, id );
 
 		// clean up
 		{
@@ -1625,23 +1994,16 @@
 			{
 				delete c_p->second;
 			}
+			
+			delete children;
 		}
 	}
 
 	// recurse as necessary
-	if ( store_type == store_recursive )
+	for ( smem_sym_list::iterator shorty=shorties.begin(); shorty!=shorties.end(); shorty++ )
 	{
-		for ( w=children->begin(); w!=children->end(); w++ )
-		{
-			if ( !smem_symbol_is_constant( (*w)->value ) )
-			{
-				smem_soar_store( my_agent, (*w)->value, store_type, tc );
-			}
-		}
+		smem_soar_store( my_agent, (*shorty), store_recursive, tc );
 	}
-
-	// clean up child wme list
-	delete children;
 }
 

#######################3
# smem_install_memory()

@@ -1651,7 +2013,7 @@
 //////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////
 
-void smem_install_memory( agent *my_agent, Symbol *state, smem_lti_id parent_id, Symbol *lti = NIL )
+void smem_install_memory( agent *my_agent, Symbol *state, smem_lti_id parent_id, Symbol *lti, bool activate_lti, soar_module::symbol_triple_list& meta_wmes, soar_module::symbol_triple_list& retrieval_wmes )
 {
 	////////////////////////////////////////////////////////////////////////////
 	my_agent->smem_timers->ncb_retrieval->start();
@@ -1669,7 +2031,7 @@
 		q->bind_int( 1, parent_id );
 		q->execute();
 
-		lti = smem_lti_soar_make( my_agent, parent_id, static_cast<char>( q->column_int( 0 ) ), static_cast<unsigned long>( q->column_int( 1 ) ), result_header->id.level );
+		lti = smem_lti_soar_make( my_agent, parent_id, static_cast<char>( q->column_int( 0 ) ), static_cast<uint64_t>( q->column_int( 1 ) ), result_header->id.level );
 
 		q->reinitialize();
 
@@ -1677,10 +2039,13 @@
 	}
 
 	// activate lti
-	smem_lti_activate( my_agent, parent_id );
+	if ( activate_lti )
+	{
+		smem_lti_activate( my_agent, parent_id, true );
+	}
 
 	// point retrieved to lti
-	smem_add_meta_wme( my_agent, state, result_header, my_agent->smem_sym_retrieved, lti );
+	smem_buffer_add_wme( meta_wmes, result_header, my_agent->smem_sym_retrieved, lti );
 	if ( lti_created_here )
 	{
 		// if the identifier was created above we need to
@@ -1691,9 +2056,11 @@
 	}	
 
 	// if no children, then retrieve children
-	if ( ( lti->id.impasse_wmes == NIL ) &&
+	// merge may override this behavior
+	if ( ( my_agent->smem_params->merge->get_value() == smem_param_container::merge_add ) || 
+		 ( ( lti->id.impasse_wmes == NIL ) &&
 		 ( lti->id.input_wmes == NIL ) &&
-		 ( lti->id.slots == NIL ) )
+		 ( lti->id.slots == NIL ) ) )
 	{
 		soar_module::sqlite_statement *expand_q = my_agent->smem_stmts->web_expand;
 		Symbol *attr_sym;
@@ -1707,9 +2074,9 @@
 			attr_sym = smem_reverse_hash( my_agent, static_cast<byte>( expand_q->column_int(0) ), static_cast<smem_hash_id>( expand_q->column_int(1) ) );
 
 			// identifier vs. constant
-			if ( expand_q->column_type( 6 ) != soar_module::null_t )
+			if ( expand_q->column_int( 6 ) != SMEM_WEB_NULL )
 			{
-				value_sym = smem_lti_soar_make( my_agent, static_cast<smem_lti_id>( expand_q->column_int( 6 ) ), static_cast<char>( expand_q->column_int( 4 ) ), static_cast<unsigned long>( expand_q->column_int( 5 ) ), lti->id.level );
+				value_sym = smem_lti_soar_make( my_agent, static_cast<smem_lti_id>( expand_q->column_int( 6 ) ), static_cast<char>( expand_q->column_int( 4 ) ), static_cast<uint64_t>( expand_q->column_int( 5 ) ), lti->id.level );
 			}
 			else
 			{
@@ -1717,7 +2084,7 @@
 			}
 
 			// add wme
-			smem_add_retrieved_wme( my_agent, state, lti, attr_sym, value_sym );
+			smem_buffer_add_wme( retrieval_wmes, lti, attr_sym, value_sym );
 
 			// deal with ref counts - attribute/values are always created in this function
 			// (thus an extra ref count is set before adding a wme)
 			
 			
############################
# adding smem_setup_web_crawl(), _smem_process_cue_wme()
# smem_process_query() moved below

@@ -1739,7 +2106,138 @@
 //////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////
 
-smem_lti_id smem_process_query( agent *my_agent, Symbol *state, Symbol *query, smem_lti_set *prohibit, smem_query_levels query_level = qry_full )
+inline soar_module::sqlite_statement* smem_setup_web_crawl(agent* my_agent, smem_weighted_cue_element* el)
+{
+	soar_module::sqlite_statement* q = NULL;
+
+	// first, point to correct query and setup
+	// query-specific parameters
+	if ( el->element_type == attr_t )
+	{
+		// attr=?
+		q = my_agent->smem_stmts->web_attr_all;
+	}
+	else if ( el->element_type == value_const_t )
+	{
+		// attr=? AND val_const=?
+		q = my_agent->smem_stmts->web_const_all;
+		q->bind_int( 2, el->value_hash );
+	}
+	else if ( el->element_type == value_lti_t )
+	{
+		// attr=? AND val_lti=?
+		q = my_agent->smem_stmts->web_lti_all;
+		q->bind_int( 2, el->value_lti );
+	}
+
+	// all require hash as first parameter
+	q->bind_int( 1, el->attr_hash );
+
+	return q;
+}
+
+inline bool _smem_process_cue_wme( agent* my_agent, wme* w, bool pos_cue, smem_prioritized_weighted_cue& weighted_pq )
+{
+	bool good_wme = true;
+	smem_weighted_cue_element *new_cue_element;
+	
+	smem_hash_id attr_hash;
+	smem_hash_id value_hash;
+	smem_lti_id value_lti;
+	smem_cue_element_type element_type;
+	
+	soar_module::sqlite_statement *q = NULL;
+	
+	{
+		// we only have to do hard work if
+		attr_hash = smem_temporal_hash( my_agent, w->attr, false );
+		if ( attr_hash != NIL )
+		{
+			if ( smem_symbol_is_constant( w->value ) )
+			{
+				value_lti = NIL;
+				value_hash = smem_temporal_hash( my_agent, w->value, false );
+				
+				if ( value_hash != NIL )
+				{
+					q = my_agent->smem_stmts->ct_const_get;
+					q->bind_int( 1, attr_hash );
+					q->bind_int( 2, value_hash );
+					
+					element_type = value_const_t;
+				}
+				else
+				{
+					if ( pos_cue )
+					{
+						good_wme = false;
+					}
+				}
+			}
+			else
+			{
+				value_lti = w->value->id.smem_lti;
+				value_hash = NIL;
+				
+				if ( value_lti == NIL )
+				{
+					q = my_agent->smem_stmts->ct_attr_get;
+					q->bind_int( 1, attr_hash );
+					
+					element_type = attr_t;
+				}
+				else
+				{
+					q = my_agent->smem_stmts->ct_lti_get;
+					q->bind_int( 1, attr_hash );
+					q->bind_int( 2, value_lti );
+					
+					element_type = value_lti_t;
+				}
+			}
+			
+			if ( good_wme )
+			{
+				if ( q->execute() == soar_module::row )
+				{
+					new_cue_element = new smem_weighted_cue_element;
+					
+					new_cue_element->weight = q->column_int( 0 );
+					new_cue_element->attr_hash = attr_hash;
+					new_cue_element->value_hash = value_hash;
+					new_cue_element->value_lti = value_lti;
+					new_cue_element->cue_element = w;
+					
+					new_cue_element->element_type = element_type;
+					new_cue_element->pos_element = pos_cue;
+					
+					weighted_pq.push( new_cue_element );
+					new_cue_element = NULL;
+				}
+				else
+				{
+					if ( pos_cue )
+					{
+						good_wme = false;
+					}
+				}
+				
+				q->reinitialize();
+			}
+		}
+		else
+		{
+			if ( pos_cue )
+			{
+				good_wme = false;
+			}
+		}
+	}
+	
+	return good_wme;
+}
+

##########################
# smem_process_query()
# major changes, maybe just report?

+smem_lti_id smem_process_query( agent *my_agent, Symbol *state, Symbol *query, Symbol *negquery, smem_lti_set *prohibit, soar_module::wme_set& cue_wmes, soar_module::symbol_triple_list& meta_wmes, soar_module::symbol_triple_list& retrieval_wmes, smem_query_levels query_level = qry_full )
 {	
 	smem_weighted_cue_list weighted_cue;	
 	bool good_cue = true;
@@ -1755,100 +2253,44 @@
 	// prepare query stats
 	{
 		smem_prioritized_weighted_cue weighted_pq;
-		smem_weighted_cue_element *new_cue_element;
-		
-		smem_wme_list *cue = smem_get_direct_augs_of_id( query );
-		smem_wme_list::iterator cue_p;
 
-		smem_hash_id attr_hash;
-		smem_hash_id value_hash;
-		smem_lti_id value_lti;
-		smem_cue_element_type element_type = attr_t;
-
-		wme *w;
-
-		for ( cue_p=cue->begin(); cue_p!=cue->end(); cue_p++ )
+		// positive cue - always
 		{
-			w = (*cue_p);
+			smem_wme_list *cue = smem_get_direct_augs_of_id( query );
+			if ( cue->empty() )
+			{
+				good_cue = false;
+			}
+			
+			for ( smem_wme_list::iterator cue_p=cue->begin(); cue_p!=cue->end(); cue_p++ )
+			{
+				cue_wmes.insert( (*cue_p) );
 
-			state->id.smem_info->cue_wmes->insert( w );
-
-			if ( good_cue )
-			{
-				// we only have to do hard work if
-				attr_hash = smem_temporal_hash( my_agent, w->attr, false );
-				if ( attr_hash != NIL )
+				if ( good_cue )
 				{
-					if ( smem_symbol_is_constant( w->value ) )
-					{
-						value_lti = NIL;
-						value_hash = smem_temporal_hash( my_agent, w->value, false );
-
-						if ( value_hash != NIL )
-						{
-							q = my_agent->smem_stmts->ct_const_get;
-							q->bind_int( 1, attr_hash );
-							q->bind_int( 2, value_hash );
-
-							element_type = value_const_t;
-						}
-						else
-						{
-							good_cue = false;
-						}
-					}
-					else
-					{
-						value_lti = w->value->id.smem_lti;
-						value_hash = NIL;
-
-						if ( value_lti == NIL )
-						{
-							q = my_agent->smem_stmts->ct_attr_get;
-							q->bind_int( 1, attr_hash );
-
-							element_type = attr_t;
-						}
-						else
-						{
-							q = my_agent->smem_stmts->ct_lti_get;
-							q->bind_int( 1, attr_hash );
-							q->bind_int( 2, value_lti );
-
-							element_type = value_lti_t;
-						}
-					}
-
-					if ( good_cue )
-					{
-						if ( q->execute() == soar_module::row )
-						{
-							new_cue_element = new smem_weighted_cue_element;
-
-							new_cue_element->weight = q->column_int( 0 );
-							new_cue_element->attr_hash = attr_hash;
-							new_cue_element->value_hash = value_hash;
-							new_cue_element->value_lti = value_lti;
-							new_cue_element->cue_element = w;
-
-							new_cue_element->element_type = element_type;
-
-							weighted_pq.push( new_cue_element );
-							new_cue_element = NULL;
-						}
-						else
-						{
-							good_cue = false;
-						}
-
-						q->reinitialize();
-					}
+					good_cue = _smem_process_cue_wme( my_agent, (*cue_p), true, weighted_pq );
 				}
-				else
+			}
+			
+			delete cue;
+		}
+		
+		// negative cue - if present
+		if ( negquery )
+		{
+			smem_wme_list *cue = smem_get_direct_augs_of_id( negquery );
+			
+			for ( smem_wme_list::iterator cue_p=cue->begin(); cue_p!=cue->end(); cue_p++ )
+			{
+				cue_wmes.insert( (*cue_p) );
+				
+				if ( good_cue )
 				{
-					good_cue = false;
+					good_cue = _smem_process_cue_wme( my_agent, (*cue_p), false, weighted_pq );
 				}
 			}
+			
+			delete cue;
 		}
 
 		// if valid cue, transfer priority queue to list
@@ -1869,60 +2311,73 @@
 				weighted_pq.pop();
 			}
 		}
-
-		// clean cue irrespective of validity
-		delete cue;
 	}
 
 	// only search if the cue was valid
 	if ( good_cue && !weighted_cue.empty() )
 	{
-		smem_weighted_cue_list::iterator first_element = weighted_cue.begin();
+		// by definition, the first positive-cue element dictates the candidate set
+		smem_weighted_cue_list::iterator cand_set;
 		smem_weighted_cue_list::iterator next_element;
-		smem_weighted_cue_list::iterator second_element = first_element;		
-		second_element++;
+		for ( next_element=weighted_cue.begin(); next_element!=weighted_cue.end(); next_element++ )
+		{
+			if ( (*next_element)->pos_element )
+			{
+				cand_set = next_element;
+				break;
+			}
+		}
 
 		soar_module::sqlite_statement *q2 = NULL;
 		smem_lti_set::iterator prohibit_p;
 
 		smem_lti_id cand;
 		bool good_cand;
-		
-		// setup first query, which is sorted on activation already
+
+		if ( my_agent->smem_params->activation_mode->get_value() == smem_param_container::act_base )
 		{
-			if ( (*first_element)->element_type == attr_t )
+			// naive base-level updates means update activation of
+			// every candidate in the minimal list before the
+			// confirmation walk
+			if ( my_agent->smem_params->base_update->get_value() == smem_param_container::bupt_naive )
 			{
-				// attr=?
-				q = my_agent->smem_stmts->web_attr_all;
+				q = smem_setup_web_crawl( my_agent, (*cand_set) );
+
+				// queue up distinct lti's to update
+				// - set because queries could contain wilds
+				// - not in loop because the effects of activation may actually
+				//   alter the resultset of the query (isolation???)
+				std::set< smem_lti_id > to_update;
+				while ( q->execute() == soar_module::row )
+				{
+					to_update.insert( q->column_int(0) );
+				}
+
+				for ( std::set< smem_lti_id >::iterator it=to_update.begin(); it!=to_update.end(); it++ )
+				{
+					smem_lti_activate( my_agent, (*it), false );
+				}
+
+				q->reinitialize();
 			}
-			else if ( (*first_element)->element_type == value_const_t )
-			{
-				// attr=? AND val_const=?
-				q = my_agent->smem_stmts->web_const_all;
-				q->bind_int( 2, (*first_element)->value_hash );
-			}
-			else if ( (*first_element)->element_type == value_lti_t )
-			{
-				// attr=? AND val_lti=?
-				q = my_agent->smem_stmts->web_lti_all;
-				q->bind_int( 2, (*first_element)->value_lti );
-			}
-
-			// all require hash as first parameter
-			q->bind_int( 1, (*first_element)->attr_hash );
 		}
+		
+		// setup first query, which is sorted on activation already
+		q = smem_setup_web_crawl( my_agent, (*cand_set) );
 
+		// this becomes the minimal set to walk (till match or fail)
 		if ( q->execute() == soar_module::row )
 		{
 			smem_prioritized_activated_lti_queue plentiful_parents;
 			bool more_rows = true;
 			bool use_db = false;
+			bool has_feature = false;
 
-			while ( more_rows && ( q->column_int( 1 ) == SMEM_ACT_MAX ) )
+			while ( more_rows && ( q->column_double( 1 ) == static_cast<double>( SMEM_ACT_MAX ) ) )
 			{
 				my_agent->smem_stmts->act_lti_get->bind_int( 1, q->column_int( 0 ) );
 				my_agent->smem_stmts->act_lti_get->execute();				
-				plentiful_parents.push( std::make_pair< intptr_t, smem_lti_id >( my_agent->smem_stmts->act_lti_get->column_int( 0 ), q->column_int( 0 ) ) );
+				plentiful_parents.push( std::make_pair< double, smem_lti_id >( my_agent->smem_stmts->act_lti_get->column_double( 0 ), q->column_int( 0 ) ) );
 				my_agent->smem_stmts->act_lti_get->reinitialize();
 
 				more_rows = ( q->execute() == soar_module::row );
@@ -1944,7 +2399,7 @@
 					}
 					else
 					{
-						use_db = ( q->column_int( 1 ) >  plentiful_parents.top().first );						
+						use_db = ( q->column_double( 1 ) >  plentiful_parents.top().first );						
 					}
 
 					if ( use_db )
@@ -1965,8 +2420,14 @@
 				{
 					good_cand = true;
 
-					for ( next_element=second_element; ( ( good_cand ) && ( next_element!=weighted_cue.end() ) ); next_element++ )
+					for ( next_element=weighted_cue.begin(); next_element!=weighted_cue.end(); next_element++ )
 					{
+						// don't need to check the generating list
+						if ( (*next_element) == (*cand_set) )
+						{
+							continue;
+						}
+						
 						if ( (*next_element)->element_type == attr_t )
 						{
 							// parent=? AND attr=?
@@ -1989,7 +2450,12 @@
 						q2->bind_int( 1, cand );
 						q2->bind_int( 2, (*next_element)->attr_hash );
 
-						good_cand = ( q2->execute( soar_module::op_reinit ) == soar_module::row );
+						has_feature = ( q2->execute( soar_module::op_reinit ) == soar_module::row );
+						good_cand = ( ( (*next_element)->pos_element )?( has_feature ):( !has_feature ) );
+						if ( !good_cand )
+						{
+							break;
+						}
 					}
 
 					if ( good_cand )
@@ -2015,17 +2481,25 @@
 		if ( king_id != NIL )
 		{
 			// success!
-			smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_success, query );
+			smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_success, query );
+			if ( negquery )
+			{
+				smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_success, negquery );
+			}
 
 			////////////////////////////////////////////////////////////////////////////
 			my_agent->smem_timers->query->stop();
 			////////////////////////////////////////////////////////////////////////////
 
-			smem_install_memory( my_agent, state, king_id );
+			smem_install_memory( my_agent, state, king_id, NIL, ( my_agent->smem_params->activate_on_query->get_value() == soar_module::on ), meta_wmes, retrieval_wmes );
 		}
 		else
 		{
-			smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_failure, query );
+			smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_failure, query );
+			if ( negquery )
+			{
+				smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_failure, negquery );
+			}
 
 			////////////////////////////////////////////////////////////////////////////
 			my_agent->smem_timers->query->stop();
 			
#########################
# smem_clear_result()

@@ -2055,8 +2529,8 @@
 
 	while ( !state->id.smem_info->smem_wmes->empty() )
 	{
-		pref = state->id.smem_info->smem_wmes->top();
-		state->id.smem_info->smem_wmes->pop();
+		pref = state->id.smem_info->smem_wmes->back();
+		state->id.smem_info->smem_wmes->pop_back();
 
 		if ( pref->in_tm )
 		{
 		
####################
# smem_reset()

@@ -2081,15 +2555,10 @@
 		data->last_cmd_time[1] = 0;
 		data->last_cmd_count[0] = 0;
 		data->last_cmd_count[1] = 0;
-
-		data->cue_wmes->clear();
 		
 		// this will be called after prefs from goal are already removed,
 		// so just clear out result stack
-		while ( !data->smem_wmes->empty() )
-		{
-			data->smem_wmes->pop();
-		}		
+		data->smem_wmes->clear();
 
 		state = state->id.lower_goal;
 	}
 	
####################
# smem_init_db()

@@ -2135,26 +2604,55 @@
 
 		// apply performance options
 		{
-			// cache
+			// page_size
 			{
-				switch ( my_agent->smem_params->cache->get_value() )
+				switch ( my_agent->smem_params->page_size->get_value() )
 				{
-					// 5MB cache
-					case ( smem_param_container::cache_S ):
-						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA cache_size = 5000" );
+					case ( smem_param_container::page_1k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 1024" );
 						break;
-
-					// 20MB cache
-					case ( smem_param_container::cache_M ):
-						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA cache_size = 20000" );
+						
+					case ( smem_param_container::page_2k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 2048" );
 						break;
-
-					// 100MB cache
-					case ( smem_param_container::cache_L ):
-						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA cache_size = 100000" );
+						
+					case ( smem_param_container::page_4k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 4096" );
 						break;
+						
+					case ( smem_param_container::page_8k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 8192" );
+						break;
+						
+					case ( smem_param_container::page_16k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 16384" );
+						break;
+						
+					case ( smem_param_container::page_32k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 32768" );
+						break;
+						
+					case ( smem_param_container::page_64k ):
+						temp_q = new soar_module::sqlite_statement( my_agent->smem_db, "PRAGMA page_size = 65536" );
+						break;
 				}
+				
+				temp_q->prepare();
+				temp_q->execute();
+				delete temp_q;
+				temp_q = NULL;
+			}
+			
+			// cache_size
+			{
+				std::string cache_sql( "PRAGMA cache_size = " );
+                char* str = my_agent->smem_params->cache_size->get_string();
+				cache_sql.append( str );
+				free(str);
+                str = NULL;
 
+				temp_q = new soar_module::sqlite_statement( my_agent->smem_db, cache_sql.c_str() );
+				
 				temp_q->prepare();
 				temp_q->execute();
 				delete temp_q;
@@ -2227,7 +2725,7 @@
 			my_agent->smem_stmts->begin->execute( soar_module::op_reinit );
 			{
 				// max cycle
-				my_agent->smem_max_cycle = 1;
+				my_agent->smem_max_cycle = static_cast<int64_t>( 1 );
 				smem_variable_create( my_agent, var_max_cycle, 1 );
 
 				// number of nodes
@@ -2239,13 +2737,16 @@
 				smem_variable_create( my_agent, var_num_edges, 0 );
 
 				// threshold (from user parameter value)
-				smem_variable_create( my_agent, var_act_thresh, static_cast<intptr_t>( my_agent->smem_params->thresh->get_value() ) );
+				smem_variable_create( my_agent, var_act_thresh, static_cast<int64_t>( my_agent->smem_params->thresh->get_value() ) );
+				
+				// activation mode (from user parameter value)
+				smem_variable_create( my_agent, var_act_mode, static_cast<int64_t>( my_agent->smem_params->activation_mode->get_value() ) );
 			}
 			my_agent->smem_stmts->commit->execute( soar_module::op_reinit );
 		}
 		else
 		{
-			intptr_t temp;
+			int64_t temp;
 
 			// max cycle
 			smem_variable_get( my_agent, var_max_cycle, &( my_agent->smem_max_cycle ) );
@@ -2260,7 +2761,11 @@
 
 			// threshold
 			smem_variable_get( my_agent, var_act_thresh, &( temp ) );
-			my_agent->smem_params->thresh->set_value( static_cast<long>( temp ) );
+			my_agent->smem_params->thresh->set_value( temp );
+			
+			// activation mode
+			smem_variable_get( my_agent, var_act_mode, &( temp ) );
+			my_agent->smem_params->activation_mode->set_value( static_cast< smem_param_container::act_choices >( temp ) );
 		}
 
 		// reset identifier counters
@@ -2286,18 +2791,23 @@
 	}
 }

##########################
# new function _smem_close_vars()

+inline void _smem_close_vars( agent* my_agent )
+{
+	// store max cycle for future use of the smem database
+	smem_variable_set( my_agent, var_max_cycle, my_agent->smem_max_cycle );
+
+	// store num nodes/edges for future use of the smem database
+	smem_variable_set( my_agent, var_num_nodes, my_agent->smem_stats->chunks->get_value() );
+	smem_variable_set( my_agent, var_num_edges, my_agent->smem_stats->slots->get_value() );
+}
+

#########################
# smem_close()

 // performs cleanup operations when the database needs to be closed (end soar, manual close, etc)
 void smem_close( agent *my_agent )
 {
 	if ( my_agent->smem_db->get_status() == soar_module::connected )
 	{
-		// store max cycle for future use of the smem database
-		smem_variable_set( my_agent, var_max_cycle, my_agent->smem_max_cycle );
+		_smem_close_vars( my_agent );
 
-		// store num nodes/edges for future use of the smem database
-		smem_variable_set( my_agent, var_num_nodes, my_agent->smem_stats->chunks->get_value() );
-		smem_variable_set( my_agent, var_num_edges, my_agent->smem_stats->slots->get_value() );
-
 		// if lazy, commit
 		if ( my_agent->smem_params->lazy_commit->get_value() == soar_module::on )
 		{
@@ -2378,7 +2888,7 @@
 	}
 }

#######################
# smem_parse_lti_name()
# type change is irrelevant for jsoar -- don't think these changes need to be ported

-inline std::string *smem_parse_lti_name( struct lexeme_info *lexeme, char *id_letter, unsigned long *id_number )
+inline std::string *smem_parse_lti_name( struct lexeme_info *lexeme, char *id_letter, uint64_t *id_number )
 {
 	std::string *return_val = new std::string;
 
@@ -2397,8 +2907,8 @@
 	{
 		return_val->assign( (*lexeme).string );
 
-		(*id_letter) = static_cast<char>( static_cast<int>( toupper( (*lexeme).string[1] ) ) );
-		(*id_number) = NIL;
+		(*id_letter) = static_cast<char>( toupper( (*lexeme).string[1] ) );
+		(*id_number) = 0;
 	}
 
 	return return_val;
 	
############################
# smem_parse_constant_attr()
# irrelevant change

@@ -2408,7 +2918,7 @@
 {
 	Symbol *return_val = NIL;
 
-	if ( ( (*lexeme).type == SYM_CONSTANT_LEXEME ) )
+	if ( (*lexeme).type == SYM_CONSTANT_LEXEME )
 	{
 		return_val = make_sym_constant( my_agent, static_cast<const char *>( (*lexeme).string ) );
 	}
 	
#############################
# smem_parse_chunk()
# many (but not all) of these changes are irrelevant

@@ -2434,7 +2944,7 @@
 	std::string *chunk_name = NULL;
 
 	char temp_letter;
-	unsigned long temp_number;
+	uint64_t temp_number;
 
 	bool good_at;
 
@@ -2469,7 +2979,7 @@
 
 			//
 
-			unsigned long intermediate_counter = 1;
+			uint64_t intermediate_counter = 1;
 			smem_chunk *intermediate_parent;
 			smem_chunk *temp_chunk;
 			std::string temp_key;
@@ -2545,23 +3055,25 @@
 
 					if ( chunk_attr != NIL )
 					{
+						bool first_value = true;
+						
 						do
 						{
 							// value by type
 							chunk_value = NIL;
-							if ( ( my_agent->lexeme.type == SYM_CONSTANT_LEXEME ) )
+							if ( my_agent->lexeme.type == SYM_CONSTANT_LEXEME )
 							{
 								chunk_value = new smem_chunk_value;
 								chunk_value->val_const.val_type = value_const_t;
 								chunk_value->val_const.val_value = make_sym_constant( my_agent, static_cast<const char *>( my_agent->lexeme.string ) );
 							}
-							else if ( ( my_agent->lexeme.type == INT_CONSTANT_LEXEME ) )
+							else if ( my_agent->lexeme.type == INT_CONSTANT_LEXEME )
 							{
 								chunk_value = new smem_chunk_value;
 								chunk_value->val_const.val_type = value_const_t;
 								chunk_value->val_const.val_value = make_int_constant( my_agent, my_agent->lexeme.int_val );
 							}
-							else if ( ( my_agent->lexeme.type == FLOAT_CONSTANT_LEXEME ) )
+							else if ( my_agent->lexeme.type == FLOAT_CONSTANT_LEXEME )
 							{
 								chunk_value = new smem_chunk_value;
 								chunk_value->val_const.val_type = value_const_t;
@@ -2603,7 +3115,8 @@
 										temp_chunk->lti_letter = temp_letter;
 										temp_chunk->lti_number = temp_number;
 										temp_chunk->lti_id = NIL;
-										temp_chunk->slots = NULL;
+										temp_chunk->slots = NIL;
+										temp_chunk->soar_id = NIL;
 
 										// associate with value
 										chunk_value->val_lti.val_value = temp_chunk;
@@ -2626,6 +3139,11 @@
 
 								// add to appropriate slot
 								s = smem_make_slot( intermediate_parent->slots, chunk_attr );
+								if ( first_value && !s->empty() )
+								{
+									// in the case of a repeated attribute, remove ref here to avoid leak
+									symbol_remove_ref( my_agent, chunk_attr );
+								}
 								s->push_back( chunk_value );
 
 								// if this was the last attribute
@@ -2635,6 +3153,8 @@
 									get_lexeme( my_agent );
 									chunk_value = NIL;
 								}
+								
+								first_value = false;
 							}
 						} while ( chunk_value != NIL );
 					}
@@ -2725,121 +3245,111 @@
 	return return_val;
 }
 
############################
# bool smem_parse_chunks()

-bool smem_parse_chunks( agent *my_agent, const char *chunks, std::string **err_msg )
+bool smem_parse_chunks( agent *my_agent, const char *chunks_str, std::string **err_msg )
 {
 	bool return_val = false;
-	unsigned long clause_count = 0;
+	uint64_t clause_count = 0;
 
 	// parsing chunks requires an open semantic database
 	smem_attach( my_agent );
 
 	// copied primarily from cli_sp
-	my_agent->alternate_input_string = chunks;
+	my_agent->alternate_input_string = chunks_str;
 	my_agent->alternate_input_suffix = const_cast<char *>( ") " );
 	my_agent->current_char = ' ';
 	my_agent->alternate_input_exit = true;
 	set_lexer_allow_ids( my_agent, true );
+
+    bool good_chunk = true;
+		
+	smem_str_to_chunk_map chunks;
+	smem_str_to_chunk_map::iterator c_old;
+	
+	smem_chunk_set newbies;
+	smem_chunk_set::iterator c_new;		
+
+	// consume next token
 	get_lexeme( my_agent );
 
-	if ( my_agent->lexeme.type == L_BRACE_LEXEME )
+	// while there are chunks to consume
+	while ( ( my_agent->lexeme.type == L_PAREN_LEXEME ) && ( good_chunk ) )
 	{
-		bool good_chunk = true;
-		
-		smem_str_to_chunk_map chunks;
-		smem_str_to_chunk_map::iterator c_old;
-		
-		smem_chunk_set newbies;
-		smem_chunk_set::iterator c_new;		
+		good_chunk = smem_parse_chunk( my_agent, &( chunks ), &( newbies ) );
 
-		// consume next token
-		get_lexeme( my_agent );
-
-		// while there are chunks to consume
-		while ( ( my_agent->lexeme.type == L_PAREN_LEXEME ) && ( good_chunk ) )
+		if ( good_chunk )
 		{
-			good_chunk = smem_parse_chunk( my_agent, &( chunks ), &( newbies ) );
-
-			if ( good_chunk )
+			// add all newbie lti's as appropriate
+			for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
 			{
-				// add all newbie lti's as appropriate
-				for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
-				{
-					if ( (*c_new)->lti_id == NIL )
-					{					
-						// deal differently with variable vs. lti
-						if ( (*c_new)->lti_number == NIL )
+				if ( (*c_new)->lti_id == NIL )
+				{					
+					// deal differently with variable vs. lti
+					if ( (*c_new)->lti_number == NIL )
+					{
+						// add a new lti id (we have a guarantee this won't be in Soar's WM)
+						(*c_new)->lti_number = ( my_agent->id_counter[ (*c_new)->lti_letter - static_cast<char>('A') ]++ );
+						(*c_new)->lti_id = smem_lti_add_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
+					}
+					else
+					{
+						// should ALWAYS be the case (it's a newbie and we've initialized lti_id to NIL)
+						if ( (*c_new)->lti_id == NIL )
 						{
-							// add a new lti id (we have a guarantee this won't be in Soar's WM)
-							(*c_new)->lti_number = ( my_agent->id_counter[ (*c_new)->lti_letter - static_cast<unsigned long>('A') ]++ );
-							(*c_new)->lti_id = smem_lti_add_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
-						}
-						else
-						{
-							// should ALWAYS be the case (it's a newbie and we've initialized lti_id to NIL)
+							// get existing
+							(*c_new)->lti_id = smem_lti_get_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
+
+							// if doesn't exist, add it
 							if ( (*c_new)->lti_id == NIL )
 							{
-								// get existing
-								(*c_new)->lti_id = smem_lti_get_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
+								(*c_new)->lti_id = smem_lti_add_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
 
-								// if doesn't exist, add it
-								if ( (*c_new)->lti_id == NIL )
+								// this could affect an existing identifier in Soar's WM
+								Symbol *id_parent = find_identifier( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
+								if ( id_parent != NIL )
 								{
-									(*c_new)->lti_id = smem_lti_add_id( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
+									// if so we make it an lti manually
+									id_parent->id.smem_lti = (*c_new)->lti_id;
 
-									// this could affect an existing identifier in Soar's WM
-									Symbol *id_parent = find_identifier( my_agent, (*c_new)->lti_letter, (*c_new)->lti_number );
-									if ( id_parent != NIL )
-									{
-										// if so we make it an lti manually
-										id_parent->id.smem_lti = (*c_new)->lti_id;
-
-										id_parent->id.smem_time_id = my_agent->epmem_stats->time->get_value();
-										id_parent->id.smem_valid = my_agent->epmem_validation;
-									}
+									id_parent->id.smem_time_id = my_agent->epmem_stats->time->get_value();
+									id_parent->id.smem_valid = my_agent->epmem_validation;
+									epmem_schedule_promotion( my_agent, id_parent );
 								}
 							}
 						}
 					}
 				}
+			}
 
-				// add all newbie contents (append, as opposed to replace, children)
-				for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
+			// add all newbie contents (append, as opposed to replace, children)
+			for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
+			{
+				if ( (*c_new)->slots != NIL )
 				{
-					if ( (*c_new)->slots != NIL )
-					{
-						smem_store_chunk( my_agent, (*c_new)->lti_id, (*c_new)->slots, false );
-					}
+					smem_store_chunk( my_agent, (*c_new)->lti_id, (*c_new)->slots, false );
 				}
+			}
 
-				// deallocate *contents* of all newbies (need to keep around name->id association for future chunks)
-				for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
-				{
-					smem_deallocate_chunk( my_agent, (*c_new), false );
-				}
-
-				// increment clause counter
-				clause_count++;
-
-				// clear newbie list
-				newbies.clear();
+			// deallocate *contents* of all newbies (need to keep around name->id association for future chunks)
+			for ( c_new=newbies.begin(); c_new!=newbies.end(); c_new++ )
+			{
+				smem_deallocate_chunk( my_agent, (*c_new), false );
 			}
-		};
 
-		if ( good_chunk && ( my_agent->lexeme.type == R_BRACE_LEXEME ) )
-		{
-			// consume right brace
-			get_lexeme( my_agent );
+			// increment clause counter
+			clause_count++;
 
-			// confirm (but don't consume) suffix
-			return_val = ( my_agent->lexeme.type == R_PAREN_LEXEME );		
+			// clear newbie list
+			newbies.clear();
 		}
+	};
 
-		// deallocate all chunks
+    return_val = good_chunk;
+
+	// deallocate all chunks
+	{
+		for ( c_old=chunks.begin(); c_old!=chunks.end(); c_old++ )
 		{
-			for ( c_old=chunks.begin(); c_old!=chunks.end(); c_old++ )
-			{
-				smem_deallocate_chunk( my_agent, c_old->second, true );
-			}
+			smem_deallocate_chunk( my_agent, c_old->second, true );
 		}
 	}

###########################
# smem_respond_to_cmd()

@@ -2873,7 +3383,12 @@
 	smem_wme_list *cmds;
 	smem_wme_list::iterator w_p;
 
+	soar_module::symbol_triple_list meta_wmes;
+	soar_module::symbol_triple_list retrieval_wmes;
+	soar_module::wme_set cue_wmes;
+
 	Symbol *query;
+	Symbol *negquery;
 	Symbol *retrieve;
 	smem_sym_list prohibit;
 	smem_sym_list store;
@@ -2881,10 +3396,10 @@
 	enum path_type { blank_slate, cmd_bad, cmd_retrieve, cmd_query, cmd_store } path;
 
 	unsigned int time_slot = ( ( store_only )?(1):(0) );
-	unsigned long wme_count;
+	uint64_t wme_count;
 	bool new_cue;
 
-	int tc;	
+	tc_number tc;	
 
 	Symbol *parent_sym;
 	std::queue<Symbol *> syms;
@@ -2892,6 +3407,11 @@
 	int parent_level;
 	std::queue<int> levels;	
 
+	bool do_wm_phase = false;
+	bool mirroring_on = ( my_agent->smem_params->mirroring->get_value() == soar_module::on );
+	
+	//
+
 	while ( state != NULL )
 	{
 		////////////////////////////////////////////////////////////////////////////
@@ -2924,7 +3444,7 @@
 				{
 					for ( w_p=wmes->begin(); w_p!=wmes->end(); w_p++ )
 					{
-						if ( ( ( store_only ) && ( ( parent_level != 0 ) || ( ( (*w_p)->attr != my_agent->smem_sym_query ) && ( (*w_p)->attr != my_agent->smem_sym_retrieve ) ) ) ) || 
+						if ( ( ( store_only ) && ( ( parent_level != 0 ) || ( (*w_p)->attr == my_agent->smem_sym_store ) ) ) || 
 							 ( ( !store_only ) && ( ( parent_level != 0 ) || ( (*w_p)->attr != my_agent->smem_sym_store ) ) ) )
 						{						
 							wme_count++;
@@ -2967,14 +3487,10 @@
 
 			if ( new_cue )
 			{
-				// clear old cue
-				state->id.smem_info->cue_wmes->clear();
-
 				// clear old results
 				smem_clear_result( my_agent, state );
 
-				// change is afoot!
-				my_agent->smem_made_changes = true;
+				do_wm_phase = true;
 			}
 		}		
 
@@ -2982,9 +3498,14 @@
 		// and there is something on the cue
 		if ( new_cue && wme_count )
 		{
+			cue_wmes.clear();
+			meta_wmes.clear();
+			retrieval_wmes.clear();
+			
 			// initialize command vars
 			retrieve = NIL;
 			query = NIL;
+			negquery = NIL;
 			store.clear();
 			prohibit.clear();
 			path = blank_slate;
@@ -2992,7 +3513,7 @@
 			// process top-level symbols
 			for ( w_p=cmds->begin(); w_p!=cmds->end(); w_p++ )
 			{
-				state->id.smem_info->cue_wmes->insert( (*w_p) );
+				cue_wmes.insert( (*w_p) );
 
 				if ( path != cmd_bad )
 				{
@@ -3025,6 +3546,21 @@
 							path = cmd_bad;
 						}
 					}
+					else if ( (*w_p)->attr == my_agent->smem_sym_negquery )
+					{
+						if ( ( (*w_p)->value->common.symbol_type == IDENTIFIER_SYMBOL_TYPE ) &&
+							 ( ( path == blank_slate ) || ( path == cmd_query ) ) &&
+							 ( negquery == NIL ) )
+							
+						{
+							negquery = (*w_p)->value;
+							path = cmd_query;
+						}
+						else
+						{
+							path = cmd_bad;
+						}
+					}
 					else if ( (*w_p)->attr == my_agent->smem_sym_prohibit )
 					{
 						if ( ( (*w_p)->value->common.symbol_type == IDENTIFIER_SYMBOL_TYPE ) &&
@@ -3087,15 +3623,15 @@
 					if ( retrieve->id.smem_lti == NIL )
 					{
 						// retrieve is not pointing to an lti!
-						smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_failure, retrieve );
+						smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_failure, retrieve );
 					}
 					else
 					{
 						// status: success
-						smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_success, retrieve );
+						smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_success, retrieve );
 
 						// install memory directly onto the retrieve identifier
-						smem_install_memory( my_agent, state, retrieve->id.smem_lti, retrieve );
+						smem_install_memory( my_agent, state, retrieve->id.smem_lti, retrieve, true, meta_wmes, retrieval_wmes );
 
 						// add one to the expansions stat
 						my_agent->smem_stats->expansions->set_value( my_agent->smem_stats->expansions->get_value() + 1 );
@@ -3112,7 +3648,7 @@
 						prohibit_lti.insert( (*sym_p)->id.smem_lti );
 					}
 
-					smem_process_query( my_agent, state, query, &( prohibit_lti ) );
+					smem_process_query( my_agent, state, query, negquery, &( prohibit_lti ), cue_wmes, meta_wmes, retrieval_wmes );
 
 					// add one to the cbr stat
 					my_agent->smem_stats->cbr->set_value( my_agent->smem_stats->cbr->get_value() + 1 );
@@ -3133,10 +3669,10 @@
 
 					for ( sym_p=store.begin(); sym_p!=store.end(); sym_p++ )
 					{
-						smem_soar_store( my_agent, (*sym_p) );
+						smem_soar_store( my_agent, (*sym_p), ( ( mirroring_on )?( store_recursive ):( store_level ) ) );
 
 						// status: success
-						smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_success, (*sym_p) );
+						smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_success, (*sym_p) );
 
 						// add one to the store stat
 						my_agent->smem_stats->stores->set_value( my_agent->smem_stats->stores->get_value() + 1 );
@@ -3155,8 +3691,45 @@
 			}
 			else
 			{
-				smem_add_meta_wme( my_agent, state, state->id.smem_result_header, my_agent->smem_sym_bad_cmd, state->id.smem_cmd_header );
+				smem_buffer_add_wme( meta_wmes, state->id.smem_result_header, my_agent->smem_sym_bad_cmd, state->id.smem_cmd_header );
 			}
+
+			if ( !meta_wmes.empty() || !retrieval_wmes.empty() )
+			{
+				// process preference assertion en masse
+				smem_process_buffered_wmes( my_agent, state, cue_wmes, meta_wmes, retrieval_wmes );
+
+				// clear cache
+				{
+					soar_module::symbol_triple_list::iterator mw_it;
+
+					for ( mw_it=retrieval_wmes.begin(); mw_it!=retrieval_wmes.end(); mw_it++ )
+					{
+						symbol_remove_ref( my_agent, (*mw_it)->id );
+						symbol_remove_ref( my_agent, (*mw_it)->attr );
+						symbol_remove_ref( my_agent, (*mw_it)->value );
+						
+						delete (*mw_it);
+					}
+					retrieval_wmes.clear();
+
+					for ( mw_it=meta_wmes.begin(); mw_it!=meta_wmes.end(); mw_it++ )
+					{
+						symbol_remove_ref( my_agent, (*mw_it)->id );
+						symbol_remove_ref( my_agent, (*mw_it)->attr );
+						symbol_remove_ref( my_agent, (*mw_it)->value );
+						
+						delete (*mw_it);
+					}
+					meta_wmes.clear();
+				}
+
+				// process wm changes on this state
+				do_wm_phase = true;
+			}
+
+			// clear cue wmes
+			cue_wmes.clear();
 		}
 		else
 		{
@@ -3170,14 +3743,59 @@
 
 		state = state->id.higher_goal;
 	}
+
+	if ( store_only && mirroring_on && ( !my_agent->smem_changed_ids->empty() ) )
+	{
+		////////////////////////////////////////////////////////////////////////////
+		my_agent->smem_timers->storage->start();
+		////////////////////////////////////////////////////////////////////////////
+
+		// start transaction (if not lazy)
+		if ( my_agent->smem_params->lazy_commit->get_value() == soar_module::off )
+		{
+			my_agent->smem_stmts->begin->execute( soar_module::op_reinit );
+		}
+		
+		for ( smem_pooled_symbol_set::iterator it=my_agent->smem_changed_ids->begin(); it!=my_agent->smem_changed_ids->end(); it++ )
+		{
+			// require that the lti has at least one augmentation
+			if ( (*it)->id.slots )
+			{
+				smem_soar_store( my_agent, (*it), store_recursive );
+
+				// add one to the mirrors stat
+				my_agent->smem_stats->mirrors->set_value( my_agent->smem_stats->mirrors->get_value() + 1 );
+			}
+
+			symbol_remove_ref( my_agent, (*it) );
+		}
+
+		// commit transaction (if not lazy)
+		if ( my_agent->smem_params->lazy_commit->get_value() == soar_module::off )
+		{
+			my_agent->smem_stmts->commit->execute( soar_module::op_reinit );
+		}
+
+		// clear symbol set
+		my_agent->smem_changed_ids->clear();
+
+		////////////////////////////////////////////////////////////////////////////
+		my_agent->smem_timers->storage->stop();
+		////////////////////////////////////////////////////////////////////////////
+	}
+
+	if ( do_wm_phase )
+	{
+		my_agent->smem_ignore_changes = true;
+		
+		do_working_memory_phase( my_agent );
+
+		my_agent->smem_ignore_changes = false;
+	}
 }


############################
# smem_go()

 void smem_go( agent *my_agent, bool store_only )
-{
-	// after we are done we will perform a wm phase
-	// if any adds/removes
-	my_agent->smem_made_changes = false;
-	
+{	
 	my_agent->smem_timers->total->start();
 
 #ifndef SMEM_EXPERIMENT
@@ -3189,11 +3807,34 @@
 #endif // SMEM_EXPERIMENT
 
 	my_agent->smem_timers->total->stop();
+}
 
-	if ( my_agent->smem_made_changes )

############################
# new function smem_backup_db()

+bool smem_backup_db( agent* my_agent, const char* file_name, std::string *err )
+{
+	bool return_val = false;
+	
+	if ( my_agent->smem_db->get_status() == soar_module::connected )
 	{
-		do_working_memory_phase( my_agent );
+		_smem_close_vars( my_agent );
+		
+		if ( my_agent->smem_params->lazy_commit->get_value() == soar_module::on )
+		{
+			my_agent->smem_stmts->commit->execute( soar_module::op_reinit );
+		}
+
+		return_val = my_agent->smem_db->backup( file_name, err );
+
+		if ( my_agent->smem_params->lazy_commit->get_value() == soar_module::on )
+		{
+			my_agent->smem_stmts->begin->execute( soar_module::op_reinit );
+		}
 	}
+	else
+	{
+		err->assign( "Semantic database is not currently connected." );
+	}
+
+	return return_val;
 }
 
#########################
# smem_visualize_store()

@@ -3223,11 +3864,11 @@
 
 		smem_lti_id lti_id;
 		char lti_letter;
-		unsigned long lti_number;
+		uint64_t lti_number;
 
 		std::string *lti_name;
 		std::string temp_str;
-		intptr_t temp_int;
+		int64_t temp_int;
 		double temp_double;
 
 		// id, letter, number
@@ -3236,7 +3877,7 @@
 		{
 			lti_id = q->column_int( 0 );
 			lti_letter = static_cast<char>( q->column_int( 1 ) );
-			lti_number = static_cast<unsigned long>( q->column_int( 2 ) );
+			lti_number = static_cast<uint64_t>( q->column_int( 2 ) );
 
 			lti_name =& lti_names[ lti_id ];
 			lti_name->push_back( lti_letter );
@@ -3245,7 +3886,21 @@
 			lti_name->append( temp_str );
 
 			return_val->append( (*lti_name) );
-			return_val->append( " " );
+			return_val->append( " [ label=\"" );
+			return_val->append( (*lti_name) );
+			return_val->append( "\\n[" );
+
+			temp_double = q->column_double( 3 );
+			to_string( temp_double, temp_str, 3, true );
+			if ( temp_double >= 0 )
+			{
+				return_val->append( "+" );
+			}
+			return_val->append( temp_str );
+
+			return_val->append( "]\"" );
+			return_val->append( " ];" );
+			return_val->append( "\n" );
 		}
 		q->reinitialize();
 
@@ -3260,7 +3915,6 @@
 				std::list<std::string> *my_terminals;
 				std::list<std::string>::size_type terminal_num;
 
-				return_val->append( ";" );
 				return_val->append( "\n" );
 
 				// proceed to terminal nodes
@@ -3438,23 +4092,26 @@
 	return_val->append( "\n" );
 }

##########################
# smem_visualize_lti()

-void smem_visualize_lti( agent *my_agent, smem_lti_id lti_id, unsigned long depth, std::string *return_val )
+void smem_visualize_lti( agent *my_agent, smem_lti_id lti_id, unsigned int depth, std::string *return_val )
 {
+	// buffer
+	std::string return_val2;
+	
 	soar_module::sqlite_statement* expand_q = my_agent->smem_stmts->web_expand;
 
-	unsigned long child_counter;
+	uint64_t child_counter;
 
 	std::string temp_str;
 	std::string temp_str2;
-	intptr_t temp_int;
+	int64_t temp_int;
 	double temp_double;
 
 	std::queue<smem_vis_lti *> bfs;
 	smem_vis_lti *new_lti;
 	smem_vis_lti *parent_lti;
 
-	std::set<smem_lti_id> close_list;
-	std::set<smem_lti_id>::iterator cl_p;
+	std::map< smem_lti_id, smem_vis_lti* > close_list;
+	std::map< smem_lti_id, smem_vis_lti* >::iterator cl_p;
 
 	// header
 	return_val->append( "digraph smem_lti {" );
@@ -3484,20 +4141,12 @@
 
 			// done with lookup
 			lti_q->reinitialize();
-
-			// output without linkage
-			return_val->append( "node [ shape = doublecircle ];" );
-			return_val->append( "\n" );
-
-			return_val->append( new_lti->lti_name );
-			return_val->append( ";" );
-			return_val->append( "\n" );
 		}
 
 		bfs.push( new_lti );
+		close_list.insert( std::make_pair< smem_lti_id, smem_vis_lti* >( lti_id, new_lti ) );
+
 		new_lti = NULL;
-
-		close_list.insert( lti_id );
 	}
 
 	// optionally depth-limited breadth-first-search of children
@@ -3513,7 +4162,7 @@
 		while ( expand_q->execute() == soar_module::row )
 		{
 			// identifier vs. constant
-			if ( expand_q->column_type( 6 ) != soar_module::null_t )
+			if ( expand_q->column_int( 6 ) != SMEM_WEB_NULL )
 			{
 				new_lti = new smem_vis_lti;
 				new_lti->lti_id = expand_q->column_int( 6 );
@@ -3528,14 +4177,6 @@
 					temp_int = expand_q->column_int( 5 );
 					to_string( temp_int, temp_str );
 					new_lti->lti_name.append( temp_str );
-
-					// output node
-					return_val->append( "node [ shape = doublecircle ];" );
-					return_val->append( "\n" );
-
-					return_val->append( new_lti->lti_name );
-					return_val->append( ";" );
-					return_val->append( "\n" );
 				}
 
 
@@ -3564,34 +4205,32 @@
 					}
 
 					// output linkage
-					return_val->append( parent_lti->lti_name );
-					return_val->append( " -> " );
-					return_val->append( new_lti->lti_name );
-					return_val->append( " [ label = \"" );
-					return_val->append( temp_str );
-					return_val->append( "\" ];" );
-					return_val->append( "\n" );
+					return_val2.append( parent_lti->lti_name );
+					return_val2.append( " -> " );
+					return_val2.append( new_lti->lti_name );
+					return_val2.append( " [ label = \"" );
+					return_val2.append( temp_str );
+					return_val2.append( "\" ];" );
+					return_val2.append( "\n" );
 				}
 
-				// add to bfs (if still in depth limit)
-				if ( ( depth == 0 ) || ( new_lti->level < depth ) )
+				// prevent looping
 				{
-					// prevent looping
 					cl_p = close_list.find( new_lti->lti_id );
 					if ( cl_p == close_list.end() )
 					{
-						close_list.insert( new_lti->lti_id );						
-						bfs.push( new_lti );
+						close_list.insert( std::make_pair< smem_lti_id, smem_vis_lti* >( new_lti->lti_id, new_lti ) );
+
+						if ( ( depth == 0 ) || ( new_lti->level < depth ) )
+						{
+							bfs.push( new_lti );
+						}
 					}
 					else
 					{
 						delete new_lti;
-					}				
+					}
 				}
-				else
-				{
-					delete new_lti;
-				}
 
 				new_lti = NULL;
 			}
@@ -3631,13 +4270,13 @@
 					}
 
 					// output node
-					return_val->append( "node [ shape = plaintext ];" );
-					return_val->append( "\n" );
-					return_val->append( temp_str2 );
-					return_val->append( " [ label=\"" );
-					return_val->append( temp_str );
-					return_val->append( "\" ];" );
-					return_val->append( "\n" );
+					return_val2.append( "node [ shape = plaintext ];" );
+					return_val2.append( "\n" );
+					return_val2.append( temp_str2 );
+					return_val2.append( " [ label=\"" );
+					return_val2.append( temp_str );
+					return_val2.append( "\" ];" );
+					return_val2.append( "\n" );
 				}
 
 				// add linkage
@@ -3665,25 +4304,259 @@
 					}
 
 					// output linkage
-					return_val->append( parent_lti->lti_name );
-					return_val->append( " -> " );
-					return_val->append( temp_str2 );
-					return_val->append( " [ label = \"" );
-					return_val->append( temp_str );
-					return_val->append( "\" ];" );
-					return_val->append( "\n" );
+					return_val2.append( parent_lti->lti_name );
+					return_val2.append( " -> " );
+					return_val2.append( temp_str2 );
+					return_val2.append( " [ label = \"" );
+					return_val2.append( temp_str );
+					return_val2.append( "\" ];" );
+					return_val2.append( "\n" );
 				}
 
 				child_counter++;
 			}
 		}
 		expand_q->reinitialize();
+	}
 
-		delete parent_lti;
+	// footer
+	return_val2.append( "}" );
+	return_val2.append( "\n" );
+
+	// handle lti nodes at once 
+	{
+		soar_module::sqlite_statement* act_q = my_agent->smem_stmts->vis_lti_act;
+		
+		return_val->append( "node [ shape = doublecircle ];" );
+		return_val->append( "\n" );
+		
+		for ( cl_p=close_list.begin(); cl_p!=close_list.end(); cl_p++ )
+		{
+			return_val->append( cl_p->second->lti_name );
+			return_val->append( " [ label=\"" );
+			return_val->append( cl_p->second->lti_name );
+			return_val->append( "\\n[" );
+
+			act_q->bind_int( 1, cl_p->first );
+			if ( act_q->execute() == soar_module::row )
+			{
+				temp_double = act_q->column_double( 0 );
+				to_string( temp_double, temp_str, 3, true );
+				if ( temp_double >= 0 )
+				{
+					return_val->append( "+" );
+				}
+				return_val->append( temp_str );
+			}
+			act_q->reinitialize();
+
+			return_val->append( "]\"" );
+			return_val->append( " ];" );
+			return_val->append( "\n" );
+			
+			delete cl_p->second;
+		}
 	}
 
-	// footer
-	return_val->append( "}" );
-	return_val->append( "\n" );
+	// transfer buffer after nodes
+	return_val->append( return_val2 );
 }

############################
# new functions _smem_print_lti(), smem_print_store(), smem_print_lti()

+inline std::set< smem_lti_id > _smem_print_lti( agent* my_agent, smem_lti_id lti_id, char lti_letter, uint64_t lti_number, double lti_act, std::string *return_val )
+{
+	std::set< smem_lti_id > next;
+
+	std::string temp_str, temp_str2, temp_str3;
+	int64_t temp_int;
+	double temp_double;
+
+	std::map< std::string, std::list< std::string > > augmentations;
+	std::map< std::string, std::list< std::string > >::iterator lti_slot;
+	std::list< std::string >::iterator slot_val;
+
+	soar_module::sqlite_statement* expand_q = my_agent->smem_stmts->web_expand;
+
+	//
+	//
+
+	return_val->append( "(@" );
+	return_val->push_back( lti_letter );
+	to_string( lti_number, temp_str );
+	return_val->append( temp_str );
+
+	// get direct children: attr_type, attr_hash, value_type, value_hash, value_letter, value_num, value_lti
+	expand_q->bind_int( 1, lti_id );
+	while ( expand_q->execute() == soar_module::row )
+	{
+		// get attribute
+		switch ( expand_q->column_int(0) )
+		{
+			case SYM_CONSTANT_SYMBOL_TYPE:
+				smem_reverse_hash_str( my_agent, expand_q->column_int(1), temp_str );							
+				break;
+
+			case INT_CONSTANT_SYMBOL_TYPE:
+				temp_int = smem_reverse_hash_int( my_agent, expand_q->column_int(1) );
+				to_string( temp_int, temp_str );
+				break;
+
+			case FLOAT_CONSTANT_SYMBOL_TYPE:
+				temp_double = smem_reverse_hash_float( my_agent, expand_q->column_int(1) );
+				to_string( temp_double, temp_str );
+				break;
+
+			default:
+				temp_str.clear();
+				break;
+		}
+
+		// identifier vs. constant
+		if ( expand_q->column_int( 6 ) != SMEM_WEB_NULL )
+		{
+			temp_str2.clear();
+			temp_str2.push_back( '@' );
+			
+			// letter
+			temp_str2.push_back( static_cast<char>( expand_q->column_int( 4 ) ) );
+
+			// number
+			temp_int = expand_q->column_int( 5 );
+			to_string( temp_int, temp_str3 );
+			temp_str2.append( temp_str3 );
+
+			// add to next
+			next.insert( static_cast< smem_lti_id >( expand_q->column_int( 6 ) ) );
+		}
+		else
+		{
+			switch ( expand_q->column_int(2) )
+			{
+				case SYM_CONSTANT_SYMBOL_TYPE:
+					smem_reverse_hash_str( my_agent, expand_q->column_int(3), temp_str2 );							
+					break;
+
+				case INT_CONSTANT_SYMBOL_TYPE:
+					temp_int = smem_reverse_hash_int( my_agent, expand_q->column_int(3) );
+					to_string( temp_int, temp_str2 );
+					break;
+
+				case FLOAT_CONSTANT_SYMBOL_TYPE:
+					temp_double = smem_reverse_hash_float( my_agent, expand_q->column_int(3) );
+					to_string( temp_double, temp_str2 );
+					break;
+
+				default:
+					temp_str2.clear();
+					break;
+			}
+		}
+
+		augmentations[ temp_str ].push_back( temp_str2 );
+	}
+	expand_q->reinitialize();
+
+	// output augmentations nicely
+	{
+		for ( lti_slot=augmentations.begin(); lti_slot!=augmentations.end(); lti_slot++ )
+		{
+			return_val->append( " ^" );
+			return_val->append( lti_slot->first );
+			
+			for ( slot_val=lti_slot->second.begin(); slot_val!=lti_slot->second.end(); slot_val++ )
+			{
+				return_val->append( " " );
+				return_val->append( (*slot_val) );
+			}
+		}
+	}
+	augmentations.clear();
+
+	return_val->append( " [" );
+	to_string( lti_act, temp_str, 3, true );
+	if ( lti_act >= 0 )
+	{
+		return_val->append( "+" );
+	}
+	return_val->append( temp_str );
+	return_val->append( "]" );
+	return_val->append( ")\n" );
+
+	return next;
+}
+
+void smem_print_store( agent *my_agent, std::string *return_val )
+{
+	// vizualizing the store requires an open semantic database
+	smem_attach( my_agent );
+
+	// id, letter, number
+	soar_module::sqlite_statement* q = my_agent->smem_stmts->vis_lti;
+	while ( q->execute() == soar_module::row )
+	{
+		_smem_print_lti( my_agent, q->column_int( 0 ), static_cast<char>( q->column_int( 1 ) ), static_cast<uint64_t>( q->column_int( 2 ) ), q->column_double( 3 ), return_val );
+	}
+	q->reinitialize();
+}
+
+void smem_print_lti( agent *my_agent, smem_lti_id lti_id, unsigned int depth, std::string *return_val )
+{
+	std::set< smem_lti_id > visited;
+	std::pair< std::set< smem_lti_id >::iterator, bool > visited_ins_result;
+
+	std::queue< std::pair< smem_lti_id, unsigned int > > to_visit;
+	std::pair< smem_lti_id, unsigned int > c;
+	
+	std::set< smem_lti_id > next;
+	std::set< smem_lti_id >::iterator next_it;
+
+	soar_module::sqlite_statement* lti_q = my_agent->smem_stmts->lti_letter_num;
+	soar_module::sqlite_statement* act_q = my_agent->smem_stmts->vis_lti_act;
+	unsigned int i;
+	
+	// vizualizing the store requires an open semantic database
+	smem_attach( my_agent );
+
+	// initialize queue/set
+	to_visit.push( std::make_pair< smem_lti_id, unsigned int >( lti_id, 1 ) );
+	visited.insert( lti_id );
+
+	while ( !to_visit.empty() )
+	{
+		c = to_visit.front();
+		to_visit.pop();
+
+		// output leading spaces ala depth
+		for ( i=1; i<c.second; i++ )
+		{
+			return_val->append( "  " );
+		}
+
+		// get lti info
+		{
+			lti_q->bind_int( 1, c.first );
+			lti_q->execute();
+
+			act_q->bind_int( 1, c.first );
+			act_q->execute();
+
+			next = _smem_print_lti( my_agent, c.first, static_cast<char>( lti_q->column_int( 0 ) ), static_cast<uint64_t>( lti_q->column_int( 1 ) ), act_q->column_double( 0 ), return_val );
+
+			// done with lookup
+			lti_q->reinitialize();
+			act_q->reinitialize();
+
+			// consider further depth
+			if ( c.second < depth )
+			{
+				for ( next_it=next.begin(); next_it!=next.end(); next_it++ )
+				{
+					visited_ins_result = visited.insert( (*next_it) );
+					if ( visited_ins_result.second )
+					{
+						to_visit.push( std::make_pair< smem_lti_id, unsigned int >( (*next_it), c.second+1 ) );
+					}
+				}
+			}
+		}
+	}
+}



###############################################
# agent.h
###############################################

###################
# these changes are in DefaultSemanticMemory.java

... 			
891 	892 		
892 	893 		uint64_t smem_validation;
893 	894 		bool smem_first_switch;
894 		- 	bool smem_made_changes;
895 	895 		int64_t smem_max_cycle;
896 	896 		
897 	897 		// JRV: Added to support XML management inside Soar
... 		

... 			
913 	913 		bool smem_first_switch;
914 	914 		int64_t smem_max_cycle;
915 	915 		
	916 	+ 	smem_pooled_symbol_set* smem_changed_ids;
	917 	+ 	bool smem_ignore_changes;
916 	918 		
917 	919 		// dynamic memory pools
918 	920 		std::map< size_t, memory_pool* >* dyn_memory_pools;
... 	

##################
# these changes in SemanticMemorySymbols.java

... 			
355 	355 		
356 	356 		Symbol * smem_sym_retrieve;
357 	357 		Symbol * smem_sym_query;
	358 	+ 	Symbol * smem_sym_negquery;
358 	359 		Symbol * smem_sym_prohibit;
359 	360 		Symbol * smem_sym_store;
360 	361 		
... 	

################################################
# agent.cpp
################################################

###################
# these changes are in DefaultSemanticMemory.java

... 			
383 	383 		newAgent->smem_validation = 0;
384 	384 		newAgent->smem_first_switch = true;
385 	385 		
	386 	+ 	newAgent->smem_changed_ids = new smem_pooled_symbol_set( std::less< Symbol* >(), soar_module::soar_memory_pool_allocator< Symbol* >( newAgent ) );
	387 	+ 	newAgent->smem_ignore_changes = false;
	388 	+ 	
386 	389 		// statistics initialization
387 	390 		newAgent->dc_stat_tracking = false;
388 	391 		newAgent->stats_db = new soar_module::sqlite_database();
... 			
455 	458 		
456 	459 		// cleanup smem
457 	460 		smem_close( delete_agent );
	461 	+ 	delete delete_agent->smem_changed_ids;
458 	462 		delete delete_agent->smem_params;
459 	463 		delete delete_agent->smem_stats;
460 	464 		delete delete_agent->smem_timers;
... 	
################################################
# decide.cpp
################################################

###################
# this change is in SemanticMemoryStateInfo.java

... 			
2275 	2274 		id->id.smem_info->last_cmd_time[1] = 0;
2276 	2275 		id->id.smem_info->last_cmd_count[0] = 0;
2277 	2276 		id->id.smem_info->last_cmd_count[1] = 0;
2278 		- 	id->id.smem_info->cue_wmes = new std::set<wme *>();
2279 	2277 		id->id.smem_info->smem_wmes = new std::stack<preference *>();
2280 	2278 		
2281 	2279 		
...

################################################
# rete.cpp
################################################

####################
# add_wme_to_rete()

... 			
1602 	1602 		}
1603 	1603 		}
1604 	1604 		}
	1605 	+ 	
	1606 	+ 	if ( ( w->id->id.smem_lti ) && ( !thisAgent->smem_ignore_changes ) && smem_enabled( thisAgent ) && ( thisAgent->smem_params->mirroring->get_value() == soar_module::on ) )
	1607 	+ 	{
	1608 	+ 	std::pair< smem_pooled_symbol_set::iterator, bool > insert_result = thisAgent->smem_changed_ids->insert( w->id );
	1609 	+ 	if ( insert_result.second )
	1610 	+ 	{
	1611 	+ 	symbol_add_ref( w->id );
	1612 	+ 	}
	1613 	+ 	}
1605 	1614 		}
1606 	1615 		
1607 	1616 		/* --- Removes a WME from the Rete. --- */
...

######################
# remove_wme_from_rete()
 			
1643 	1652 		}
1644 	1653 		}
1645 	1654 		}
	1655 	+ 	
	1656 	+ 	if ( ( w->id->id.smem_lti ) && ( !thisAgent->smem_ignore_changes ) && smem_enabled( thisAgent ) && ( thisAgent->smem_params->mirroring->get_value() == soar_module::on ) )
	1657 	+ 	{
	1658 	+ 	std::pair< smem_pooled_symbol_set::iterator, bool > insert_result = thisAgent->smem_changed_ids->insert( w->id );
	1659 	+ 	if ( insert_result.second )
	1660 	+ 	{
	1661 	+ 	symbol_add_ref( w->id );
	1662 	+ 	}
	1663 	+ 	}
1646 	1664 		
1647 	1665 		/* --- remove w from all_wmes_in_rete --- */
1648 	1666 		remove_from_dll (thisAgent->all_wmes_in_rete, w, rete_next, rete_prev);
... 	

################################################
# recmem.cpp
################################################

#######################
# assert_new_preferences()

... 			
1214 	1214 		else if (inst->in_ms || pref->o_supported)
1215 	1215 		{
1216 	1216 		/* --- normal case --- */
1217 		- 	add_preference_to_tm (thisAgent, pref);
	1217 	+ 	if ( add_preference_to_tm (thisAgent, pref) )
	1218 	+ 	{
	1219 	+ 	/* REW: begin 09.15.96 */
	1220 	+ 	/* No knowledge retrieval necessary in Operand2 */
	1221 	+ 	/* REW: end 09.15.96 */
1218 	1222 		
1219 	1223 		
1220 		- 	/* REW: begin 09.15.96 */
1221 		- 	/* No knowledge retrieval necessary in Operand2 */
1222 		- 	/* REW: end 09.15.96 */
1223 		- 	
1224 		- 	
1225 		- 	if ( wma_enabled( thisAgent ) )
	1224 	+ 	if ( wma_enabled( thisAgent ) )
	1225 	+ 	{
	1226 	+ 	wma_activate_wmes_in_pref( thisAgent, pref );
	1227 	+ 	}
	1228 	+ 	}
	1229 	+ 	else
1226 	1230 		{
1227 		- 	wma_activate_wmes_in_pref( thisAgent, pref );
	1231 	+ 	// NLD: the preference was o-supported, at
	1232 	+ 	// the top state, and was asserting an acceptable
	1233 	+ 	// preference for a WME that was already
	1234 	+ 	// o-supported. hence unnecessary.
	1235 	+ 	
	1236 	+ 	preference_add_ref( pref );
	1237 	+ 	preference_remove_ref( thisAgent, pref );
1228 	1238 		}
1229 	1239 		}
1230 	1240 		else
... 	

###############################################################################
# symtab.cpp
###############################################################################

################
# these changes made in SemanticMemorySymbols.java

... 			
757 	757 		
758 	758 		thisAgent->smem_sym_retrieve = make_sym_constant( thisAgent, "retrieve" );
759 	759 		thisAgent->smem_sym_query = make_sym_constant( thisAgent, "query" );
	760 	+ 	thisAgent->smem_sym_negquery = make_sym_constant( thisAgent, "neg-query" );
760 	761 		thisAgent->smem_sym_prohibit = make_sym_constant( thisAgent, "prohibit" );
761 	762 		thisAgent->smem_sym_store = make_sym_constant( thisAgent, "store" );
762 	763 		}
... 			
864 	865 		
865 	866 		release_helper( thisAgent, &( thisAgent->smem_sym_retrieve ) );
866 	867 		release_helper( thisAgent, &( thisAgent->smem_sym_query ) );
	868 	+ 	release_helper( thisAgent, &( thisAgent->smem_sym_negquery ) );
867 	869 		release_helper( thisAgent, &( thisAgent->smem_sym_prohibit ) );
868 	870 		release_helper( thisAgent, &( thisAgent->smem_sym_store ) );
869 	871 		}
... 	