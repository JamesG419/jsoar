diff from csoar revision 13602
see issue 84 on github

################################################################################
# changes to learn command
# this is implemented differently in jsoar, so don't take these changes literally
# rather, figure out how to get the same effect in jsoar's implementation

Modify	/trunk/SoarSuite/Core/CLI/src/cli_Cli.h	diff
... 			
218 	218 		LEARN_ONLY,
219 	219 		LEARN_ENABLE_THROUGH_LOCAL_NEGATIONS,
220 	220 		LEARN_DISABLE_THROUGH_LOCAL_NEGATIONS,
      221 	+ 	LEARN_ENABLE_THROUGH_EVALUATION_RULES,
      222 	+ 	LEARN_DISABLE_THROUGH_EVALUATION_RULES,
221 	223 		LEARN_NUM_OPTIONS, // must be last
222 	224 		};
223 	225 		typedef std::bitset<LEARN_NUM_OPTIONS> LearnBitset;
...

Modify	/trunk/SoarSuite/Core/CLI/src/cli_Commands.h	diff
... 			
1293 	1293 		{'o', "only", OPTARG_NONE},
1294 	1294 		{'n', "enable-through-local-negations", OPTARG_NONE},
1295 	1295 		{'N', "disable-through-local-negations", OPTARG_NONE},
      1296 	+ 	{'p', "enable-through-evaluation-rules", OPTARG_NONE},
      1297 	+ 	{'P', "disable-through-evaluation-rules", OPTARG_NONE},
1296 	1298 		{0, 0, OPTARG_NONE}
1297 	1299 		};
1298 	1300 		
... 			
1330 	1332 		case 'N':
1331 	1333 		options.set(Cli::LEARN_DISABLE_THROUGH_LOCAL_NEGATIONS);
1332 	1334 		break;
      1335 	+ 	case 'p':
      1336 	+ 	options.set(Cli::LEARN_ENABLE_THROUGH_EVALUATION_RULES);
      1337 	+ 	break;
      1338 	+ 	case 'P':
      1339 	+ 	options.set(Cli::LEARN_DISABLE_THROUGH_EVALUATION_RULES);
      1340 	+ 	break;
1333 	1341 		}
1334 	1342 		}
1335 	1343 		
...

Modify	/trunk/SoarSuite/Core/CLI/src/cli_learn.cpp	diff
... 			
60 	60 		} else {
61 	61 		m_Result << " (not through-local-negations)";
62 	62 		}
63 		- 	
64 	63 		} else {
65 	64 		m_Result << "Learning is disabled.";
66 	65 		}
		66 	+ 	if (agnt->sysparams[CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM]) {
		67 	+ 	m_Result << " (will backtrace through evaluation rules)";
		68 	+ 	} else {
		69 	+ 	m_Result << " (will not backtrace through evaluation rules)";
		70 	+ 	}
67 	71 		} else {
68 	72 		AppendArgTagFast(sml_Names::kParamLearnSetting, sml_Names::kTypeBoolean, agnt->sysparams[LEARNING_ON_SYSPARAM] ? sml_Names::kTrue : sml_Names::kFalse);
69 	73 		AppendArgTagFast(sml_Names::kParamLearnOnlySetting, sml_Names::kTypeBoolean, agnt->sysparams[LEARNING_ONLY_SYSPARAM] ? sml_Names::kTrue : sml_Names::kFalse);
... 			
96 	100 		set_sysparam(agnt, LEARNING_ON_SYSPARAM, true);
97 	101 		set_sysparam(agnt, LEARNING_ONLY_SYSPARAM, true);
98 	102 		set_sysparam(agnt, LEARNING_EXCEPT_SYSPARAM, false);
		103 	+ 	if (m_RawOutput) {
		104 	+ 	m_Result << "\nWill learn only in certain states.";
		105 	+ 	}
99 	106 		}
100 	107 		
101 	108 		if (options.test(LEARN_EXCEPT)) {
102 	109 		set_sysparam(agnt, LEARNING_ON_SYSPARAM, true);
103 	110 		set_sysparam(agnt, LEARNING_ONLY_SYSPARAM, false);
104 	111 		set_sysparam(agnt, LEARNING_EXCEPT_SYSPARAM, true);
		112 	+ 	if (m_RawOutput) {
		113 	+ 	m_Result << "\nWill learn everywhere except certain states.";
		114 	+ 	}
105 	115 		}
106 	116 		
107 	117 		if (options.test(LEARN_ENABLE)) {
108 	118 		set_sysparam(agnt, LEARNING_ON_SYSPARAM, true);
109 	119 		set_sysparam(agnt, LEARNING_ONLY_SYSPARAM, false);
110 	120 		set_sysparam(agnt, LEARNING_EXCEPT_SYSPARAM, false);
		121 	+ 	if (m_RawOutput) {
		122 	+ 	m_Result << "\nLearning on.";
		123 	+ 	}
111 	124 		}
112 	125 		
113 	126 		if (options.test(LEARN_DISABLE)) {
114 	127 		set_sysparam(agnt, LEARNING_ON_SYSPARAM, false);
115 	128 		set_sysparam(agnt, LEARNING_ONLY_SYSPARAM, false);
116 	129 		set_sysparam(agnt, LEARNING_EXCEPT_SYSPARAM, false);
		130 	+ 	if (m_RawOutput) {
		131 	+ 	m_Result << "\nLearning off.";
		132 	+ 	}
117 	133 		}
118 	134 		
119 	135 		if (options.test(LEARN_ALL_LEVELS)) {
120 	136 		set_sysparam(agnt, LEARNING_ALL_GOALS_SYSPARAM, true);
		137 	+ 	if (m_RawOutput) {
		138 	+ 	m_Result << "\nWill learn for all goals.";
		139 	+ 	}
121 	140 		}
122 	141 		
123 	142 		if (options.test(LEARN_BOTTOM_UP)) {
124 	143 		set_sysparam(agnt, LEARNING_ALL_GOALS_SYSPARAM, false);
		144 	+ 	if (m_RawOutput) {
		145 	+ 	m_Result << "\nWill learn from the bottom up.";
		146 	+ 	}
125 	147 		}
126 	148 		
127 	149 		if (options.test(LEARN_ENABLE_THROUGH_LOCAL_NEGATIONS)) {
128 	150 		set_sysparam(agnt, CHUNK_THROUGH_LOCAL_NEGATIONS_SYSPARAM, true);
		151 	+ 	if (m_RawOutput) {
		152 	+ 	m_Result << "\nWill chunk through local negations.";
		153 	+ 	}
129 	154 		}
130 	155 		
131 	156 		if (options.test(LEARN_DISABLE_THROUGH_LOCAL_NEGATIONS)) {
132 	157 		set_sysparam(agnt, CHUNK_THROUGH_LOCAL_NEGATIONS_SYSPARAM, false);
		158 	+ 	if (m_RawOutput) {
		159 	+ 	m_Result << "\nWill not chunk through local negations.";
		160 	+ 	}
		161 	+ 	}
		162 	+ 	
		163 	+ 	if (options.test(LEARN_ENABLE_THROUGH_EVALUATION_RULES)) {
		164 	+ 	set_sysparam(agnt, CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM, true);
		165 	+ 	if (m_RawOutput) {
		166 	+ 	m_Result << "\nWill include evaluation rules when backtracing.";
		167 	+ 	}
		168 	+ 	}
		169 	+ 	
		170 	+ 	if (options.test(LEARN_DISABLE_THROUGH_EVALUATION_RULES)) {
		171 	+ 	set_sysparam(agnt, CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM, false);
		172 	+ 	if (m_RawOutput) {
		173 	+ 	m_Result << "\nWill not include evaluation rules when backtracing.";
		174 	+ 	}
133 	175 		}
134 	176 		
135 	177 		return true;
... 		

# soar_ecPrintPreferences()
Modify	/trunk/SoarSuite/Core/CLI/src/cli_preferences.cpp	diff
... 			
275 	275 		// run preference semantics "read only" via _consistency_check
276 	276 		// returns a list of candidates without deciding which one in the event of indifference
277 	277 		preference* cand = 0;
278 		- 	byte impasse_type = run_preference_semantics_for_consistency_check(soarAgent, s, &cand);
		278 	+ 	byte impasse_type = run_preference_semantics(soarAgent, s, &cand, true);
279 	279 		
280 	280 		// if the impasse isn't NONE_IMPASSE_TYPE, there's an impasse and we don't want to print anything
281 	281 		// if we have no candidates, we don't want to print anything
... 			

################################################################################
# backtrace stuff

Modify	/trunk/SoarSuite/Core/SoarKernel/src/backtrace.cpp	diff
# backtrace_through_instantiation()
... 			
312 	312 		for (c=inst->top_of_instantiated_conditions; c!=NIL; c=c->next) {
313 	313 		if (c->type==POSITIVE_CONDITION) {
314 	314 		
315 		- 	/* REW: begin 11.22.97 */
316 		- 	/* print (thisAgent, "\n Checking...");print_wme(c->bt.wme_);
317 		- 	if (c->bt.trace) print ("c->bt.trace exists..."); else print("\n no c->bt.trace...");
318 		- 	if (c->bt.wme_) {
319 		- 	print ("c->bt.wme_....");
320 		- 	if (c->bt.wme_->preference)
321 		- 	print("c->bt.wme_->preference");
322 		- 	else
323 		- 	print("\n no c->bt.wme_->preference");
324 		- 	} else
325 		- 	print ("\nNo WME No Preference!!!!!!");
326 		- 	print("\n");
327 		- 	if ((c->bt.trace) && (c->bt.wme_->preference)){
328 		- 	if (c->bt.trace != c->bt.wme_->preference) {
329 		- 	print("\n bt.trace and WME preferences not equal:\n");
330 		- 	print(thisAgent, "\nWME:"); print_wme(c->bt.wme_);
331 		- 	print("\n bt.trace:");
332 		- 	if (c->bt.trace) print_preference(c->bt.trace); else print(" NIL\n");
333 		- 	print("\n bt.wme_->preference:");
334 		- 	if (c->bt.wme_->preference) print_preference(c->bt.wme_->preference);
335 		- 	else print(" NIL\n");
336 		- 	c->bt.trace = c->bt.wme_->preference;
337 		- 	c->bt.level = c->bt.wme_->id->id.level;
338 		- 	}
339 		- 	}*/
340 		- 	/* REW: end 11.22.97 */
341 	315 		/* --- positive cond's are grounds, potentials, or locals --- */
342 	316 		if (referent_of_equality_test(c->data.tests.id_test)->id.tc_num == tc) {
343 	317 		add_to_grounds (thisAgent, c);
...

# trace_locals() 			
444 	418 		void trace_locals (agent* thisAgent, goal_stack_level grounds_level, bool *reliable) {
445 	419 		
446 	420 		/* mvp 5-17-94 */
447 		- 	cons *c, *prohibits;
		421 	+ 	cons *c, *CDPS;
448 	422 		condition *cond;
449 	423 		preference *bt_pref, *p;
450 	424 		
... 			
471 	445 		/* --- if it has a trace at this level, backtrace through it --- */
472 	446 		if (bt_pref) {
473 	447 		
474 		- 	/* mvp 5-17-94 */
475 	448 		backtrace_through_instantiation (thisAgent, bt_pref->inst, grounds_level,cond, reliable, 0);
476 	449 		
477 		- 	/* check if any prohibit preferences */
478 		- 	if (cond->bt.prohibits) {
479 		- 	for (prohibits=cond->bt.prohibits; prohibits!=NIL; prohibits=prohibits->rest) {
480 		- 	p = static_cast<preference_struct *>(prohibits->first);
		450 	+ 	/* MMA 8-2012: Check for any CDPS prefs and backtrace through them */
		451 	+ 	if (cond->bt.CDPS) {
		452 	+ 	for (CDPS=cond->bt.CDPS; CDPS!=NIL; CDPS=CDPS->rest) {
		453 	+ 	p = static_cast<preference_struct *>(CDPS->first);
481 	454 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
482 		- 	print_string (thisAgent, " For prohibit preference: ");
483 		- 	xml_begin_tag(thisAgent, kTagProhibitPreference);
		455 	+ 	print_string (thisAgent, " Backtracing through CDPS preference: ");
		456 	+ 	xml_begin_tag(thisAgent, kTagCDPSPreference);
484 	457 		print_preference (thisAgent, p);
485 	458 		}
486 	459 		backtrace_through_instantiation (thisAgent, p->inst, grounds_level, cond, reliable, 6);
487 	460 		
488 	461 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
489 		- 	xml_end_tag(thisAgent, kTagProhibitPreference);
		462 	+ 	xml_end_tag(thisAgent, kTagCDPSPreference);
490 	463 		}
491 	464 		}
492 	465 		}
493 		- 	/* mvp done */
		466 	+ 	/* MMA 8-2012 end */
		467 	+ 	
494 	468 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
495 	469 		xml_end_tag(thisAgent, kTagLocal);
496 	470 		}
... 			

# trace_ungrounded_potentials()
610 	584 		Bool trace_ungrounded_potentials (agent* thisAgent, goal_stack_level grounds_level, bool *reliable) {
611 	585 		
612 	586 		/* mvp 5-17-94 */
613 		- 	cons *c, *next_c, *prev_c, *prohibits;
		587 	+ 	cons *c, *next_c, *prev_c, *CDPS;
614 	588 		cons *pots_to_bt;
615 	589 		condition *potential;
616 	590 		preference *bt_pref, *p;
... 			
660 	634 		bt_pref = find_clone_for_level (potential->bt.trace,
661 	635 		static_cast<goal_stack_level>(grounds_level+1));
662 	636 		
663 		- 	/* mvp 5-17-94 */
664 	637 		backtrace_through_instantiation (thisAgent, bt_pref->inst, grounds_level,potential, reliable, 0);
665 		- 	if (potential->bt.prohibits) {
666 		- 	for (prohibits=potential->bt.prohibits; prohibits!=NIL; prohibits=prohibits->rest) {
667 		- 	p = static_cast<preference_struct *>(prohibits->first);
		638 	+ 	
		639 	+ 	/* MMA 8-2012: now backtrace through CDPS of potentials */
		640 	+ 	if (potential->bt.CDPS) {
		641 	+ 	for (CDPS=potential->bt.CDPS; CDPS!=NIL; CDPS=CDPS->rest) {
		642 	+ 	p = static_cast<preference_struct *>(CDPS->first);
668 	643 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
669 		- 	print_string (thisAgent, " For prohibit preference: ");
670 		- 	xml_begin_tag(thisAgent, kTagProhibitPreference);
		644 	+ 	print_string (thisAgent, " Backtracing through CDPS preference: ");
		645 	+ 	xml_begin_tag(thisAgent, kTagCDPSPreference);
671 	646 		print_preference (thisAgent, p);
672 	647 		}
673 	648 		backtrace_through_instantiation (thisAgent, p->inst, grounds_level, potential, reliable, 6);
674 	649 		
675 	650 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
676 		- 	xml_end_tag(thisAgent, kTagProhibitPreference);
		651 	+ 	xml_end_tag(thisAgent, kTagCDPSPreference);
677 	652 		}
678 	653 		}
679 	654 		}
680 		- 	/* mvp done */
		655 	+ 	/* MMA end */
		656 	+ 	
681 	657 		if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM]) {
682 	658 		xml_end_tag(thisAgent, kTagUngroundedPotential);
683 	659 		}
... 		

################################################################################
# consistency stuff

Modify	/trunk/SoarSuite/Core/SoarKernel/src/consistency.cpp	diff
... 			
181 	181 		}
182 	182 		
183 	183 		/* Determine the new impasse type, based on the preferences that exist now */
184 		- 	new_impasse_type = run_preference_semantics_for_consistency_check (thisAgent, s, &candidates);
	184 	+ 	new_impasse_type = run_preference_semantics(thisAgent, s, &candidates, true);
185 	185 		
186 	186 		#ifdef DEBUG_CONSISTENCY_CHECK
187 	187 		printf(" Impasse Type returned by run preference semantics: %d\n", new_impasse_type);
... 		


################################################################################
# deicde stuff

Modify	/trunk/SoarSuite/Core/SoarKernel/src/decide.cpp	diff
... 			
# this should be part of an enum in jsoar
140 	140 		#define WORST_DECIDER_FLAG 5
141 	141 		#define UNARY_INDIFFERENT_DECIDER_FLAG 6
142 	142 		#define ALREADY_EXISTING_WME_DECIDER_FLAG 7
143 		- 	#define UNARY_PARALLEL_DECIDER_FLAG 8
	143 	+ 	
144 	144 		/* REW: 2003-01-02 Behavior Variability Kernel Experiments
145 	145 		A new preference type: unary indifferent + constant (probability) value
146 	146 		*/
147 		- 	#define UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG 9
	147 	+ 	#define UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG 8
148 	148 		
149 	149 		/* ======================================================================
150 	150 	
# typo fix, may already be fixed in jsoar	
... 			
826 	826 		/* ------------------------------------------------------------------
827 	827 		Do Buffered Link Changes
828 	828 		
829 		- 	This routine does all the buffered link (ownership) chages, updating
	829 	+ 	This routine does all the buffered link (ownership) changes, updating
830 	830 		the goal stack level on all identifiers and garbage collecting
831 	831 		disconnected wmes.
832 	832 		------------------------------------------------------------------ */
... 		

# new function: add_to_CDPS()
859 	859 		#endif
860 	860 		#endif
861 	861 		}
	862 	+ 	
	863 	+ 	/* ------------------------------------------------------------------
	864 	+ 	Add a preference to a slot's CDPS
	865 	+ 	This function adds a preference to a slots's context dependent
	866 	+ 	preference set, checking to first see whether the pref is already
	867 	+ 	there. If an operator The slot's CDPS is copied to conditions' bt structs in
	868 	+ 	create_instatiation. Those copies of the CDPS are used to
	869 	+ 	backtrace through all relevant local evaluation rules that led to the
	870 	+ 	selection of the operator that produced a result.
	871 	+ 	------------------------------------------------------------------ */
	872 	+ 	
	873 	+ 	void add_to_CDPS(agent* thisAgent, slot *s, preference *pref, bool unique_value) {
	874 	+ 	
	875 	+ 	Bool already_exists=false;
	876 	+ 	cons *CDPS;
	877 	+ 	preference *p;
	878 	+ 	
	879 	+ 	for (CDPS=s->CDPS; CDPS!=NIL; CDPS=CDPS->rest) {
	880 	+ 	p = static_cast<preference *>(CDPS->first);
	881 	+ 	if (p == pref) {
	882 	+ 	already_exists=true;
	883 	+ 	break;
	884 	+ 	}
	885 	+ 	
	886 	+ 	if (unique_value) {
	887 	+ 	/* Checking if a preference is unique differs depending on the preference type */
	888 	+ 	
	889 	+ 	/* Binary preferences can be considered equivalent if they point to the same
	890 	+ 	* operators in the correct relative spots */
	891 	+ 	if (((pref->type == BETTER_PREFERENCE_TYPE) || (pref->type == WORSE_PREFERENCE_TYPE)) &&
	892 	+ 	((p->type == BETTER_PREFERENCE_TYPE) || (p->type == WORSE_PREFERENCE_TYPE))) {
	893 	+ 	if (pref->type == p->type)
	894 	+ 	already_exists = ((pref->value == p->value) && (pref->referent == p->referent));
	895 	+ 	else
	896 	+ 	already_exists = ((pref->value == p->referent) && (pref->referent == p->value));
	897 	+ 	} else if ((pref->type == BINARY_INDIFFERENT_PREFERENCE_TYPE) &&
	898 	+ 	(p->type == BINARY_INDIFFERENT_PREFERENCE_TYPE)) {
	899 	+ 	already_exists = (((pref->value == p->value) && (pref->referent == p->referent)) ||
	900 	+ 	((pref->value == p->referent) && (pref->referent == p->value)));
	901 	+ 	} else {
	902 	+ 	/* Otherwise they are equivalent if they have the same value and type */
	903 	+ 	already_exists = (pref->value == p->value) && (pref->type == p->type);
	904 	+ 	}
	905 	+ 	if (already_exists) {
	906 	+ 	break;
	907 	+ 	}
	908 	+ 	}
	909 	+ 	}
	910 	+ 	if (!already_exists) {
	911 	+ 	push(thisAgent, pref, s->CDPS);
	912 	+ 	preference_add_ref(pref);
	913 	+ 	}
	914 	+ 	}
	915 	+ 	
	916 	+ 	/* Perform reinforcement learning update for one valid candidate. */
	917 	+ 	
	918 	+ 	void rl_update_for_one_candidate(agent* thisAgent, slot *s, bool consistency, preference *candidates) {
	919 	+ 	
	920 	+ 	if (!consistency && rl_enabled(thisAgent)) {
	921 	+ 	rl_tabulate_reward_values(thisAgent);
	922 	+ 	exploration_compute_value_of_candidate(thisAgent, candidates, s, 0);
	923 	+ 	rl_perform_update(thisAgent, candidates->numeric_value,
	924 	+ 	candidates->rl_contribution, s->id);
	925 	+ 	}
	926 	+ 	}
862 	927 		
863 	928 		/* **************************************************************************
864 	929

# typo fixes and removal of obsolete comment
865 		- 	Preference Semantics
	930 	+ 	Run Preference Semantics
866 	931 		
867 	932 		Run_preference_semantics (slot *s, preference **result_candidates) examines
868 		- 	the preferences for a given slot, and returns an impasse type for the
	933 	+ 	the preferences for a given slot, and returns an impasse type for thez
869 	934 		slot. The argument "result_candidates" is set to a list of candidate
870 	935 		values for the slot--if the returned impasse type is NONE_IMPASSE_TYPE,
871 	936 		this is the set of winners; otherwise it is the set of tied, conflicted,
872 		- 	or constraint-failured values. This list of values is a list of preferences
	937 	+ 	or constraint-failure values. This list of values is a list of preferences
873 	938 		for those values, linked via the "next_candidate" field on each preference
874 	939 		structure. If there is more than one preference for a given value,
875 	940 		only one is returned in the result_candidates, with (first) require
... 			
884 	949 		afterwards (i.e., before the next time the slot is re-decided, I think),
885 	950 		we would be left with a WME still in WM (not GC'd, because of the acceptable
886 	951 		preference higher up) but with a trace pointing to a deallocated require
887 		- 	preference. This case is very obsure and unlikely to come up, but it
	952 	+ 	preference. This case is very obscure and unlikely to come up, but it
888 	953 		could easily cause a core dump or worse.
889 	954 		
890 		- 	Require_preference_semantics() is a helper function for
891 		- 	run_preference_semantics() that is used when there is at least one
892 		- 	require preference for the slot.
893 	955 		************************************************************************** */
894 	956 		

# this diff is confusing, but the essence is that:
#  require_preference_semantics() is removed
#  run_preference_semantics_for_consistency_check() is removed
#  run_preference_semantics() is modified
# it may be easier to diff the current and old version of run_preference_semantics() than to follow this diff

895 		- 	byte require_preference_semantics (agent *thisAgent, slot *s, preference **result_candidates, bool consistency) {
896 		- 	preference *p;
	957 	+ 	byte run_preference_semantics(agent* thisAgent,
	958 	+ 	slot *s,
	959 	+ 	preference **result_candidates,
	960 	+ 	bool consistency,
	961 	+ 	bool predict)
	962 	+ 	{
	963 	+ 	preference *p, *p2, *cand, *prev_cand;
	964 	+ 	Bool match_found, not_all_indifferent, some_numeric, do_CDPS;
897 	965 		preference *candidates;
898 	966 		Symbol *value;
	967 	+ 	cons *CDPS, *prev_cons;
899 	968 		
900 		- 	/* --- collect set of required items into candidates list --- */
901 		- 	for (p=s->preferences[REQUIRE_PREFERENCE_TYPE]; p!=NIL; p=p->next)
	969 	+ 	/* Set a flag to determine if a context-dependent preference set makes sense in this context.
	970 	+ 	* We can ignore the CDPS when:
	971 	+ 	* - Run_preference_semantics is called for a consistency check (don't want side effects)
	972 	+ 	* - For non-context slots (only makes sense for operators)
	973 	+ 	* - For context-slots at the top level (will never be backtraced through)
	974 	+ 	* - when the learning system parameter is set off (note, this is independent of whether learning is on) */
	975 	+ 	
	976 	+ 	do_CDPS = (s->isa_context_slot && !consistency && (s->id->id.level > TOP_GOAL_LEVEL) && thisAgent->sysparams[CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM]);
	977 	+ 	
	978 	+ 	/* Empty the context-dependent preference set in the slot */
	979 	+ 	
	980 	+ 	if (do_CDPS && s->CDPS) {
	981 	+ 	clear_CDPS(thisAgent, s);
	982 	+ 	}
	983 	+ 	
	984 	+ 	/* If the slot has no preferences at all, things are trivial --- */
	985 	+ 	
	986 	+ 	if (!s->all_preferences) {
	987 	+ 	if (!s->isa_context_slot)
	988 	+ 	mark_slot_for_possible_removal(thisAgent, s);
	989 	+ 	*result_candidates = NIL;
	990 	+ 	return NONE_IMPASSE_TYPE;
	991 	+ 	}
	992 	+ 	
	993 	+ 	/* If this is the true decision slot and selection has been made, attempt force selection */
	994 	+ 	
	995 	+ 	if (s->isa_context_slot && !consistency) {
	996 	+ 	if (select_get_operator(thisAgent) != NULL) {
	997 	+ 	preference *force_result = select_force(thisAgent,
	998 	+ 	s->preferences[ACCEPTABLE_PREFERENCE_TYPE], !predict);
	999 	+ 	
	1000 	+ 	if (force_result) {
	1001 	+ 	force_result->next_candidate = NIL;
	1002 	+ 	*result_candidates = force_result;
	1003 	+ 	
	1004 	+ 	if (!predict && rl_enabled(thisAgent)) {
	1005 	+ 	rl_tabulate_reward_values(thisAgent);
	1006 	+ 	exploration_compute_value_of_candidate(thisAgent, force_result, s, 0);
	1007 	+ 	rl_perform_update(thisAgent, force_result->numeric_value,
	1008 	+ 	force_result->rl_contribution, s->id);
	1009 	+ 	}
	1010 	+ 	
	1011 	+ 	return NONE_IMPASSE_TYPE;
	1012 	+ 	}
	1013 	+ 	}
	1014 	+ 	}
	1015 	+ 	
	1016 	+ 	/* If debugging a context-slot, print all preferences that we're deciding through */
	1017 	+ 	
	1018 	+ 	if (thisAgent->sysparams[TRACE_BACKTRACING_SYSPARAM] && s->isa_context_slot) {
	1019 	+ 	
	1020 	+ 	print(thisAgent,
	1021 	+ 	"\n----------------------------\nRUNNING PREFERENCE SEMANTICS...\n----------------------------\n");
	1022 	+ 	print(thisAgent, "All Preferences for slot:");
	1023 	+ 	
	1024 	+ 	for (int i = 0; i < NUM_PREFERENCE_TYPES; i++) {
	1025 	+ 	if (s->preferences[i]) {
	1026 	+ 	print(thisAgent, "\n %ss:\n", preference_name[i]);
	1027 	+ 	for (p = s->preferences[i]; p; p = p->next) {
	1028 	+ 	print(thisAgent, " ");
	1029 	+ 	print_preference(thisAgent, p);
	1030 	+ 	}
	1031 	+ 	}
	1032 	+ 	}
	1033 	+ 	}
	1034 	+ 	
	1035 	+ 	/* === Requires === */
	1036 	+ 	
	1037 	+ 	if (s->preferences[REQUIRE_PREFERENCE_TYPE]) {
	1038 	+ 	
	1039 	+ 	/* Collect set of required items into candidates list */
	1040 	+ 	
	1041 	+ 	for (p=s->preferences[REQUIRE_PREFERENCE_TYPE]; p!=NIL; p=p->next)
	1042 	+ 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1043 	+ 	candidates = NIL;
	1044 	+ 	for (p=s->preferences[REQUIRE_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
	1045 	+ 	if (p->value->common.decider_flag == NOTHING_DECIDER_FLAG) {
	1046 	+ 	p->next_candidate = candidates;
	1047 	+ 	candidates = p;
	1048 	+ 	/* Unmark it, in order to prevent it from being added twice */
	1049 	+ 	p->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
	1050 	+ 	}
	1051 	+ 	}
	1052 	+ 	*result_candidates = candidates;
	1053 	+ 	
	1054 	+ 	/* Check if we have more than one required item. If so, return constraint failure. */
	1055 	+ 	
	1056 	+ 	if (candidates->next_candidate)
	1057 	+ 	return CONSTRAINT_FAILURE_IMPASSE_TYPE;
	1058 	+ 	
	1059 	+ 	/* Check if we have also have a prohibit preference. If so, return constraint failure.
	1060 	+ 	* Note that this is the one difference between prohibit and reject preferences. */
	1061 	+ 	
	1062 	+ 	value = candidates->value;
	1063 	+ 	for (p=s->preferences[PROHIBIT_PREFERENCE_TYPE]; p!=NIL; p=p->next)
	1064 	+ 	if (p->value == value) return CONSTRAINT_FAILURE_IMPASSE_TYPE;
	1065 	+ 	
	1066 	+ 	/* --- We have a winner, so update RL --- */
	1067 	+ 	
	1068 	+ 	rl_update_for_one_candidate(thisAgent, s, consistency, candidates);
	1069 	+ 	
	1070 	+ 	return NONE_IMPASSE_TYPE;
	1071 	+ 	}
	1072 	+ 	
	1073 	+ 	/* === Acceptables, Prohibits, Rejects === */
	1074 	+ 	
	1075 	+ 	/* Mark every acceptable preference as a possible candidate */
	1076 	+ 	
	1077 	+ 	for (p = s->preferences[ACCEPTABLE_PREFERENCE_TYPE]; p != NIL; p = p->next)
	1078 	+ 	p->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
	1079 	+ 	
	1080 	+ 	/* Unmark any preferences that have a prohibit or reject. Note that this may
	1081 	+ 	* remove the candidate_decider_flag set in the last loop */
	1082 	+ 	
	1083 	+ 	for (p = s->preferences[PROHIBIT_PREFERENCE_TYPE]; p != NIL; p = p->next)
902 	1084 		p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1085 	+ 	for (p = s->preferences[REJECT_PREFERENCE_TYPE]; p != NIL; p = p->next)
	1086 	+ 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1087 	+ 	
	1088 	+ 	/* Build list of candidates. These are the acceptable prefs that didn't
	1089 	+ 	* have the CANDIDATE_DECIDER_FLAG reversed by prohibit or reject prefs. */
	1090 	+ 	
903 	1091 		candidates = NIL;
904 		- 	for (p=s->preferences[REQUIRE_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
905 		- 	if (p->value->common.decider_flag == NOTHING_DECIDER_FLAG) {
	1092 	+ 	for (p = s->preferences[ACCEPTABLE_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1093 	+ 	if (p->value->common.decider_flag == CANDIDATE_DECIDER_FLAG) {
906 	1094 		p->next_candidate = candidates;
907 	1095 		candidates = p;
908 		- 	/* --- unmark it, in order to prevent it from being added twice --- */
909 		- 	p->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
	1096 	+ 	/* --- Unmark it, in order to prevent it from being added twice --- */
	1097 	+ 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
910 	1098 		}
911 	1099 		}
912 		- 	*result_candidates = candidates;
913 	1100 		
914 		- 	/* --- if more than one required item, we have a constraint failure --- */
915 		- 	if (candidates->next_candidate) return CONSTRAINT_FAILURE_IMPASSE_TYPE;
	1101 	+ 	/* If this is not a decidable context slot, then we're done */
916 	1102 		
917 		- 	/* --- just one require, check for require-prohibit impasse --- */
918 		- 	value = candidates->value;
919 		- 	for (p=s->preferences[PROHIBIT_PREFERENCE_TYPE]; p!=NIL; p=p->next)
920 		- 	if (p->value == value) return CONSTRAINT_FAILURE_IMPASSE_TYPE;
	1103 	+ 	if (!s->isa_context_slot) {
	1104 	+ 	*result_candidates = candidates;
	1105 	+ 	return NONE_IMPASSE_TYPE;
	1106 	+ 	}
921 	1107 		
922 		- 	/* --- the lone require is the winner --- */
923 		- 	if ( !consistency && candidates && rl_enabled( thisAgent ) )
924 		- 	{
925 		- 	rl_tabulate_reward_values( thisAgent );
926 		- 	exploration_compute_value_of_candidate( thisAgent, candidates, s, 0 );
927 		- 	rl_perform_update( thisAgent, candidates->numeric_value, candidates->rl_contribution, s->id );
	1108 	+ 	/* If there are reject or prohibit preferences,
	1109 	+ 	* (1) add all acceptable preferences to CDPS except those with a reject or prohibit
	1110 	+ 	* which is equivalent to the entire candidate list at this point
	1111 	+ 	* (2) add all reject and prohibit preferences */
	1112 	+ 	
	1113 	+ 	if (do_CDPS) {
	1114 	+ 	if (s->preferences[PROHIBIT_PREFERENCE_TYPE] || s->preferences[REJECT_PREFERENCE_TYPE]) {
	1115 	+ 	for (p = s->preferences[PROHIBIT_PREFERENCE_TYPE]; p != NIL; p = p->next)
	1116 	+ 	add_to_CDPS(thisAgent, s, p);
	1117 	+ 	for (p = s->preferences[REJECT_PREFERENCE_TYPE]; p != NIL; p = p->next)
	1118 	+ 	add_to_CDPS(thisAgent, s, p);
	1119 	+ 	for (p = candidates; p != NIL; p = p->next_candidate) {
	1120 	+ 	add_to_CDPS(thisAgent, s, p);
	1121 	+ 	}
	1122 	+ 	}
928 	1123 		}
929 	1124 		
930 		- 	return NONE_IMPASSE_TYPE;
931 		- 	}
	1125 	+ 	/* Exit point 1: Check if we're done, i.e. 0 or 1 candidates left */
	1126 	+ 	if ((!candidates) || (!candidates->next_candidate)) {
	1127 	+ 	*result_candidates = candidates;
	1128 	+ 	if (candidates) {
	1129 	+ 	/* Update RL values for the winning candidate */
	1130 	+ 	rl_update_for_one_candidate(thisAgent, s, consistency, candidates);
	1131 	+ 	} else {
	1132 	+ 	if (do_CDPS && s->CDPS) {
	1133 	+ 	clear_CDPS(thisAgent, s);
	1134 	+ 	}
	1135 	+ 	}
	1136 	+ 	return NONE_IMPASSE_TYPE;
	1137 	+ 	}
932 	1138 		
933 		- 	byte run_preference_semantics (agent* thisAgent, slot *s, preference **result_candidates, bool consistency = false, bool predict = false)
934 		- 	{
935 		- 	preference *p, *p2, *cand, *prev_cand;
936 		- 	Bool match_found, not_all_indifferent, not_all_parallel;
937 		- 	preference *candidates;
	1139 	+ 	/* === Better/Worse === */
938 	1140 		
939 		- 	/* --- if the slot has no preferences at all, things are trivial --- */
940 		- 	if (!s->all_preferences)
941 		- 	{
942 		- 	if (! s->isa_context_slot) mark_slot_for_possible_removal (thisAgent, s);
943 		- 	*result_candidates = NIL;
944 		- 	return NONE_IMPASSE_TYPE;
945 		- 	}
	1141 	+ 	if (s->preferences[BETTER_PREFERENCE_TYPE]
	1142 	+ 	|| s->preferences[WORSE_PREFERENCE_TYPE]) {
	1143 	+ 	Symbol *j, *k;
946 	1144 		
947 		- 	// if this is the true decision slot and selection has been made, attempt force selection
948 		- 	if ( s->isa_context_slot && !consistency)
949 		- 	{
950 		- 	if ( select_get_operator( thisAgent ) != NULL )
951 		- 	{
952 		- 	preference *force_result = select_force( thisAgent, s->preferences[ACCEPTABLE_PREFERENCE_TYPE], !predict );
	1145 	+ 	/* Initialize decider flags */
953 	1146 		
954 		- 	if ( force_result )
955 		- 	{
956 		- 	force_result->next_candidate = NIL;
957 		- 	*result_candidates = force_result;
	1147 	+ 	for (p = s->preferences[BETTER_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1148 	+ 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1149 	+ 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
	1150 	+ 	}
	1151 	+ 	for (p = s->preferences[WORSE_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1152 	+ 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1153 	+ 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
	1154 	+ 	}
	1155 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate) {
	1156 	+ 	cand->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
	1157 	+ 	}
958 	1158 		
959 		- 	if ( !predict && rl_enabled( thisAgent ) )
960 		- 	{
961 		- 	rl_tabulate_reward_values( thisAgent );
962 		- 	exploration_compute_value_of_candidate( thisAgent, force_result, s, 0 );
963 		- 	rl_perform_update( thisAgent, force_result->numeric_value, force_result->rl_contribution, s->id );
964 		- 	}
	1159 	+ 	/* Mark any preferences that are worse than another as conflicted. This
	1160 	+ 	* will either remove it from the candidate list or add it to the conflicted
	1161 	+ 	* list later. We first do this for both the referent half of better and
	1162 	+ 	* then the value half of worse preferences. */
965 	1163 		
966 		- 	return NONE_IMPASSE_TYPE;
967 		- 	}
968 		- 	}
969 		- 	}
	1164 	+ 	for (p = s->preferences[BETTER_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1165 	+ 	j = p->value;
	1166 	+ 	k = p->referent;
	1167 	+ 	if (j == k)
	1168 	+ 	continue;
	1169 	+ 	if (j->common.decider_flag && k->common.decider_flag) {
	1170 	+ 	if (j->common.decider_flag == CANDIDATE_DECIDER_FLAG
	1171 	+ 	|| k->common.decider_flag == CANDIDATE_DECIDER_FLAG) {
	1172 	+ 	k->common.decider_flag = CONFLICTED_DECIDER_FLAG;
	1173 	+ 	}
	1174 	+ 	}
	1175 	+ 	}
970 	1176 		
971 		- 	/* === Requires === */
972 		- 	if (s->preferences[REQUIRE_PREFERENCE_TYPE]) {
973 		- 	return require_preference_semantics (thisAgent, s, result_candidates, consistency);
974 		- 	}
	1177 	+ 	for (p = s->preferences[WORSE_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1178 	+ 	j = p->value;
	1179 	+ 	k = p->referent;
	1180 	+ 	if (j == k)
	1181 	+ 	continue;
	1182 	+ 	if (j->common.decider_flag && k->common.decider_flag) {
	1183 	+ 	if (j->common.decider_flag == CANDIDATE_DECIDER_FLAG
	1184 	+ 	|| k->common.decider_flag == CANDIDATE_DECIDER_FLAG) {
	1185 	+ 	j->common.decider_flag = CONFLICTED_DECIDER_FLAG;
	1186 	+ 	}
	1187 	+ 	}
	1188 	+ 	}
975 	1189 		
976 		- 	/* === Acceptables, Prohibits, Rejects === */
	1190 	+ 	/* Check if a valid candidate still exists. */
977 	1191 		
978 		- 	/* --- mark everything that's acceptable, then unmark the prohibited
979 		- 	and rejected items --- */
980 		- 	for (p=s->preferences[ACCEPTABLE_PREFERENCE_TYPE]; p!=NIL; p=p->next)
981 		- 	p->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
982 		- 	for (p=s->preferences[PROHIBIT_PREFERENCE_TYPE]; p!=NIL; p=p->next)
983 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
984 		- 	for (p=s->preferences[REJECT_PREFERENCE_TYPE]; p!=NIL; p=p->next)
985 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
	1192 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate) {
	1193 	+ 	if (cand->value->common.decider_flag == CANDIDATE_DECIDER_FLAG)
	1194 	+ 	break;
	1195 	+ 	}
986 	1196 		
987 		- 	/* --- now scan through acceptables and build the list of candidates --- */
988 		- 	candidates = NIL;
989 		- 	for (p=s->preferences[ACCEPTABLE_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
990 		- 	if (p->value->common.decider_flag == CANDIDATE_DECIDER_FLAG) {
991 		- 	p->next_candidate = candidates;
992 		- 	candidates = p;
993 		- 	/* --- unmark it, in order to prevent it from being added twice --- */
994 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
995 		- 	}
996 		- 	}
	1197 	+ 	/* If no candidates exists, collect conflicted candidates and return as
	1198 	+ 	* the result candidates with a conflict impasse type. */
997 	1199 		
998 		- 	if (!s->isa_context_slot) {
999 		- 	*result_candidates = candidates;
1000 		- 	return NONE_IMPASSE_TYPE;
1001 		- 	}
	1200 	+ 	if (!cand) {
	1201 	+ 	prev_cand = NIL;
	1202 	+ 	cand = candidates;
	1203 	+ 	while (cand) {
	1204 	+ 	if (cand->value->common.decider_flag != CONFLICTED_DECIDER_FLAG) {
	1205 	+ 	if (prev_cand)
	1206 	+ 	prev_cand->next_candidate = cand->next_candidate;
	1207 	+ 	else
	1208 	+ 	candidates = cand->next_candidate;
	1209 	+ 	} else {
	1210 	+ 	prev_cand = cand;
	1211 	+ 	}
	1212 	+ 	cand = cand->next_candidate;
	1213 	+ 	}
	1214 	+ 	*result_candidates = candidates;
	1215 	+ 	if (do_CDPS && s->CDPS) {
	1216 	+ 	clear_CDPS(thisAgent, s);
	1217 	+ 	}
	1218 	+ 	return CONFLICT_IMPASSE_TYPE;
	1219 	+ 	}
1002 	1220 		
1003 		- 	/* === If there are only 0 or 1 candidates, we're done === */
1004 		- 	if ((!candidates) || (! candidates->next_candidate)) {
1005 		- 	*result_candidates = candidates;
	1221 	+ 	/* Otherwise, delete conflicted candidates from candidate list.
	1222 	+ 	* Also add better preferences to CDPS for every item in the candidate
	1223 	+ 	* list and delete acceptable preferences from the CDPS for those that
	1224 	+ 	* don't make the candidate list.*/
1006 	1225 		
1007 		- 	if ( !consistency && rl_enabled( thisAgent ) && candidates )
1008 		- 	{
1009 		- 	// perform update here for just one candidate
1010 		- 	rl_tabulate_reward_values( thisAgent );
1011 		- 	exploration_compute_value_of_candidate( thisAgent, candidates, s, 0 );
1012 		- 	rl_perform_update( thisAgent, candidates->numeric_value, candidates->rl_contribution, s->id );
1013 		- 	}
	1226 	+ 	prev_cand = NIL;
	1227 	+ 	cand = candidates;
	1228 	+ 	while (cand) {
	1229 	+ 	if (cand->value->common.decider_flag == CONFLICTED_DECIDER_FLAG) {
	1230 	+ 	/* Remove this preference from the candidate list */
	1231 	+ 	if (prev_cand)
	1232 	+ 	prev_cand->next_candidate = cand->next_candidate;
	1233 	+ 	else
	1234 	+ 	candidates = cand->next_candidate;
1014 	1235 		
1015 		- 	return NONE_IMPASSE_TYPE;
1016 		- 	}
	1236 	+ 	/* Remove any acceptable preference for the same operator from the CDPS */
	1237 	+ 	if (do_CDPS && s->CDPS) {
	1238 	+ 	prev_cons = NIL;
	1239 	+ 	for (CDPS=s->CDPS; CDPS!=NIL; CDPS=CDPS->rest) {
	1240 	+ 	p = static_cast<preference *>(CDPS->first);
	1241 	+ 	if ((p->value == cand->value) && (p->type == ACCEPTABLE_PREFERENCE_TYPE)) {
	1242 	+ 	if (!prev_cons) {
	1243 	+ 	s->CDPS = CDPS->rest;
	1244 	+ 	} else {
	1245 	+ 	prev_cons->rest = CDPS->rest;
	1246 	+ 	}
	1247 	+ 	free_cons(thisAgent, CDPS);
	1248 	+ 	preference_remove_ref(thisAgent, p);
	1249 	+ 	} else {
	1250 	+ 	prev_cons = CDPS;
	1251 	+ 	}
	1252 	+ 	}
	1253 	+ 	}
	1254 	+ 	} else {
	1255 	+ 	if (do_CDPS) {
	1256 	+ 	/* Add better/worse preference to CDPS */
	1257 	+ 	for (p = s->preferences[BETTER_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1258 	+ 	if (p->value == cand->value) {
	1259 	+ 	add_to_CDPS(thisAgent, s, p);
	1260 	+ 	}
	1261 	+ 	}
	1262 	+ 	for (p = s->preferences[WORSE_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1263 	+ 	if (p->referent == cand->value) {
	1264 	+ 	add_to_CDPS(thisAgent, s, p);
	1265 	+ 	}
	1266 	+ 	}
	1267 	+ 	}
	1268 	+ 	prev_cand = cand;
	1269 	+ 	}
	1270 	+ 	cand = cand->next_candidate;
	1271 	+ 	}
	1272 	+ 	}
1017 	1273 		
1018 		- 	/* === Better/Worse === */
1019 		- 	#define NEW_PREFERENCES_SCHEME 1 // bug 234
1020 		- 	#if(NEW_PREFERENCES_SCHEME == 1)
1021 		- 	// new algorithm:
1022 		- 	// for each j > k:
1023 		- 	// if j is (candidate or conflicted) and k is (candidate or conflicted):
1024 		- 	// if one of (j, k) is candidate:
1025 		- 	// candidate -= k, if not already true
1026 		- 	// conflicted += k, if not already true
1027 		- 	// for each j < k:
1028 		- 	// if j is (candidate or conflicted) and k is (candidate or conflicted):
1029 		- 	// if one of (j, k) is candidate:
1030 		- 	// candidate -= j, if not already true
1031 		- 	// conflicted += j, if not already true
1032 		- 	// if no remaning candidates:
1033 		- 	// conflict impasse using conflicted as candidates
1034 		- 	// else
1035 		- 	// pass on candidates to next filter
1036 		- 	if (s->preferences[BETTER_PREFERENCE_TYPE] || s->preferences[WORSE_PREFERENCE_TYPE])
1037 		- 	{
1038 		- 	Symbol *j, *k;
	1274 	+ 	/* Exit point 2: Check if we're done, i.e. 0 or 1 candidates left */
1039 	1275 		
1040 		- 	// initialize
1041 		- 	for (p=s->preferences[BETTER_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1042 		- 	{
1043 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1044 		- 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
1045 		- 	}
1046 		- 	for (p=s->preferences[WORSE_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1047 		- 	{
1048 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1049 		- 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
1050 		- 	}
1051 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate) {
1052 		- 	cand->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
1053 		- 	}
	1276 	+ 	if ((!candidates) || (!candidates->next_candidate)) {
	1277 	+ 	*result_candidates = candidates;
	1278 	+ 	if (candidates) {
	1279 	+ 	/* Update RL values for the winning candidate */
	1280 	+ 	rl_update_for_one_candidate(thisAgent, s, consistency, candidates);
	1281 	+ 	} else {
	1282 	+ 	if (do_CDPS && s->CDPS) {
	1283 	+ 	clear_CDPS(thisAgent, s);
	1284 	+ 	}
	1285 	+ 	}
	1286 	+ 	return NONE_IMPASSE_TYPE;
	1287 	+ 	}
1054 	1288 		
1055 		- 	for (p=s->preferences[BETTER_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1056 		- 	{
1057 		- 	j = p->value;
1058 		- 	k = p->referent;
1059 		- 	if (j==k)
1060 		- 	continue;
1061 		- 	if (j->common.decider_flag && k->common.decider_flag)
1062 		- 	{
1063 		- 	if (j->common.decider_flag == CANDIDATE_DECIDER_FLAG || k->common.decider_flag == CANDIDATE_DECIDER_FLAG)
1064 		- 	k->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1065 		- 	}
1066 		- 	}
	1289 	+ 	/* === Bests === */
1067 	1290 		
1068 		- 	for (p=s->preferences[WORSE_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1069 		- 	{
1070 		- 	j = p->value;
1071 		- 	k = p->referent;
1072 		- 	if (j==k)
1073 		- 	continue;
1074 		- 	if (j->common.decider_flag && k->common.decider_flag)
1075 		- 	{
1076 		- 	if (j->common.decider_flag == CANDIDATE_DECIDER_FLAG || k->common.decider_flag == CANDIDATE_DECIDER_FLAG)
1077 		- 	j->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1078 		- 	}
1079 		- 	}
	1291 	+ 	if (s->preferences[BEST_PREFERENCE_TYPE]) {
1080 	1292 		
1081 		- 	/* --- now scan through candidates list, look for remaining candidates --- */
1082 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1083 		- 	{
1084 		- 	if (cand->value->common.decider_flag==CANDIDATE_DECIDER_FLAG)
1085 		- 	break;
1086 		- 	}
1087 		- 	if (!cand) {
1088 		- 	/* --- collect conflicted candidates into new candidates list --- */
1089 		- 	prev_cand = NIL;
1090 		- 	cand = candidates;
1091 		- 	while (cand)
1092 		- 	{
1093 		- 	if (cand->value->common.decider_flag != CONFLICTED_DECIDER_FLAG)
1094 		- 	{
1095 		- 	if (prev_cand)
1096 		- 	prev_cand->next_candidate = cand->next_candidate;
1097 		- 	else
1098 		- 	candidates = cand->next_candidate;
1099 		- 	}
1100 		- 	else
1101 		- 	{
1102 		- 	prev_cand = cand;
1103 		- 	}
1104 		- 	cand = cand->next_candidate;
1105 		- 	}
1106 		- 	*result_candidates = candidates;
1107 		- 	return CONFLICT_IMPASSE_TYPE;
1108 		- 	}
1109 		- 	/* --- non-conflict candidates found, remove conflicts from candidates --- */
1110 		- 	prev_cand = NIL;
1111 		- 	cand = candidates;
1112 		- 	while (cand)
1113 		- 	{
1114 		- 	if (cand->value->common.decider_flag == CONFLICTED_DECIDER_FLAG)
1115 		- 	{
1116 		- 	if (prev_cand)
1117 		- 	prev_cand->next_candidate = cand->next_candidate;
1118 		- 	else
1119 		- 	candidates = cand->next_candidate;
1120 		- 	}
1121 		- 	else
1122 		- 	{
1123 		- 	prev_cand = cand;
1124 		- 	}
1125 		- 	cand = cand->next_candidate;
1126 		- 	}
1127 		- 	}
1128 		- 	#else // !NEW_PREFERENCES_SCHEME
1129 		- 	if (s->preferences[BETTER_PREFERENCE_TYPE] ||
1130 		- 	s->preferences[WORSE_PREFERENCE_TYPE]) {
1131 		- 	Symbol *j, *k;
	1293 	+ 	/* Initialize decider flags for all candidates */
	1294 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate)
	1295 	+ 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1132 	1296 		
1133 		- 	/* -------------------- Algorithm to find conflicted set:
1134 		- 	conflicted = {}
1135 		- 	for each (j > k):
1136 		- 	if j is (candidate or conflicted)
1137 		- 	and k is (candidate or conflicted)
1138 		- 	and at least one of j,k is a candidate
1139 		- 	then if (k > j) or (j < k) then
1140 		- 	conflicted += j, if not already true
1141 		- 	conflicted += k, if not already true
1142 		- 	candidate -= j, if not already true
1143 		- 	candidate -= k, if not already true
1144 		- 	for each (j < k):
1145 		- 	if j is (candidate or conflicted)
1146 		- 	and k is (candidate or conflicted)
1147 		- 	and at least one of j,k is a candidate
1148 		- 	then if (k < j)
1149 		- 	then
1150 		- 	conflicted += j, if not already true
1151 		- 	conflicted += k, if not already true
1152 		- 	candidate -= j, if not already true
1153 		- 	candidate -= k, if not already true
1154 		- 	----------------------- */
	1297 	+ 	/* Mark flag for those with a best preference */
	1298 	+ 	for (p = s->preferences[BEST_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1299 	+ 	p->value->common.decider_flag = BEST_DECIDER_FLAG;
	1300 	+ 	}
1155 	1301 		
1156 		- 	for (p=s->preferences[BETTER_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
1157 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1158 		- 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
1159 		- 	}
1160 		- 	for (p=s->preferences[WORSE_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
1161 		- 	p->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1162 		- 	p->referent->common.decider_flag = NOTHING_DECIDER_FLAG;
1163 		- 	}
1164 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate) {
1165 		- 	cand->value->common.decider_flag = CANDIDATE_DECIDER_FLAG;
1166 		- 	}
1167 		- 	for (p=s->preferences[BETTER_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
1168 		- 	j = p->value;
1169 		- 	k = p->referent;
1170 		- 	if (j==k) continue;
1171 		- 	if (j->common.decider_flag && k->common.decider_flag) {
1172 		- 	if(k->common.decider_flag != CONFLICTED_DECIDER_FLAG)
1173 		- 	k->common.decider_flag = FORMER_CANDIDATE_DECIDER_FLAG;
1174 		- 	if ((j->common.decider_flag!=CONFLICTED_DECIDER_FLAG) ||
1175 		- 	(k->common.decider_flag!=CONFLICTED_DECIDER_FLAG)) {
1176 		- 	for (p2=s->preferences[BETTER_PREFERENCE_TYPE]; p2; p2=p2->next)
1177 		- 	if ((p2->value==k)&&(p2->referent==j)) {
1178 		- 	j->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1179 		- 	k->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1180 		- 	break;
1181 		- 	}
1182 		- 	for (p2=s->preferences[WORSE_PREFERENCE_TYPE]; p2; p2=p2->next)
1183 		- 	if ((p2->value==j)&&(p2->referent==k)) {
1184 		- 	j->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1185 		- 	k->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1186 		- 	break;
1187 		- 	}
1188 		- 	}
1189 		- 	}
1190 		- 	}
1191 		- 	for (p=s->preferences[WORSE_PREFERENCE_TYPE]; p!=NIL; p=p->next) {
1192 		- 	j = p->value;
1193 		- 	k = p->referent;
1194 		- 	if (j==k) continue;
1195 		- 	if (j->common.decider_flag && k->common.decider_flag) {
1196 		- 	if(j->common.decider_flag != CONFLICTED_DECIDER_FLAG)
1197 		- 	j->common.decider_flag = FORMER_CANDIDATE_DECIDER_FLAG;
1198 		- 	if ((j->common.decider_flag!=CONFLICTED_DECIDER_FLAG) ||
1199 		- 	(k->common.decider_flag!=CONFLICTED_DECIDER_FLAG)) {
1200 		- 	for (p2=s->preferences[WORSE_PREFERENCE_TYPE]; p2; p2=p2->next)
1201 		- 	if ((p2->value==k)&&(p2->referent==j)) {
1202 		- 	j->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1203 		- 	k->common.decider_flag = CONFLICTED_DECIDER_FLAG;
1204 		- 	break;
1205 		- 	}
1206 		- 	}
1207 		- 	}
1208 		- 	}
	1302 	+ 	/* Reduce candidates list to only those with best preference flag and add pref to CDPS */
	1303 	+ 	prev_cand = NIL;
	1304 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate)
	1305 	+ 	if (cand->value->common.decider_flag == BEST_DECIDER_FLAG) {
	1306 	+ 	if (do_CDPS) {
	1307 	+ 	for (p = s->preferences[BEST_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1308 	+ 	if (p->value == cand->value) {
	1309 	+ 	add_to_CDPS(thisAgent, s, p);
	1310 	+ 	}
	1311 	+ 	}
	1312 	+ 	}
	1313 	+ 	if (prev_cand)
	1314 	+ 	prev_cand->next_candidate = cand;
	1315 	+ 	else
	1316 	+ 	candidates = cand;
	1317 	+ 	prev_cand = cand;
	1318 	+ 	}
	1319 	+ 	if (prev_cand)
	1320 	+ 	prev_cand->next_candidate = NIL;
	1321 	+ 	}
1209 	1322 		
1210 		- 	/* --- now scan through candidates list, look for conflicted stuff --- */
1211 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1212 		- 	if (cand->value->common.decider_flag==CONFLICTED_DECIDER_FLAG) break;
1213 		- 	if (cand) {
1214 		- 	/* --- collect conflicted candidates into new candidates list --- */
1215 		- 	prev_cand = NIL;
1216 		- 	cand = candidates;
1217 		- 	while (cand) {
1218 		- 	if (cand->value->common.decider_flag != CONFLICTED_DECIDER_FLAG) {
1219 		- 	if (prev_cand)
1220 		- 	prev_cand->next_candidate = cand->next_candidate;
1221 		- 	else
1222 		- 	candidates = cand->next_candidate;
1223 		- 	} else {
1224 		- 	prev_cand = cand;
1225 		- 	}
1226 		- 	cand = cand->next_candidate;
1227 		- 	}
1228 		- 	*result_candidates = candidates;
1229 		- 	return CONFLICT_IMPASSE_TYPE;
1230 		- 	}
1231 		- 	/* --- no conflicts found, remove former_candidates from candidates --- */
1232 		- 	prev_cand = NIL;
1233 		- 	cand = candidates;
1234 		- 	while (cand) {
1235 		- 	if (cand->value->common.decider_flag == FORMER_CANDIDATE_DECIDER_FLAG) {
1236 		- 	if (prev_cand)
1237 		- 	prev_cand->next_candidate = cand->next_candidate;
1238 		- 	else
1239 		- 	candidates = cand->next_candidate;
1240 		- 	} else {
1241 		- 	prev_cand = cand;
1242 		- 	}
1243 		- 	cand = cand->next_candidate;
1244 		- 	}
1245 		- 	}
1246 		- 	#endif // !NEW_PREFERENCES_SCHEME
	1323 	+ 	/* Exit point 3: Check if we're done, i.e. 0 or 1 candidates left */
1247 	1324 		
1248 		- 	/* === Bests === */
1249 		- 	if (s->preferences[BEST_PREFERENCE_TYPE]) {
1250 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1251 		- 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1252 		- 	for (p=s->preferences[BEST_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1253 		- 	p->value->common.decider_flag = BEST_DECIDER_FLAG;
1254 		- 	prev_cand = NIL;
1255 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1256 		- 	if (cand->value->common.decider_flag == BEST_DECIDER_FLAG) {
1257 		- 	if (prev_cand)
1258 		- 	prev_cand->next_candidate = cand;
1259 		- 	else
1260 		- 	candidates = cand;
1261 		- 	prev_cand = cand;
1262 		- 	}
1263 		- 	if (prev_cand) prev_cand->next_candidate = NIL;
1264 		- 	}
	1325 	+ 	if ((!candidates) || (!candidates->next_candidate)) {
	1326 	+ 	*result_candidates = candidates;
	1327 	+ 	if (candidates) {
	1328 	+ 	/* Update RL values for the winning candidate */
	1329 	+ 	rl_update_for_one_candidate(thisAgent, s, consistency, candidates);
	1330 	+ 	} else {
	1331 	+ 	if (do_CDPS && s->CDPS) {
	1332 	+ 	clear_CDPS(thisAgent, s);
	1333 	+ 	}
	1334 	+ 	}
	1335 	+ 	return NONE_IMPASSE_TYPE;
	1336 	+ 	}
1265 	1337 		
1266 		- 	/* === Worsts === */
1267 		- 	if (s->preferences[WORST_PREFERENCE_TYPE]) {
1268 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1269 		- 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1270 		- 	for (p=s->preferences[WORST_PREFERENCE_TYPE]; p!=NIL; p=p->next)
1271 		- 	p->value->common.decider_flag = WORST_DECIDER_FLAG;
1272 		- 	prev_cand = NIL;
1273 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1274 		- 	if (cand->value->common.decider_flag != WORST_DECIDER_FLAG) {
1275 		- 	if (prev_cand)
1276 		- 	prev_cand->next_candidate = cand;
1277 		- 	else
1278 		- 	candidates = cand;
1279 		- 	prev_cand = cand;
1280 		- 	}
1281 		- 	if (prev_cand) prev_cand->next_candidate = NIL;
1282 		- 	}
	1338 	+ 	/* === Worsts === */
1283 	1339 		
1284 		- 	/* === If there are only 0 or 1 candidates, we're done === */
1285 		- 	if ( !candidates || !candidates->next_candidate )
1286 		- 	{
1287 		- 	*result_candidates = candidates;
	1340 	+ 	if (s->preferences[WORST_PREFERENCE_TYPE]) {
1288 	1341 		
1289 		- 	if ( !consistency && rl_enabled( thisAgent ) && candidates )
1290 		- 	{
1291 		- 	// perform update here for just one candidate
1292 		- 	rl_tabulate_reward_values( thisAgent );
1293 		- 	exploration_compute_value_of_candidate( thisAgent, candidates, s, 0 );
1294 		- 	rl_perform_update( thisAgent, candidates->numeric_value, candidates->rl_contribution, s->id );
1295 		- 	}
	1342 	+ 	/* Initialize decider flags for all candidates */
	1343 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate)
	1344 	+ 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1296 	1345 		
1297 		- 	return NONE_IMPASSE_TYPE;
1298 		- 	}
	1346 	+ 	/* Mark flag for those with a worst preference */
	1347 	+ 	for (p = s->preferences[WORST_PREFERENCE_TYPE]; p != NIL; p = p->next)
	1348 	+ 	p->value->common.decider_flag = WORST_DECIDER_FLAG;
1299 	1349 		
1300 		- 	/* === Indifferents === */
1301 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1302 		- 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1303 		- 	for (p=s->preferences[UNARY_INDIFFERENT_PREFERENCE_TYPE]; p; p=p->next)
1304 		- 	p->value->common.decider_flag = UNARY_INDIFFERENT_DECIDER_FLAG;
	1350 	+ 	/* Reduce candidates list to only those that do not have a worst preference flag. Note
	1351 	+ 	* that this only occurs if there is at least one candidate that doesn't have a worse
	1352 	+ 	* preference, otherwise the candidate list is not modified. */
1305 	1353 		
	1354 	+ 	prev_cand = NIL;
	1355 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate) {
	1356 	+ 	if (cand->value->common.decider_flag != WORST_DECIDER_FLAG) {
	1357 	+ 	if (prev_cand)
	1358 	+ 	prev_cand->next_candidate = cand;
	1359 	+ 	else
	1360 	+ 	candidates = cand;
	1361 	+ 	prev_cand = cand;
	1362 	+ 	} else {
	1363 	+ 	if (do_CDPS) {
	1364 	+ 	/* Add this worst preference to CDPS */
	1365 	+ 	for (p = s->preferences[WORST_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1366 	+ 	if (p->value == cand->value) {
	1367 	+ 	add_to_CDPS(thisAgent, s, p);
	1368 	+ 	}
	1369 	+ 	}
	1370 	+ 	}
	1371 	+ 	}
	1372 	+ 	}
	1373 	+ 	if (prev_cand)
	1374 	+ 	prev_cand->next_candidate = NIL;
	1375 	+ 	}
1306 	1376 		
1307 		- 	for (p=s->preferences[NUMERIC_INDIFFERENT_PREFERENCE_TYPE]; p; p=p->next)
1308 		- 	p->value->common.decider_flag = UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG;
	1377 	+ 	/* Exit point 4: Check if we're done, i.e. 0 or 1 candidates left */
1309 	1378 		
1310 		- 	for (p=s->preferences[BINARY_INDIFFERENT_PREFERENCE_TYPE]; p; p=p->next)
1311 		- 	if((p->referent->fc.common_symbol_info.symbol_type == INT_CONSTANT_SYMBOL_TYPE) ||
1312 		- 	(p->referent->fc.common_symbol_info.symbol_type == FLOAT_CONSTANT_SYMBOL_TYPE))
1313 		- 	p->value->common.decider_flag = UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG;
	1379 	+ 	if ((!candidates) || (!candidates->next_candidate)) {
	1380 	+ 	*result_candidates = candidates;
	1381 	+ 	if (candidates) {
	1382 	+ 	/* Update RL values for the winning candidate */
	1383 	+ 	rl_update_for_one_candidate(thisAgent, s, consistency, candidates);
	1384 	+ 	} else {
	1385 	+ 	if (do_CDPS && s->CDPS) {
	1386 	+ 	clear_CDPS(thisAgent, s);
	1387 	+ 	}
	1388 	+ 	}
	1389 	+ 	return NONE_IMPASSE_TYPE;
	1390 	+ 	}
1314 	1391 		
	1392 	+ 	/* === Indifferents === */
1315 	1393 		
	1394 	+ 	/* Initialize decider flags for all candidates */
1316 	1395 		
1317 		- 	not_all_indifferent = FALSE;
1318 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1319 		- 	{
1320 		- 	if (cand->value->common.decider_flag==UNARY_INDIFFERENT_DECIDER_FLAG)
1321 		- 	continue;
1322 		- 	else if ( cand->value->common.decider_flag==UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG )
1323 		- 	continue;
	1396 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate)
	1397 	+ 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1324 	1398 		
1325 		- 	/* --- check whether cand is binary indifferent to each other one --- */
1326 		- 	for (p=candidates; p!=NIL; p=p->next_candidate) {
1327 		- 	if (p==cand) continue;
1328 		- 	match_found = FALSE;
1329 		- 	for (p2=s->preferences[BINARY_INDIFFERENT_PREFERENCE_TYPE]; p2!=NIL;
1330 		- 	p2=p2->next)
1331 		- 	if ( ((p2->value==cand->value)&&(p2->referent==p->value)) ||
1332 		- 	((p2->value==p->value)&&(p2->referent==cand->value)) ) {
1333 		- 	match_found = TRUE;
1334 		- 	break;
1335 		- 	}
1336 		- 	if (!match_found) {
1337 		- 	not_all_indifferent = TRUE;
1338 		- 	break;
1339 		- 	}
1340 		- 	} /* end of for p loop */
1341 		- 	if (not_all_indifferent) break;
1342 		- 	} /* end of for cand loop */
	1399 	+ 	/* Mark flag for unary or numeric indifferent preferences */
1343 	1400 		
1344 		- 	if ( !not_all_indifferent )
1345 		- 	{
1346 		- 	if ( !consistency )
1347 		- 	{
1348 		- 	(*result_candidates) = exploration_choose_according_to_policy( thisAgent, s, candidates );
1349 		- 	(*result_candidates)->next_candidate = NIL;
1350 		- 	}
1351 		- 	else
1352 		- 	*result_candidates = candidates;
	1401 	+ 	for (p = s->preferences[UNARY_INDIFFERENT_PREFERENCE_TYPE]; p; p = p->next)
	1402 	+ 	p->value->common.decider_flag = UNARY_INDIFFERENT_DECIDER_FLAG;
1353 	1403 		
1354 		- 	return NONE_IMPASSE_TYPE;
1355 		- 	}
	1404 	+ 	for (p = s->preferences[NUMERIC_INDIFFERENT_PREFERENCE_TYPE]; p; p = p->next)
	1405 	+ 	p->value->common.decider_flag = UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG;
1356 	1406 		
1357 		- 	/* --- items not all indifferent; for context slots this gives a tie --- */
1358 		- 	if (s->isa_context_slot) {
1359 		- 	*result_candidates = candidates;
1360 		- 	return TIE_IMPASSE_TYPE;
1361 		- 	}
	1407 	+ 	/* Go through candidate list and check for a tie impasse. All candidates
	1408 	+ 	* must either be unary indifferent or binary indifferent to every item on
	1409 	+ 	* the candidate list. This will also catch when a candidate has no
	1410 	+ 	* indifferent preferences at all. */
1362 	1411 		
1363 		- 	/* === Parallels === */
1364 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate)
1365 		- 	cand->value->common.decider_flag = NOTHING_DECIDER_FLAG;
1366 		- 	for (p=s->preferences[UNARY_PARALLEL_PREFERENCE_TYPE]; p; p=p->next)
1367 		- 	p->value->common.decider_flag = UNARY_PARALLEL_DECIDER_FLAG;
1368 		- 	not_all_parallel = FALSE;
1369 		- 	for (cand=candidates; cand!=NIL; cand=cand->next_candidate) {
1370 		- 	/* --- if cand is unary parallel, it's fine --- */
1371 		- 	if (cand->value->common.decider_flag==UNARY_PARALLEL_DECIDER_FLAG)
1372 		- 	continue;
1373 		- 	/* --- check whether cand is binary parallel to each other candidate --- */
1374 		- 	for (p=candidates; p!=NIL; p=p->next_candidate) {
1375 		- 	if (p==cand) continue;
1376 		- 	match_found = FALSE;
1377 		- 	for (p2=s->preferences[BINARY_PARALLEL_PREFERENCE_TYPE]; p2!=NIL;
1378 		- 	p2=p2->next)
1379 		- 	if ( ((p2->value==cand->value)&&(p2->referent==p->value)) ||
1380 		- 	((p2->value==p->value)&&(p2->referent==cand->value)) ) {
1381 		- 	match_found = TRUE;
1382 		- 	break;
1383 		- 	}
1384 		- 	if (!match_found) {
1385 		- 	not_all_parallel = TRUE;
1386 		- 	break;
1387 		- 	}
1388 		- 	} /* end of for p loop */
1389 		- 	if (not_all_parallel) break;
1390 		- 	} /* end of for cand loop */
	1412 	+ 	not_all_indifferent = false;
	1413 	+ 	some_numeric = false;
1391 	1414 		
1392 		- 	*result_candidates = candidates;
	1415 	+ 	for (cand = candidates; cand != NIL; cand = cand->next_candidate) {
1393 	1416 		
1394 		- 	if (! not_all_parallel) {
1395 		- 	/* --- items are all parallel, so return them all --- */
1396 		- 	return NONE_IMPASSE_TYPE;
1397 		- 	}
	1417 	+ 	/* If this candidate has a unary indifferent preference, skip. Numeric indifferent
	1418 	+ 	* prefs are considered to have an implicit unary indifferent pref,
	1419 	+ 	* which is why they are skipped too. */
1398 	1420 		
1399 		- 	/* --- otherwise we have a tie --- */
1400 		- 	return TIE_IMPASSE_TYPE;
1401 		- 	}
	1421 	+ 	if (cand->value->common.decider_flag == UNARY_INDIFFERENT_DECIDER_FLAG)
	1422 	+ 	continue;
	1423 	+ 	else if (cand->value->common.decider_flag == UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG) {
	1424 	+ 	some_numeric = true;
	1425 	+ 	continue;
	1426 	+ 	}
1402 	1427 		
	1428 	+ 	/* Candidate has either only binary indifferences or no indifference prefs
	1429 	+ 	* at all, so make sure there is a binary preference between its operator
	1430 	+ 	* and every other preference's operator in the candidate list */
1403 	1431 		
1404 		- 	byte run_preference_semantics_for_consistency_check (agent* thisAgent, slot *s, preference **result_candidates)
1405 		- 	{
1406 		- 	return run_preference_semantics( thisAgent, s, result_candidates, true );
	1432 	+ 	for (p = candidates; p != NIL; p = p->next_candidate) {
	1433 	+ 	if (p == cand)
	1434 	+ 	continue;
	1435 	+ 	match_found = false;
	1436 	+ 	for (p2 = s->preferences[BINARY_INDIFFERENT_PREFERENCE_TYPE]; p2 != NIL;
	1437 	+ 	p2 = p2->next)
	1438 	+ 	if (((p2->value == cand->value) && (p2->referent == p->value))
	1439 	+ 	|| ((p2->value == p->value) && (p2->referent == cand->value))) {
	1440 	+ 	match_found = true;
	1441 	+ 	break;
	1442 	+ 	}
	1443 	+ 	if (!match_found) {
	1444 	+ 	not_all_indifferent = true;
	1445 	+ 	break;
	1446 	+ 	}
	1447 	+ 	}
	1448 	+ 	if (not_all_indifferent)
	1449 	+ 	break;
	1450 	+ 	}
	1451 	+ 	
	1452 	+ 	if (!not_all_indifferent) {
	1453 	+ 	if (!consistency) {
	1454 	+ 	(*result_candidates) = exploration_choose_according_to_policy(thisAgent, s, candidates);
	1455 	+ 	(*result_candidates)->next_candidate = NIL;
	1456 	+ 	
	1457 	+ 	if (do_CDPS) {
	1458 	+ 	
	1459 	+ 	/* Add all indifferent preferences associated with the chosen candidate to the CDPS.*/
	1460 	+ 	
	1461 	+ 	if (some_numeric) {
	1462 	+ 	
	1463 	+ 	/* Note that numeric indifferent preferences are never considered duplicates, so we
	1464 	+ 	* pass an extra argument to add_to_cdps so that it does not check for duplicates.*/
	1465 	+ 	
	1466 	+ 	for (p = s->preferences[NUMERIC_INDIFFERENT_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1467 	+ 	if (p->value == (*result_candidates)->value) {
	1468 	+ 	add_to_CDPS(thisAgent, s, p, false);
	1469 	+ 	}
	1470 	+ 	}
	1471 	+ 	
	1472 	+ 	/* Now add any binary preferences with a candidate that does NOT have a numeric preference. */
	1473 	+ 	
	1474 	+ 	for (p = s->preferences[BINARY_INDIFFERENT_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1475 	+ 	if ((p->value == (*result_candidates)->value) || (p->referent == (*result_candidates)->value)) {
	1476 	+ 	if ((p->referent->common.decider_flag != UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG) ||
	1477 	+ 	(p->value->common.decider_flag != UNARY_INDIFFERENT_CONSTANT_DECIDER_FLAG)) {
	1478 	+ 	add_to_CDPS(thisAgent, s, p);
	1479 	+ 	}
	1480 	+ 	}
	1481 	+ 	}
	1482 	+ 	} else {
	1483 	+ 	
	1484 	+ 	/* This decision was non-numeric, so add all non-numeric preferences associated with the
	1485 	+ 	* chosen candidate to the CDPS.*/
	1486 	+ 	
	1487 	+ 	for (p = s->preferences[UNARY_INDIFFERENT_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1488 	+ 	if (p->value == (*result_candidates)->value) {
	1489 	+ 	add_to_CDPS(thisAgent, s, p);
	1490 	+ 	}
	1491 	+ 	}
	1492 	+ 	for (p = s->preferences[BINARY_INDIFFERENT_PREFERENCE_TYPE]; p != NIL; p = p->next) {
	1493 	+ 	if ((p->value == (*result_candidates)->value) || (p->referent == (*result_candidates)->value)) {
	1494 	+ 	add_to_CDPS(thisAgent, s, p);
	1495 	+ 	}
	1496 	+ 	}
	1497 	+ 	}
	1498 	+ 	}
	1499 	+ 	} else {
	1500 	+ 	*result_candidates = candidates;
	1501 	+ 	}
	1502 	+ 	return NONE_IMPASSE_TYPE;
	1503 	+ 	}
	1504 	+ 	
	1505 	+ 	/* Candidates are not all indifferent, so we have a tie. */
	1506 	+ 	
	1507 	+ 	*result_candidates = candidates;
	1508 	+ 	if (do_CDPS && s->CDPS) {
	1509 	+ 	clear_CDPS(thisAgent, s);
	1510 	+ 	}
	1511 	+ 	return TIE_IMPASSE_TYPE;
1407 	1512 		}
1408 	1513 		
1409 	1514 		/* **************************************************************************
... 			

# make_fake_preference_for_goal_item()
1638 	1743 		#endif
1639 	1744 		cond->bt.level = ap_wme->id->id.level;
1640 	1745 		cond->bt.trace = NIL;
1641 		- 	cond->bt.prohibits = NIL;
	1746 	+ 	cond->bt.CDPS = NIL;
	1747 	+ 	
1642 	1748 		/* --- return the fake preference --- */
1643 	1749 		return pref;
1644 	1750 		}
... 		
# typo fix in comment	
1919 	2025 		* the chunk will be first on the GDS list. This order
1920 	2026 		* appears to be always true, although I am not 100% certain
1921 	2027 		* (I think it occurs this way because the chunk is
1922 		- 	* necessarily added to the instantiaton list after the
	2028 	+ 	* necessarily added to the instantiation list after the
1923 	2029 		* original instantiation and lists get built such older items
1924 	2030 		* appear further from the head of the list) . If not true,
1925 	2031 		* then we need to keep track of any GDS's that get created
... 		

# comment update	
2080 	2186 		Context Slot Is Decidable
2081 	2187 		
2082 	2188 		This returns TRUE iff the given slot (which must be a context slot)
2083 		- 	is decidable. A context slot is decidable if:
2084 		- 	- it has an installed value in WM and there is a reconsider
2085 		- 	preference for that value, or
2086 		- 	- it has no installed value but does have changed preferences
	2189 	+ 	is decidable. A context slot is decidable if it has no installed
	2190 	+ 	value but does have changed preferences
2087 	2191 		------------------------------------------------------------------ */
2088 	2192 		

# context_slot_is_decidable()
2089 	2193 		Bool context_slot_is_decidable (slot *s)
2090 	2194 		{
2091 		- 	Symbol *v;
2092 		- 	preference *p;
2093 		- 	
2094 	2195 		if (!s->wmes)
2095 	2196 		return (s->changed != NIL);
2096 		- 	
2097 		- 	v = s->wmes->value;
2098 		- 	for (p = s->preferences[RECONSIDER_PREFERENCE_TYPE]; p != NIL; p = p->next)
2099 		- 	{
2100 		- 	if (v == p->value)
2101 		- 	return TRUE;
2102 		- 	}
2103 	2197 		
2104 	2198 		return FALSE;
2105 	2199 		}
... 			

# removal of old comment
2762 	2856 		{
2763 	2857 		predict_srand_restore_snapshot( thisAgent, !predict );
2764 	2858 		
2765 		- 	/* phase printing moved to init_soar: do_one_top_level_phase */
2766 		- 	
2767 	2859 		decide_context_slots (thisAgent, predict);
2768 	2860 		
2769 	2861 		if ( !predict )
... 	

################################################################################
# adding cdps list in various places, and comment changes

Modify	/trunk/SoarSuite/Core/SoarKernel/src/gdatastructs.h	diff
... 			
# typo fixes in comments
52 	52 		/* ------------------------------------------------------------------------
53 	53 		Goal Dependency Set
54 	54 		
55 		- 	The Goal Dependency Set is a data strcuture used in Operand2 to maintain
	55 	+ 	The Goal Dependency Set is a data structure used in Operand2 to maintain
56 	56 		the integrity of a subgoal with respect to changes in supergoal WMEs.
57 	57 		Whenever a WME in the goal's dependency set changes, the goal is immediately
58 	58 		removed. The routines for maintaining the GDS and determining if a goal
... 			
65 	65 		
66 	66 		wmes_in_gds: A DLL of WMEs in the goal dependency set
67 	67 		
68 		- 	The GDS is created only when necessary; that is, when an o-suppported WME
	68 	+ 	The GDS is created only when necessary; that is, when an o-supported WME
69 	69 		is created in some subgoal and that subgoal has no GDS already. The
70 	70 		instantiations that led to the creation of the o-supported WME are
71 	71 		examined; any supergoal WMEs in these instantiations are added to the
... 			

# comment expansion
155 	155 		------------------------------------------------------------------------ */
156 	156 		
157 	157 		/* WARNING: preference types must be numbered 0..(NUM_PREFERENCE_TYPES-1),
158 		- 	because the slot structure contains an array using these indices. */
	158 	+ 	because the slot structure contains an array using these indices. Also
	159 	+ 	make sure to update the strings in prefmem.h. Finally, make sure the
	160 	+ 	helper function defined below (for e.g. preference_is_unary) use the
	161 	+ 	correct indices.
	162 	+ 	
	163 	+ 	NOTE: Reconsider, binary and unary parallel preferences are all
	164 	+ 	deprecated. Their types are not removed here because it would break
	165 	+ 	backward compatibility of rete fast loading/saving. It's possible that
	166 	+ 	can be fixed in rete.cpp, but for now, we're just keeping the preference
	167 	+ 	types. There is no code that actually uses them any more, though.*/
	168 	+ 	
	169 	+ 	
159 	170 		
160 	171 		#define ACCEPTABLE_PREFERENCE_TYPE 0
161 	172 		#define REQUIRE_PREFERENCE_TYPE 1
... 			

# this change irrelevant
189 	200 		{
190 	201 		return (p > 8);
191 	202 		}
192 		- 	
193 	203 		#endif /* USE_MACROS */
194 	204 		
195 	205 		#ifdef __cplusplus
... 			

# comment expansion
280 	290 		match goal, with the pref. supported by the highest goal at the
281 	291 		head of the list.
282 	292 		
	293 	+ 	CDPS: a dll of preferences in the context-dependent preference set,
	294 	+ 	which is the set of all preferences that contributed to an operator's
	295 	+ 	selection. This is used to allow Soar to backtrace through evaluation
	296 	+ 	rules in substates. The rules that determine which preferences are
	297 	+ 	in the CPSD are outlined in run_preference_semantics().
	298 	+ 	
283 	299 		impasse_id: points to the identifier of the attribute impasse object
284 	300 		for this slot. (NIL if the slot isn't impassed.)
285 	301 		
... 			

# adding cdps list to slot_struct
310 	326 		wme *acceptable_preference_wmes; /* dll of acceptable pref. wmes */
311 	327 		preference *all_preferences; /* dll of all pref's in the slot */
312 	328 		preference *preferences[NUM_PREFERENCE_TYPES]; /* dlls for each type */
	329 	+ 	::list *CDPS; /* list of prefs in the CDPS to backtrace through */
313 	330 		Symbol *impasse_id; /* NIL if slot is not impassed */
314 	331 		Bool isa_context_slot;
315 	332 		byte impasse_type;
... 			

# adding cdps list to bt_info_struct
525 	542 		preference *trace; /* preference for BT, or NIL */
526 	543 		
527 	544 		/* mvp 5-17-94 */
528 		- 	::list *prohibits; /* list of prohibit prefs to backtrace through */
	545 	+ 	::list *CDPS; /* list of substate evaluation prefs to backtrace through,
	546 	+ 	i.e. the context dependent preference set. */
	547 	+ 	
529 	548 		} bt_info;
530 	549 		

# change to reorder_info_struct
531 	550 		/* --- info on conditions used only by the reorderer --- */
532 	551 		typedef struct reorder_info_struct {
533 		- 	::list *vars_requiring_bindings; /* used only during reordering */
	552 	+ 	::list *vars_requiring_bindings; /* used only during reordering */
534 	553 		struct condition_struct *next_min_cost; /* used only during reordering */
535 	554 		} reorder_info;
536 	555 		
... 			

# make comments pretty (whitespace changes only)
550 	569 		/* --- finally, the structure of a condition --- */
551 	570 		typedef struct condition_struct {
552 	571 		byte type;
553 		- 	Bool already_in_tc; /* used only by cond_is_in_tc stuff */
	572 	+ 	Bool already_in_tc; /* used only by cond_is_in_tc stuff */
554 	573 		Bool test_for_acceptable_preference; /* for pos, neg cond's only */
555 	574 		struct condition_struct *next, *prev;
556 	575 		union condition_main_data_union {
557 	576 		three_field_tests tests; /* for pos, neg cond's only */
558 	577 		ncc_info ncc; /* for ncc's only */
559 	578 		} data;
560 		- 	bt_info bt; /* for top-level positive cond's: used for BT and by the rete */
	579 	+ 	bt_info bt; /* for top-level positive cond's: used for BT and by the rete */
561 	580 		reorder_info reorder; /* used only during reordering */
562 	581 		} condition;
563 	582 		
... 	


################################################################################
# param update. Probably irrelevant to jsoar

Modify	/trunk/SoarSuite/Core/SoarKernel/src/gsysparam.h	diff
	

... 			
191 	191 		/* JRV: Break on long decision cycle time */
192 	192 		#define DECISION_CYCLE_MAX_USEC_INTERRUPT 45
193 	193 		
	194 	+ 	/* MMA: Chunk over evaluation rules in subgoals */
	195 	+ 	#define CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM 46
	196 	+ 	
194 	197 		/* --- Warning: if you add sysparams, be sure to update the next line! --- */
195 		- 	#define HIGHEST_SYSPARAM_NUMBER 45
	198 	+ 	#define HIGHEST_SYSPARAM_NUMBER 46
196 	199 		
197 	200 		/* -----------------------------------------
198 	201 		Sysparams[] stores the parameters; set_sysparam()
... 		

################################################################################
# set default param value for new behavior

Modify	/trunk/SoarSuite/Core/SoarKernel/src/init_soar.cpp	diff
	
... 			
230 	230 		// JRV: Chunk through local negations by default
231 	231 		thisAgent->sysparams[CHUNK_THROUGH_LOCAL_NEGATIONS_SYSPARAM] = TRUE;
232 	232 		
	233 	+ 	// MMA: Chunk through evaluation rules off by default
	234 	+ 	thisAgent->sysparams[CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM] = TRUE;
	235 	+ 	
233 	236 		thisAgent->sysparams[DECISION_CYCLE_MAX_USEC_INTERRUPT] = 0;
234 	237 		}
235 	238 		
... 		

################################################################################
# comment typo fix. This probably doesn't exist in jsoar.

Modify	/trunk/SoarSuite/Core/SoarKernel/src/kernel.h	diff

... 			
165 	165 		* \def AGRESSIVE_ONC
166 	166 		*
167 	167 		* Setting this option enables Soar to generate operator no changes
168 		- 	* without requring a dedicated decision cycle. This occurs when
	168 	+ 	* without requiring a dedicated decision cycle. This occurs when
169 	169 		* Soar recognizes that no productions will fire the the PE phase.
170 	170 		* This is the standard behavior in Soar 8.3.5 and Soar 8.4.5, but
171 	171 		* is no longer standard as of Soar 8.5
... 	

################################################################################
# parser changes to remove Soar 7 syntax support, and corresponding comment updates

Modify	/trunk/SoarSuite/Core/SoarKernel/src/parser.cpp	diff
	
... 			
1377 	1377 		if (thisAgent->lexeme.type==COMMA_LEXEME) get_lexeme(thisAgent);
1378 	1378 		return WORST_PREFERENCE_TYPE;
1379 	1379 		
1380 		- 	case AMPERSAND_LEXEME:
1381 		- 	get_lexeme(thisAgent);
1382 		- 	if ((thisAgent->lexeme.type!=COMMA_LEXEME) &&
1383 		- 	(thisAgent->lexeme.type!=R_PAREN_LEXEME) &&
1384 		- 	(thisAgent->lexeme.type!=UP_ARROW_LEXEME) &&
1385 		- 	(!is_preference_lexeme(thisAgent->lexeme.type)))
1386 		- 	return BINARY_PARALLEL_PREFERENCE_TYPE;
1387 		- 	/* --- forced unary preference --- */
1388 		- 	if (thisAgent->lexeme.type==COMMA_LEXEME) get_lexeme(thisAgent);
1389 		- 	return UNARY_PARALLEL_PREFERENCE_TYPE;
1390 		- 	
1391 	1380 		default:
1392 	1381 		/* --- if no preference given, make it an acceptable preference --- */
1393 	1382 		return ACCEPTABLE_PREFERENCE_TYPE;
... 			
1469 	1458 		}
1470 	1459 		}
1471 	1460 		
1472 		- 	/* KJC begin: 10.09.98 */
1473 		- 	/* modified 3.99 to take out parallels and only create acceptables */
1474 	1461 		/* -----------------------------------------------------------------
1475 	1462 		Parse Preferences for Soar8 Non-Operators
1476 	1463 		
... 			
1505 	1492 		char szPrintId[256];
1506 	1493 		
1507 	1494 		/* --- Note: this routine is set up so if there's not preference type
1508 		- 	indicator at all, we return an acceptable preference make
1509 		- 	and a parallel preference make. For non-operators, allow
1510 		- 	only REJECT_PREFERENCE_TYPE, (and UNARY_PARALLEL and ACCEPTABLE).
	1495 	+ 	indicator at all, we return an acceptable preference make. For
	1496 	+ 	non-operators, allow only REJECT_PREFERENCE_TYPE, (and ACCEPTABLE).
1511 	1497 		If any other preference type indicator is found, a warning or
1512 	1498 		error msg (error only on binary prefs) is printed. --- */
1513 	1499 		
... 			
1648 	1634 		and create new action in the path */
1649 	1635 		new_var = make_placeholder_var(thisAgent, first_letter_from_rhs_value (attr));
1650 	1636 		
1651 		- 	/* parse_preferences actually creates the action. eventhough
	1637 	+ 	/* parse_preferences actually creates the action. Even though
1652 	1638 		there aren't really any preferences to read, we need the default
1653 		- 	acceptable and parallel prefs created for all attributes in path */
	1639 	+ 	acceptable prefs created for all attributes in path */
	1640 	+ 	
1654 	1641 		if(strcmp(szAttribute,"operator") != 0)
1655 	1642 		{
1656 	1643 		new_actions = parse_preferences_soar8_non_operator (thisAgent, id, attr,
... 	


################################################################################
# comment update. Probably irrelevant in jsoar

Modify	/trunk/SoarSuite/Core/SoarKernel/src/prefmem.cpp	diff	

... 			
37 	37 		#include "wma.h"
38 	38 		#include "wmem.h"
39 	39 		
	40 	+ 	/* Note that these must be in the same order as the #define variables
	41 	+ 	* in gdatastructs.h */
	42 	+ 	
40 	43 		const char * preference_name[] =
41 	44 		{ "acceptable",
42 	45 		"require",
... 	

################################################################################
# removing Soar 7 support

Modify	/trunk/SoarSuite/Core/SoarKernel/src/print.cpp	diff	

... 			
918 	918 		case REQUIRE_PREFERENCE_TYPE: return '!';
919 	919 		case REJECT_PREFERENCE_TYPE: return '-';
920 	920 		case PROHIBIT_PREFERENCE_TYPE: return '~';
921 		- 	case RECONSIDER_PREFERENCE_TYPE: return '@';
922 	921 		case NUMERIC_INDIFFERENT_PREFERENCE_TYPE: return '=';
923 	922 		case UNARY_INDIFFERENT_PREFERENCE_TYPE: return '=';
924 	923 		case BINARY_INDIFFERENT_PREFERENCE_TYPE: return '=';
925 		- 	case UNARY_PARALLEL_PREFERENCE_TYPE: return '&';
926 		- 	case BINARY_PARALLEL_PREFERENCE_TYPE: return '&';
927 	924 		case BEST_PREFERENCE_TYPE: return '>';
928 	925 		case BETTER_PREFERENCE_TYPE: return '>';
929 	926 		case WORST_PREFERENCE_TYPE: return '<';
... 		

################################################################################
# code that builds the CDPS
# the real code changes are actually very small, but it looks like a whitespace
#  formatter was run on this file, resulting in tons of irrelevant whitespace changes

Modify	/trunk/SoarSuite/Core/SoarKernel/src/recmem.cpp	diff
	

# memory pools are irrelevant in jsoar

... 			
59 	59 		using namespace soar_TraceNames;
60 	60 		
61 	61 		#ifdef USE_MEM_POOL_ALLOCATORS
62 		- 	typedef std::list< instantiation*, soar_module::soar_memory_pool_allocator< instantiation* > > inst_mpool_list;
63 		- 	typedef std::list< condition*, soar_module::soar_memory_pool_allocator< condition* > > cond_mpool_list;
	62 	+ 	typedef std::list<instantiation*,
	63 	+ 	soar_module::soar_memory_pool_allocator<instantiation*> > inst_mpool_list;
	64 	+ 	typedef std::list<condition*,
	65 	+ 	soar_module::soar_memory_pool_allocator<condition*> > cond_mpool_list;
64 	66 		#else
65 	67 		typedef std::list< instantiation* > inst_mpool_list;
66 	68 		typedef std::list< condition* > cond_mpool_list;
... 		

# minor comment typo fix
	
70 	72 		/* #define DEBUG_INSTANTIATIONS */
71 	73 		
72 	74 		/* TEMPORARY HACK (Ideally this should be doable through
73 		- 	the external kernel interface but for now using a
74 		- 	couple of global STL lists to get this information
75 		- 	from the rhs function to this prefference adding code)*/
	75 	+ 	the external kernel interface but for now using a
	76 	+ 	couple of global STL lists to get this information
	77 	+ 	from the rhs function to this preference adding code)*/
   
# remove build_prohibits_list(), replace with build_CDPS()

76 	78 		wme* glbDeepCopyWMEs = NULL;
77 	79 		
78 		- 	/* mvp 5-17-94 */
	80 	+ 	
79 	81 		/* --------------------------------------------------------------------------
80 		- 	Build Prohibit Preference List for Backtracing
81 		- 	--------------------------------------------------------------------------*/
	82 	+ 	Build context-dependent preference set
82 	83 		
83 		- 	void build_prohibits_list (agent* thisAgent, instantiation *inst) {
	84 	+ 	This function will copy the CDPS from a slot to the backtrace info for the
	85 	+ 	corresponding condition. The copied CDPS will later be backtraced through.
	86 	+ 	
	87 	+ 	Note: Until prohibits are included explicitly as part of the CDPS, we will
	88 	+ 	just copy them directly from the prohibits list so that there is no
	89 	+ 	additional overhead. Once the CDPS is on by default, we can eliminate the
	90 	+ 	second half of the big else (and not call this function at all if the
	91 	+ 	sysparam is not set.
	92 	+ 	
	93 	+ 	--------------------------------------------------------------------------*/
	94 	+ 	
	95 	+ 	void build_CDPS(agent* thisAgent, instantiation *inst) {
84 	96 		condition *cond;
85 	97 		preference *pref, *new_pref;
	98 	+ 	cons *CDPS;
86 	99 		
87 		- 	for (cond=inst->top_of_instantiated_conditions; cond!=NIL; cond=cond->next) {
88 		- 	cond->bt.prohibits = NIL;
89 		- 	if (cond->type==POSITIVE_CONDITION && cond->bt.trace) {
90 		- 	if (cond->bt.trace->slot) {
	100 	+ 	for (cond = inst->top_of_instantiated_conditions; cond != NIL;
	101 	+ 	cond = cond->next) {
	102 	+ 	cond->bt.CDPS = NIL;
	103 	+ 	if (cond->type == POSITIVE_CONDITION && cond->bt.trace && cond->bt.trace->slot) {
	104 	+ 	if (thisAgent->sysparams[CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM]) {
	105 	+ 	if (cond->bt.trace->slot->CDPS) {
	106 	+ 	for (CDPS=cond->bt.trace->slot->CDPS; CDPS!=NIL; CDPS=CDPS->rest) {
	107 	+ 	new_pref = NIL;
	108 	+ 	pref = static_cast<preference *>(CDPS->first);
	109 	+ 	if (pref->inst->match_goal_level == inst->match_goal_level
	110 	+ 	&& pref->in_tm) {
	111 	+ 	push(thisAgent, pref, cond->bt.CDPS);
	112 	+ 	preference_add_ref(pref);
	113 	+ 	} else {
	114 	+ 	new_pref = find_clone_for_level(pref, inst->match_goal_level);
	115 	+ 	if (new_pref) {
	116 	+ 	if (new_pref->in_tm) {
	117 	+ 	push(thisAgent, new_pref, cond->bt.CDPS);
	118 	+ 	preference_add_ref(new_pref);
	119 	+ 	}
	120 	+ 	}
	121 	+ 	}
	122 	+ 	}
	123 	+ 	}
	124 	+ 	} else {
91 	125 		pref = cond->bt.trace->slot->preferences[PROHIBIT_PREFERENCE_TYPE];
92 	126 		while (pref) {
93 	127 		new_pref = NIL;
94 	128 		if (pref->inst->match_goal_level == inst->match_goal_level && pref->in_tm) {
95 		- 	push (thisAgent, pref, cond->bt.prohibits);
	129 	+ 	push (thisAgent, pref, cond->bt.CDPS);
96 	130 		preference_add_ref (pref);
97 	131 		} else {
98 	132 		new_pref = find_clone_for_level (pref, inst->match_goal_level);
99 	133 		if (new_pref) {
100 	134 		if (new_pref->in_tm) {
101 		- 	push (thisAgent, new_pref, cond->bt.prohibits);
	135 	+ 	push (thisAgent, new_pref, cond->bt.CDPS);
102 	136 		preference_add_ref (new_pref);
103 	137 		}
104 	138 		}
... 			

# start irrelevant whitespace changes

111 	145 		}
112 	146 		
113 	147 		/* -----------------------------------------------------------------------
114 		- 	Find Clone For Level
	148 	+ 	Find Clone For Level
115 	149 		
116 		- 	This routines take a given preference and finds the clone of it whose
117 		- 	match goal is at the given goal_stack_level. (This is used to find the
118 		- 	proper preference to backtrace through.) If the given preference
119 		- 	itself is at the right level, it is returned. If there is no clone at
120 		- 	the right level, NIL is returned.
121 		- 	----------------------------------------------------------------------- */
	150 	+ 	This routines take a given preference and finds the clone of it whose
	151 	+ 	match goal is at the given goal_stack_level. (This is used to find the
	152 	+ 	proper preference to backtrace through.) If the given preference
	153 	+ 	itself is at the right level, it is returned. If there is no clone at
	154 	+ 	the right level, NIL is returned.
	155 	+ 	----------------------------------------------------------------------- */
122 	156 		
123 		- 	preference *find_clone_for_level (preference *p, goal_stack_level level) {
124 		- 	preference *clone;
	157 	+ 	preference *find_clone_for_level(preference *p, goal_stack_level level) {
	158 	+ 	preference *clone;
125 	159 		
126 		- 	if (! p) {
127 		- 	/* --- if the wme doesn't even have a preference on it, we can't backtrace
128 		- 	at all (this happens with I/O and some architecture-created wmes --- */
129 		- 	return NIL;
130 		- 	}
	160 	+ 	if (!p) {
	161 	+ 	/* --- if the wme doesn't even have a preference on it, we can't backtrace
	162 	+ 	at all (this happens with I/O and some architecture-created wmes --- */
	163 	+ 	return NIL;
	164 	+ 	}
131 	165 		
132 		- 	/* --- look at pref and all of its clones, find one at the right level --- */
	166 	+ 	/* --- look at pref and all of its clones, find one at the right level --- */
133 	167 		
134 		- 	if (p->inst->match_goal_level == level) return p;
	168 	+ 	if (p->inst->match_goal_level == level)
	169 	+ 	return p;
135 	170 		
136 		- 	for (clone=p->next_clone; clone!=NIL; clone=clone->next_clone)
137 		- 	if (clone->inst->match_goal_level==level) return clone;
	171 	+ 	for (clone = p->next_clone; clone != NIL; clone = clone->next_clone)
	172 	+ 	if (clone->inst->match_goal_level == level)
	173 	+ 	return clone;
138 	174 		
139 		- 	for (clone=p->prev_clone; clone!=NIL; clone=clone->prev_clone)
140 		- 	if (clone->inst->match_goal_level==level) return clone;
	175 	+ 	for (clone = p->prev_clone; clone != NIL; clone = clone->prev_clone)
	176 	+ 	if (clone->inst->match_goal_level == level)
	177 	+ 	return clone;
141 	178 		
142 		- 	/* --- if none was at the right level, we can't backtrace at all --- */
143 		- 	return NIL;
	179 	+ 	/* --- if none was at the right level, we can't backtrace at all --- */
	180 	+ 	return NIL;
144 	181 		}
145 	182 		
146 	183 		/* =======================================================================
147 	184 		
148 		- 	Firer Utilities
	185 	+ 	Firer Utilities
149 	186 		
150 		- 	======================================================================= */
	187 	+ 	======================================================================= */
151 	188 		
152 	189 		/* -----------------------------------------------------------------------
153 		- 	Find Match Goal
	190 	+ 	Find Match Goal
154 	191 		
155 		- 	Given an instantiation, this routines looks at the instantiated
156 		- 	conditions to find its match goal. It fills in inst->match_goal and
157 		- 	inst->match_goal_level. If there is a match goal, match_goal is set
158 		- 	to point to the goal identifier. If no goal was matched, match_goal
159 		- 	is set to NIL and match_goal_level is set to ATTRIBUTE_IMPASSE_LEVEL.
160 		- 	----------------------------------------------------------------------- */
	192 	+ 	Given an instantiation, this routines looks at the instantiated
	193 	+ 	conditions to find its match goal. It fills in inst->match_goal and
	194 	+ 	inst->match_goal_level. If there is a match goal, match_goal is set
	195 	+ 	to point to the goal identifier. If no goal was matched, match_goal
	196 	+ 	is set to NIL and match_goal_level is set to ATTRIBUTE_IMPASSE_LEVEL.
	197 	+ 	----------------------------------------------------------------------- */
161 	198 		
162 		- 	void find_match_goal (instantiation *inst) {
163 		- 	Symbol *lowest_goal_so_far;
164 		- 	goal_stack_level lowest_level_so_far;
165 		- 	condition *cond;
166 		- 	Symbol *id;
	199 	+ 	void find_match_goal(instantiation *inst) {
	200 	+ 	Symbol *lowest_goal_so_far;
	201 	+ 	goal_stack_level lowest_level_so_far;
	202 	+ 	condition *cond;
	203 	+ 	Symbol *id;
167 	204 		
168 		- 	lowest_goal_so_far = NIL;
169 		- 	lowest_level_so_far = -1;
170 		- 	for (cond=inst->top_of_instantiated_conditions; cond!=NIL; cond=cond->next)
171 		- 	if (cond->type==POSITIVE_CONDITION) {
172 		- 	id = cond->bt.wme_->id;
173 		- 	if (id->id.isa_goal)
174 		- 	if (cond->bt.level > lowest_level_so_far) {
175 		- 	lowest_goal_so_far = id;
176 		- 	lowest_level_so_far = cond->bt.level;
177 		- 	}
178 		- 	}
	205 	+ 	lowest_goal_so_far = NIL;
	206 	+ 	lowest_level_so_far = -1;
	207 	+ 	for (cond = inst->top_of_instantiated_conditions; cond != NIL;
	208 	+ 	cond = cond->next)
	209 	+ 	if (cond->type == POSITIVE_CONDITION) {
	210 	+ 	id = cond->bt.wme_->id;
	211 	+ 	if (id->id.isa_goal)
	212 	+ 	if (cond->bt.level > lowest_level_so_far) {
	213 	+ 	lowest_goal_so_far = id;
	214 	+ 	lowest_level_so_far = cond->bt.level;
	215 	+ 	}
	216 	+ 	}
179 	217 		
180 		- 	inst->match_goal = lowest_goal_so_far;
181 		- 	if (lowest_goal_so_far)
182 		- 	inst->match_goal_level = lowest_level_so_far;
183 		- 	else
184 		- 	inst->match_goal_level = ATTRIBUTE_IMPASSE_LEVEL;
	218 	+ 	inst->match_goal = lowest_goal_so_far;
	219 	+ 	if (lowest_goal_so_far)
	220 	+ 	inst->match_goal_level = lowest_level_so_far;
	221 	+ 	else
	222 	+ 	inst->match_goal_level = ATTRIBUTE_IMPASSE_LEVEL;
185 	223 		}
186 	224 		
187 	225 		/* -----------------------------------------------------------------------
188 	226 		
189 		- 	Executing the RHS Actions of an Instantiation
	227 	+ 	Executing the RHS Actions of an Instantiation
190 	228 		
191 		- 	Execute_action() executes a given RHS action. For MAKE_ACTION's, it
192 		- 	returns the created preference structure, or NIL if an error occurs.
193 		- 	For FUNCALL_ACTION's, it returns NIL.
	229 	+ 	Execute_action() executes a given RHS action. For MAKE_ACTION's, it
	230 	+ 	returns the created preference structure, or NIL if an error occurs.
	231 	+ 	For FUNCALL_ACTION's, it returns NIL.
194 	232 		
195 		- 	Instantiate_rhs_value() returns the (symbol) instantiation of an
196 		- 	rhs_value, or NIL if an error occurs. It takes a new_id_level
197 		- 	argument indicating what goal_stack_level a new id is to be created
198 		- 	at, in case a gensym is needed for the instantiation of a variable.
199 		- 	(although I'm not sure this is really needed.)
	233 	+ 	Instantiate_rhs_value() returns the (symbol) instantiation of an
	234 	+ 	rhs_value, or NIL if an error occurs. It takes a new_id_level
	235 	+ 	argument indicating what goal_stack_level a new id is to be created
	236 	+ 	at, in case a gensym is needed for the instantiation of a variable.
	237 	+ 	(although I'm not sure this is really needed.)
200 	238 		
201 		- 	As rhs unbound variables are encountered, they are instantiated with
202 		- 	new gensyms. These gensyms are then stored in the rhs_variable_bindings
203 		- 	array, so if the same unbound variable is encountered a second time
204 		- 	it will be instantiated with the same gensym.
205 		- 	----------------------------------------------------------------------- */
	239 	+ 	As rhs unbound variables are encountered, they are instantiated with
	240 	+ 	new gensyms. These gensyms are then stored in the rhs_variable_bindings
	241 	+ 	array, so if the same unbound variable is encountered a second time
	242 	+ 	it will be instantiated with the same gensym.
	243 	+ 	----------------------------------------------------------------------- */
206 	244 		
	245 	+ 	Symbol *instantiate_rhs_value(agent* thisAgent, rhs_value rv,
	246 	+ 	goal_stack_level new_id_level, char new_id_letter,
	247 	+ 	struct token_struct *tok, wme *w) {
	248 	+ 	list *fl;
	249 	+ 	list *arglist;
	250 	+ 	cons *c, *prev_c, *arg_cons;
	251 	+ 	rhs_function *rf;
	252 	+ 	Symbol *result;
	253 	+ 	Bool nil_arg_found;
207 	254 		
208 		- 	Symbol *instantiate_rhs_value (agent* thisAgent, rhs_value rv,
209 		- 	goal_stack_level new_id_level,
210 		- 	char new_id_letter,
211 		- 	struct token_struct *tok, wme *w) {
212 		- 	list *fl;
213 		- 	list *arglist;
214 		- 	cons *c, *prev_c, *arg_cons;
215 		- 	rhs_function *rf;
216 		- 	Symbol *result;
217 		- 	Bool nil_arg_found;
	255 	+ 	if (rhs_value_is_symbol(rv)) {
218 	256 		
219 		- 	if (rhs_value_is_symbol(rv)) {
	257 	+ 	result = rhs_value_to_symbol(rv);
220 	258 		
221 		- 	result = rhs_value_to_symbol(rv);
	259 	+ 	/*
	260 	+ 	Long-Winded Case-by-Case [Hopeful] Explanation
222 	261 		
223 		- 	/*
224 		- 	Long-Winded Case-by-Case [Hopeful] Explanation
	262 	+ 	This has to do with long-term identifiers (LTIs) that exist within productions (including chunks/justifications).
	263 	+ 	The real issue is that identifiers, upon creation, require a goal level (used for promotion/demotion/garbage collection).
	264 	+ 	At the time of parsing a rule, we don't have this information, so we give it an invalid "unknown" value.
	265 	+ 	This is OK on the condition side of a rule, since the rete (we think) will just consider it another symbol used for matching.
	266 	+ 	However, it becomes hairy when LTIs are on the action side of a rule, with respect to the state of the LTI in working memory and the rule LHS.
	267 	+ 	Consider the following cases:
225 	268 		
226 		- 	This has to do with long-term identifiers (LTIs) that exist within productions (including chunks/justifications).
227 		- 	The real issue is that identifiers, upon creation, require a goal level (used for promotion/demotion/garbage collection).
228 		- 	At the time of parsing a rule, we don't have this information, so we give it an invalid "unknown" value.
229 		- 	This is OK on the condition side of a rule, since the rete (we think) will just consider it another symbol used for matching.
230 		- 	However, it becomes hairy when LTIs are on the action side of a rule, with respect to the state of the LTI in working memory and the rule LHS.
231 		- 	Consider the following cases:
	269 	+ 	1. Identifier is LTI, does NOT exist as a LHS symbol
	270 	+ 	- we do NOT support this!!! bad things will likely happen due to potential for adding an identifier to working memory
	271 	+ 	with an unknown goal level.
232 	272 		
233 		- 	1. Identifier is LTI, does NOT exist as a LHS symbol
234 		- 	- we do NOT support this!!! bad things will likely happen due to potential for adding an identifier to working memory
235 		- 	with an unknown goal level.
	273 	+ 	2. Attribute/Value is LTI, does NOT exist as a LHS symbol (!!!!!IMPORTANT CASE!!!!!)
	274 	+ 	- the caller of this function will supply new_id_level (probably based upon the level of the id).
	275 	+ 	- if this is valid (i.e. greater than 0), we use it. else, ignore.
	276 	+ 	- we have a huge assert on add_wme_to_wm that will kill soar if we try to add an identifier to working memory with an invalid level.
236 	277 		
237 		- 	2. Attribute/Value is LTI, does NOT exist as a LHS symbol (!!!!!IMPORTANT CASE!!!!!)
238 		- 	- the caller of this function will supply new_id_level (probably based upon the level of the id).
239 		- 	- if this is valid (i.e. greater than 0), we use it. else, ignore.
240 		- 	- we have a huge assert on add_wme_to_wm that will kill soar if we try to add an identifier to working memory with an invalid level.
	278 	+ 	3. Identifier/Attribute/Value is LTI, DOES exist as LHS symbol
	279 	+ 	- in this situation, we are *guaranteed* that the resulting LTI (since it is in WM) has a valid goal level.
	280 	+ 	- it should be noted that if a value, the level of the LTI may change during promotion/demotion/garbage collection,
	281 	+ 	but this is natural Soar behavior and outside our perview.
241 	282 		
242 		- 	3. Identifier/Attribute/Value is LTI, DOES exist as LHS symbol
243 		- 	- in this situation, we are *guaranteed* that the resulting LTI (since it is in WM) has a valid goal level.
244 		- 	- it should be noted that if a value, the level of the LTI may change during promotion/demotion/garbage collection,
245 		- 	but this is natural Soar behavior and outside our perview.
	283 	+ 	*/
	284 	+ 	if ((result->id.common_symbol_info.symbol_type == IDENTIFIER_SYMBOL_TYPE)
	285 	+ 	&& (result->id.smem_lti != NIL)&&
	286 	+ 	( result->id.level == SMEM_LTI_UNKNOWN_LEVEL ) &&
	287 	+ 	( new_id_level > 0 ) ){
	288 	+ 	result->id.level = new_id_level;
	289 	+ 	result->id.promotion_level = new_id_level;
	290 	+ 	}
246 	291 		
247 		- 	*/
248 		- 	if ( ( result->id.common_symbol_info.symbol_type == IDENTIFIER_SYMBOL_TYPE ) &&
249 		- 	( result->id.smem_lti != NIL ) &&
250 		- 	( result->id.level == SMEM_LTI_UNKNOWN_LEVEL ) &&
251 		- 	( new_id_level > 0 ) )
252 		- 	{
253 		- 	result->id.level = new_id_level;
254 		- 	result->id.promotion_level = new_id_level;
	292 	+ 	symbol_add_ref(result);
	293 	+ 	return result;
255 	294 		}
256 	295 		
257 		- 	symbol_add_ref (result);
258 		- 	return result;
259 		- 	}
260 		- 	
261 		- 	if (rhs_value_is_unboundvar(rv)) {
262 		- 	int64_t index;
263 		- 	Symbol *sym;
	296 	+ 	if (rhs_value_is_unboundvar(rv)) {
	297 	+ 	int64_t index;
	298 	+ 	Symbol *sym;
264 	299 		
265 		- 	index = static_cast<int64_t>(rhs_value_to_unboundvar(rv));
266 		- 	if (thisAgent->firer_highest_rhs_unboundvar_index < index)
267 		- 	thisAgent->firer_highest_rhs_unboundvar_index = index;
268 		- 	sym = *(thisAgent->rhs_variable_bindings+index);
	300 	+ 	index = static_cast<int64_t>(rhs_value_to_unboundvar(rv));
	301 	+ 	if (thisAgent->firer_highest_rhs_unboundvar_index < index)
	302 	+ 	thisAgent->firer_highest_rhs_unboundvar_index = index;
	303 	+ 	sym = *(thisAgent->rhs_variable_bindings + index);
269 	304 		
270 		- 	if (!sym) {
271 		- 	sym = make_new_identifier (thisAgent, new_id_letter, new_id_level);
272 		- 	*(thisAgent->rhs_variable_bindings+index) = sym;
273 		- 	return sym;
274 		- 	} else if (sym->common.symbol_type==VARIABLE_SYMBOL_TYPE) {
275 		- 	new_id_letter = *(sym->var.name + 1);
276 		- 	sym = make_new_identifier (thisAgent, new_id_letter, new_id_level);
277 		- 	*(thisAgent->rhs_variable_bindings+index) = sym;
278 		- 	return sym;
279 		- 	} else {
280 		- 	symbol_add_ref (sym);
281 		- 	return sym;
282 		- 	}
283 		- 	}
	305 	+ 	if (!sym) {
	306 	+ 	sym = make_new_identifier(thisAgent, new_id_letter, new_id_level);
	307 	+ 	*(thisAgent->rhs_variable_bindings + index) = sym;
	308 	+ 	return sym;
	309 	+ 	} else if (sym->common.symbol_type == VARIABLE_SYMBOL_TYPE) {
	310 	+ 	new_id_letter = *(sym->var.name + 1);
	311 	+ 	sym = make_new_identifier(thisAgent, new_id_letter, new_id_level);
	312 	+ 	*(thisAgent->rhs_variable_bindings + index) = sym;
	313 	+ 	return sym;
	314 	+ 	} else {
	315 	+ 	symbol_add_ref(sym);
	316 	+ 	return sym;
	317 	+ 	}
	318 	+ 	}
284 	319 		
285 		- 	if (rhs_value_is_reteloc(rv)) {
286 		- 	result = get_symbol_from_rete_loc (rhs_value_to_reteloc_levels_up(rv),
287 		- 	rhs_value_to_reteloc_field_num(rv),
288 		- 	tok, w);
289 		- 	symbol_add_ref (result);
290 		- 	return result;
291 		- 	}
	320 	+ 	if (rhs_value_is_reteloc(rv)) {
	321 	+ 	result = get_symbol_from_rete_loc(rhs_value_to_reteloc_levels_up(rv),
	322 	+ 	rhs_value_to_reteloc_field_num(rv), tok, w);
	323 	+ 	symbol_add_ref(result);
	324 	+ 	return result;
	325 	+ 	}
292 	326 		
293 		- 	fl = rhs_value_to_funcall_list(rv);
294 		- 	rf = static_cast<rhs_function_struct *>(fl->first);
	327 	+ 	fl = rhs_value_to_funcall_list(rv);
	328 	+ 	rf = static_cast<rhs_function_struct *>(fl->first);
295 	329 		
296 		- 	/* --- build up a list of the argument values --- */
297 		- 	prev_c = NIL;
298 		- 	nil_arg_found = FALSE;
299 		- 	arglist = NIL; /* unnecessary, but gcc -Wall warns without it */
300 		- 	for (arg_cons=fl->rest; arg_cons!=NIL; arg_cons=arg_cons->rest) {
301 		- 	allocate_cons (thisAgent, &c);
302 		- 	c->first = instantiate_rhs_value (thisAgent,
303 		- 	static_cast<char *>(arg_cons->first),
304 		- 	new_id_level, new_id_letter, tok, w);
305 		- 	if (! c->first) nil_arg_found = TRUE;
306 		- 	if (prev_c) prev_c->rest = c; else arglist = c;
307 		- 	prev_c = c;
308 		- 	}
309 		- 	if (prev_c) prev_c->rest = NIL; else arglist = NIL;
	330 	+ 	/* --- build up a list of the argument values --- */
	331 	+ 	prev_c = NIL;
	332 	+ 	nil_arg_found = FALSE;
	333 	+ 	arglist = NIL; /* unnecessary, but gcc -Wall warns without it */
	334 	+ 	for (arg_cons = fl->rest; arg_cons != NIL; arg_cons = arg_cons->rest) {
	335 	+ 	allocate_cons(thisAgent, &c);
	336 	+ 	c->first = instantiate_rhs_value(thisAgent,
	337 	+ 	static_cast<char *>(arg_cons->first), new_id_level,
	338 	+ 	new_id_letter, tok, w);
	339 	+ 	if (!c->first)
	340 	+ 	nil_arg_found = TRUE;
	341 	+ 	if (prev_c)
	342 	+ 	prev_c->rest = c;
	343 	+ 	else
	344 	+ 	arglist = c;
	345 	+ 	prev_c = c;
	346 	+ 	}
	347 	+ 	if (prev_c)
	348 	+ 	prev_c->rest = NIL;
	349 	+ 	else
	350 	+ 	arglist = NIL;
310 	351 		
311 		- 	/* --- if all args were ok, call the function --- */
	352 	+ 	/* --- if all args were ok, call the function --- */
312 	353 		
313 		- 	if (!nil_arg_found) {
314 		- 	// stop the kernel timer while doing RHS funcalls KJC 11/04
315 		- 	// the total_cpu timer needs to be updated in case RHS fun is statsCmd
316 		- 	#ifndef NO_TIMING_STUFF
317 		- 	thisAgent->timers_kernel.stop();
318 		- 	thisAgent->timers_cpu.stop();
319 		- 	thisAgent->timers_total_kernel_time.update(thisAgent->timers_kernel);
320 		- 	thisAgent->timers_total_cpu_time.update(thisAgent->timers_cpu);
321 		- 	thisAgent->timers_cpu.start();
322 		- 	#endif
	354 	+ 	if (!nil_arg_found) {
	355 	+ 	// stop the kernel timer while doing RHS funcalls KJC 11/04
	356 	+ 	// the total_cpu timer needs to be updated in case RHS fun is statsCmd
	357 	+ 	#ifndef NO_TIMING_STUFF
	358 	+ 	thisAgent->timers_kernel.stop();
	359 	+ 	thisAgent->timers_cpu.stop();
	360 	+ 	thisAgent->timers_total_kernel_time.update(thisAgent->timers_kernel);
	361 	+ 	thisAgent->timers_total_cpu_time.update(thisAgent->timers_cpu);
	362 	+ 	thisAgent->timers_cpu.start();
	363 	+ 	#endif
323 	364 		
324 		- 	result = (*(rf->f))(thisAgent, arglist, rf->user_data);
	365 	+ 	result = (*(rf->f))(thisAgent, arglist, rf->user_data);
325 	366 		
326 		- 	#ifndef NO_TIMING_STUFF // restart the kernel timer
327 		- 	thisAgent->timers_kernel.start();
328 		- 	#endif
	367 	+ 	#ifndef NO_TIMING_STUFF // restart the kernel timer
	368 	+ 	thisAgent->timers_kernel.start();
	369 	+ 	#endif
329 	370 		
330 		- 	} else
331 		- 	result = NIL;
	371 	+ 	} else
	372 	+ 	result = NIL;
332 	373 		
333 		- 	/* --- scan through arglist, dereference symbols and deallocate conses --- */
334 		- 	for (c=arglist; c!=NIL; c=c->rest)
335 		- 	if (c->first) symbol_remove_ref (thisAgent, static_cast<Symbol *>(c->first));
336 		- 	free_list (thisAgent, arglist);
	374 	+ 	/* --- scan through arglist, dereference symbols and deallocate conses --- */
	375 	+ 	for (c = arglist; c != NIL; c = c->rest)
	376 	+ 	if (c->first)
	377 	+ 	symbol_remove_ref(thisAgent, static_cast<Symbol *>(c->first));
	378 	+ 	free_list(thisAgent, arglist);
337 	379 		
338 		- 	return result;
	380 	+ 	return result;
339 	381 		}
340 	382 		
341 		- 	preference *execute_action (agent* thisAgent, action *a, struct token_struct *tok, wme *w) {
	383 	+ 	preference *execute_action(agent* thisAgent, action *a,
	384 	+ 	struct token_struct *tok, wme *w) {
342 	385 		Symbol *id, *attr, *value, *referent;
343 	386 		char first_letter;
344 	387 		
345 		- 	if (a->type==FUNCALL_ACTION) {
346 		- 	value = instantiate_rhs_value (thisAgent, a->value, -1, 'v', tok, w);
347 		- 	if (value) symbol_remove_ref (thisAgent, value);
	388 	+ 	if (a->type == FUNCALL_ACTION) {
	389 	+ 	value = instantiate_rhs_value(thisAgent, a->value, -1, 'v', tok, w);
	390 	+ 	if (value)
	391 	+ 	symbol_remove_ref(thisAgent, value);
348 	392 		return NIL;
349 	393 		}
350 	394 		
351 	395 		attr = NIL;
352 	396 		value = NIL;
353 	397 		referent = NIL;
354 	398 		
355 		- 	id = instantiate_rhs_value (thisAgent, a->id, -1, 's', tok, w);
356 		- 	if (!id) goto abort_execute_action;
357 		- 	if (id->common.symbol_type!=IDENTIFIER_SYMBOL_TYPE) {
358 		- 	print_with_symbols (thisAgent, "Error: RHS makes a preference for %y (not an identifier)\n", id);
	399 	+ 	id = instantiate_rhs_value(thisAgent, a->id, -1, 's', tok, w);
	400 	+ 	if (!id)
	401 	+ 	goto abort_execute_action;
	402 	+ 	if (id->common.symbol_type != IDENTIFIER_SYMBOL_TYPE) {
	403 	+ 	print_with_symbols(thisAgent,
	404 	+ 	"Error: RHS makes a preference for %y (not an identifier)\n",
	405 	+ 	id);
359 	406 		goto abort_execute_action;
360 	407 		}
361 	408 		
362 		- 	attr = instantiate_rhs_value (thisAgent, a->attr, id->id.level, 'a', tok, w);
363 		- 	if (!attr) goto abort_execute_action;
	409 	+ 	attr = instantiate_rhs_value(thisAgent, a->attr, id->id.level, 'a', tok, w);
	410 	+ 	if (!attr)
	411 	+ 	goto abort_execute_action;
364 	412 		
365 		- 	first_letter = first_letter_from_symbol (attr);
	413 	+ 	first_letter = first_letter_from_symbol(attr);
366 	414 		
367 		- 	value = instantiate_rhs_value (thisAgent, a->value, id->id.level,
368 		- 	first_letter, tok, w);
369 		- 	if (!value) goto abort_execute_action;
	415 	+ 	value = instantiate_rhs_value(thisAgent, a->value, id->id.level,
	416 	+ 	first_letter, tok, w);
	417 	+ 	if (!value)
	418 	+ 	goto abort_execute_action;
370 	419 		
371 	420 		if (preference_is_binary(a->preference_type)) {
372 		- 	referent = instantiate_rhs_value (thisAgent, a->referent, id->id.level,
373 		- 	first_letter, tok, w);
374 		- 	if (!referent) goto abort_execute_action;
	421 	+ 	referent = instantiate_rhs_value(thisAgent, a->referent, id->id.level,
	422 	+ 	first_letter, tok, w);
	423 	+ 	if (!referent)
	424 	+ 	goto abort_execute_action;
375 	425 		}
376 	426 		
377 		- 	if (((a->preference_type != ACCEPTABLE_PREFERENCE_TYPE) &&
378 		- 	(a->preference_type != REJECT_PREFERENCE_TYPE)) &&
379 		- 	(! (id->id.isa_goal && (attr==thisAgent->operator_symbol)) )) {
380 		- 	print_with_symbols (thisAgent, "\nError: attribute preference other than +/- for %y ^%y -- ignoring it.", id, attr);
381 		- 	goto abort_execute_action;
	427 	+ 	if (((a->preference_type != ACCEPTABLE_PREFERENCE_TYPE)
	428 	+ 	&& (a->preference_type != REJECT_PREFERENCE_TYPE))
	429 	+ 	&& (!(id->id.isa_goal && (attr == thisAgent->operator_symbol)))) {
	430 	+ 	print_with_symbols(thisAgent,
	431 	+ 	"\nError: attribute preference other than +/- for %y ^%y -- ignoring it.",
	432 	+ 	id, attr);
	433 	+ 	goto abort_execute_action;
382 	434 		}
383 	435 		
384 		- 	return make_preference (thisAgent, a->preference_type, id, attr, value, referent);
	436 	+ 	return make_preference(thisAgent, a->preference_type, id, attr, value,
	437 	+ 	referent);
385 	438 		
386 		- 	abort_execute_action: /* control comes here when some error occurred */
387 		- 	if (id) symbol_remove_ref (thisAgent, id);
388 		- 	if (attr) symbol_remove_ref (thisAgent, attr);
389 		- 	if (value) symbol_remove_ref (thisAgent, value);
390 		- 	if (referent) symbol_remove_ref (thisAgent, referent);
	439 	+ 	abort_execute_action: /* control comes here when some error occurred */
	440 	+ 	if (id)
	441 	+ 	symbol_remove_ref(thisAgent, id);
	442 	+ 	if (attr)
	443 	+ 	symbol_remove_ref(thisAgent, attr);
	444 	+ 	if (value)
	445 	+ 	symbol_remove_ref(thisAgent, value);
	446 	+ 	if (referent)
	447 	+ 	symbol_remove_ref(thisAgent, referent);
391 	448 		return NIL;
392 	449 		}
393 	450 		
394 	451 		/* -----------------------------------------------------------------------
395 		- 	Fill In New Instantiation Stuff
	452 	+ 	Fill In New Instantiation Stuff
396 	453 		
397 		- 	This routine fills in a newly created instantiation structure with
398 		- 	various information. At input, the instantiation should have:
399 		- 	- preferences_generated filled in;
400 		- 	- instantiated conditions filled in;
401 		- 	- top-level positive conditions should have bt.wme_, bt.level, and
402 		- 	bt.trace filled in, but bt.wme_ and bt.trace shouldn't have their
403 		- 	reference counts incremented yet.
	454 	+ 	This routine fills in a newly created instantiation structure with
	455 	+ 	various information. At input, the instantiation should have:
	456 	+ 	- preferences_generated filled in;
	457 	+ 	- instantiated conditions filled in;
	458 	+ 	- top-level positive conditions should have bt.wme_, bt.level, and
	459 	+ 	bt.trace filled in, but bt.wme_ and bt.trace shouldn't have their
	460 	+ 	reference counts incremented yet.
404 	461 		
405 		- 	This routine does the following:
406 		- 	- increments reference count on production;
407 		- 	- fills in match_goal and match_goal_level;
408 		- 	- for each top-level positive cond:
409 		- 	replaces bt.trace with the preference for the correct level,
410 		- 	updates reference counts on bt.pref and bt.wmetraces and wmes
411 		- 	- for each preference_generated, adds that pref to the list of all
412 		- 	pref's for the match goal
413 		- 	- fills in backtrace_number;
414 		- 	- if "need_to_do_support_calculations" is TRUE, calculates o-support
415 		- 	for preferences_generated;
416 		- 	----------------------------------------------------------------------- */
	462 	+ 	This routine does the following:
	463 	+ 	- increments reference count on production;
	464 	+ 	- fills in match_goal and match_goal_level;
	465 	+ 	- for each top-level positive cond:
	466 	+ 	replaces bt.trace with the preference for the correct level,
	467 	+ 	updates reference counts on bt.pref and bt.wmetraces and wmes
	468 	+ 	- for each preference_generated, adds that pref to the list of all
	469 	+ 	pref's for the match goal
	470 	+ 	- fills in backtrace_number;
	471 	+ 	- if "need_to_do_support_calculations" is TRUE, calculates o-support
	472 	+ 	for preferences_generated;
	473 	+ 	----------------------------------------------------------------------- */
417 	474 		
418 		- 	void fill_in_new_instantiation_stuff (agent* thisAgent, instantiation *inst,
419 		- 	Bool need_to_do_support_calculations) {
420 		- 	condition *cond;
421 		- 	preference *p;
422 		- 	goal_stack_level level;
	475 	+ 	void fill_in_new_instantiation_stuff(agent* thisAgent, instantiation *inst,
	476 	+ 	Bool need_to_do_support_calculations) {
	477 	+ 	condition *cond;
	478 	+ 	preference *p;
	479 	+ 	goal_stack_level level;
423 	480 		
424 		- 	production_add_ref (inst->prod);
	481 	+ 	production_add_ref(inst->prod);
425 	482 		
426 		- 	find_match_goal (inst);
	483 	+ 	find_match_goal(inst);
427 	484 		
428 		- 	level = inst->match_goal_level;
	485 	+ 	level = inst->match_goal_level;
429 	486 		
430 		- 	/* Note: since we'll never backtrace through instantiations at the top
431 		- 	level, it might make sense to not increment the reference counts
432 		- 	on the wmes and preferences here if the instantiation is at the top
433 		- 	level. As it stands now, we could gradually accumulate garbage at
434 		- 	the top level if we have a never-ending sequence of production
435 		- 	firings at the top level that chain on each other's results. (E.g.,
436 		- 	incrementing a counter on every decision cycle.) I'm leaving it this
437 		- 	way for now, because if we go to S-Support, we'll (I think) need to
438 		- 	save these around (maybe). */
	487 	+ 	/* Note: since we'll never backtrace through instantiations at the top
	488 	+ 	level, it might make sense to not increment the reference counts
	489 	+ 	on the wmes and preferences here if the instantiation is at the top
	490 	+ 	level. As it stands now, we could gradually accumulate garbage at
	491 	+ 	the top level if we have a never-ending sequence of production
	492 	+ 	firings at the top level that chain on each other's results. (E.g.,
	493 	+ 	incrementing a counter on every decision cycle.) I'm leaving it this
	494 	+ 	way for now, because if we go to S-Support, we'll (I think) need to
	495 	+ 	save these around (maybe). */
439 	496 		
440 		- 	/* KJC 6/00: maintaining all the top level ref cts does have a big
441 		- 	impact on memory pool usage and also performance (due to malloc).
	497 	+ 	/* KJC 6/00: maintaining all the top level ref cts does have a big
	498 	+ 	impact on memory pool usage and also performance (due to malloc).
442 	499 		(See tests done by Scott Wallace Fall 99.) Therefore added
443 	500 		preprocessor macro so that by unsetting macro the top level ref cts are not
444 	501 		incremented. It's possible that in some systems, these ref cts may
445 	502 		be desireable: they can be added by defining DO_TOP_LEVEL_REF_CTS
446 	503 		*/
447 	504 		
448 		- 	for (cond=inst->top_of_instantiated_conditions; cond!=NIL; cond=cond->next)
449 		- 	if (cond->type==POSITIVE_CONDITION) {
450 		- 	#ifdef DO_TOP_LEVEL_REF_CTS
451 		- 	wme_add_ref (cond->bt.wme_);
452 		- 	#else
453 		- 	if (level > TOP_GOAL_LEVEL) wme_add_ref (cond->bt.wme_);
454 		- 	#endif
455 		- 	/* --- if trace is for a lower level, find one for this level --- */
456 		- 	if (cond->bt.trace) {
457 		- 	if (cond->bt.trace->inst->match_goal_level > level) {
458 		- 	cond->bt.trace = find_clone_for_level (cond->bt.trace, level);
	505 	+ 	for (cond = inst->top_of_instantiated_conditions; cond != NIL;
	506 	+ 	cond = cond->next)
	507 	+ 	if (cond->type == POSITIVE_CONDITION) {
	508 	+ 	#ifdef DO_TOP_LEVEL_REF_CTS
	509 	+ 	wme_add_ref (cond->bt.wme_);
	510 	+ 	#else
	511 	+ 	if (level > TOP_GOAL_LEVEL)
	512 	+ 	wme_add_ref(cond->bt.wme_);
	513 	+ 	#endif
	514 	+ 	/* --- if trace is for a lower level, find one for this level --- */
	515 	+ 	if (cond->bt.trace) {
	516 	+ 	if (cond->bt.trace->inst->match_goal_level > level) {
	517 	+ 	cond->bt.trace = find_clone_for_level(cond->bt.trace,
	518 	+ 	level);
	519 	+ 	}
	520 	+ 	#ifdef DO_TOP_LEVEL_REF_CTS
	521 	+ 	if (cond->bt.trace) preference_add_ref (cond->bt.trace);
	522 	+ 	#else
	523 	+ 	if ((cond->bt.trace) && (level > TOP_GOAL_LEVEL))
	524 	+ 	preference_add_ref(cond->bt.trace);
	525 	+ 	#endif
	526 	+ 	}
459 	527 		}
460 		- 	#ifdef DO_TOP_LEVEL_REF_CTS
461 		- 	if (cond->bt.trace) preference_add_ref (cond->bt.trace);
462 		- 	#else
463 		- 	if ((cond->bt.trace) && (level > TOP_GOAL_LEVEL))
464 		- 	preference_add_ref (cond->bt.trace);
465 		- 	#endif
466 		- 	}
467 		- 	}
468 	528 		
	529 	+ 	if (inst->match_goal) {
	530 	+ 	for (p = inst->preferences_generated; p != NIL; p = p->inst_next) {
	531 	+ 	insert_at_head_of_dll(inst->match_goal->id.preferences_from_goal, p,
	532 	+ 	all_of_goal_next, all_of_goal_prev);
	533 	+ 	p->on_goal_list = TRUE;
	534 	+ 	}
	535 	+ 	}
	536 	+ 	inst->backtrace_number = 0;
469 	537 		
470 		- 	
471 		- 	if (inst->match_goal) {
472 		- 	for (p=inst->preferences_generated; p!=NIL; p=p->inst_next) {
473 		- 	insert_at_head_of_dll (inst->match_goal->id.preferences_from_goal, p,
474 		- 	all_of_goal_next, all_of_goal_prev);
475 		- 	p->on_goal_list = TRUE;
476 		- 	}
477 		- 	}
478 		- 	inst->backtrace_number = 0;
479 		- 	
480 		- 	if ((thisAgent->o_support_calculation_type == 0) ||
481 		- 	(thisAgent->o_support_calculation_type == 3) ||
482 		- 	(thisAgent->o_support_calculation_type == 4)) {
483 		- 	/* --- do calc's the normal Soar 6 way --- */
484 		- 	if (need_to_do_support_calculations)
485 		- 	calculate_support_for_instantiation_preferences (thisAgent, inst);
486 		- 	} else if (thisAgent->o_support_calculation_type == 1) {
487 		- 	if (need_to_do_support_calculations)
488 		- 	calculate_support_for_instantiation_preferences (thisAgent, inst);
489 		- 	/* --- do calc's both ways, warn on differences --- */
490 		- 	if ((inst->prod->declared_support!=DECLARED_O_SUPPORT) &&
491 		- 	(inst->prod->declared_support!=DECLARED_I_SUPPORT)) {
492 		- 	/* --- At this point, we've done them the normal way. To look for
493 		- 	differences, save o-support flags on a list, then do Doug's
494 		- 	calculations, then compare and restore saved flags. --- */
495 		- 	list *saved_flags;
496 		- 	preference *pref;
497 		- 	Bool difference_found;
498 		- 	saved_flags = NIL;
499 		- 	for (pref=inst->preferences_generated; pref!=NIL; pref=pref->inst_next)
500 		- 	push (thisAgent, (pref->o_supported ? pref : NIL), saved_flags);
501 		- 	saved_flags = destructively_reverse_list (saved_flags);
502 		- 	dougs_calculate_support_for_instantiation_preferences (thisAgent, inst);
503 		- 	difference_found = FALSE;
504 		- 	for (pref=inst->preferences_generated; pref!=NIL; pref=pref->inst_next){
505 		- 	cons *c; Bool b;
506 		- 	c = saved_flags; saved_flags = c->rest;
507 		- 	b = (c->first ? TRUE : FALSE); free_cons (thisAgent, c);
508 		- 	if (pref->o_supported != b) difference_found = TRUE;
509 		- 	pref->o_supported = b;
510 		- 	}
511 		- 	if (difference_found) {
512 		- 	print_with_symbols(thisAgent, "\n*** O-support difference found in production %y",
513 		- 	inst->prod->name);
514 		- 	}
515 		- 	}
516 		- 	}
517 		- 	else {
518 		- 	/* --- do calc's Doug's way --- */
519 		- 	if ((inst->prod->declared_support!=DECLARED_O_SUPPORT) &&
520 		- 	(inst->prod->declared_support!=DECLARED_I_SUPPORT)) {
521 		- 	dougs_calculate_support_for_instantiation_preferences (thisAgent, inst);
522 		- 	}
523 		- 	}
	538 	+ 	if ((thisAgent->o_support_calculation_type == 0)
	539 	+ 	|| (thisAgent->o_support_calculation_type == 3)
	540 	+ 	|| (thisAgent->o_support_calculation_type == 4)) {
	541 	+ 	/* --- do calc's the normal Soar 6 way --- */
	542 	+ 	if (need_to_do_support_calculations)
	543 	+ 	calculate_support_for_instantiation_preferences(thisAgent, inst);
	544 	+ 	} else if (thisAgent->o_support_calculation_type == 1) {
	545 	+ 	if (need_to_do_support_calculations)
	546 	+ 	calculate_support_for_instantiation_preferences(thisAgent, inst);
	547 	+ 	/* --- do calc's both ways, warn on differences --- */
	548 	+ 	if ((inst->prod->declared_support != DECLARED_O_SUPPORT)
	549 	+ 	&& (inst->prod->declared_support != DECLARED_I_SUPPORT)) {
	550 	+ 	/* --- At this point, we've done them the normal way. To look for
	551 	+ 	differences, save o-support flags on a list, then do Doug's
	552 	+ 	calculations, then compare and restore saved flags. --- */
	553 	+ 	list *saved_flags;
	554 	+ 	preference *pref;
	555 	+ 	Bool difference_found;
	556 	+ 	saved_flags = NIL;
	557 	+ 	for (pref = inst->preferences_generated; pref != NIL;
	558 	+ 	pref = pref->inst_next)
	559 	+ 	push(thisAgent, (pref->o_supported ? pref : NIL), saved_flags);
	560 	+ 	saved_flags = destructively_reverse_list(saved_flags);
	561 	+ 	dougs_calculate_support_for_instantiation_preferences(thisAgent,
	562 	+ 	inst);
	563 	+ 	difference_found = FALSE;
	564 	+ 	for (pref = inst->preferences_generated; pref != NIL;
	565 	+ 	pref = pref->inst_next) {
	566 	+ 	cons *c;
	567 	+ 	Bool b;
	568 	+ 	c = saved_flags;
	569 	+ 	saved_flags = c->rest;
	570 	+ 	b = (c->first ? TRUE : FALSE);
	571 	+ 	free_cons(thisAgent, c);
	572 	+ 	if (pref->o_supported != b)
	573 	+ 	difference_found = TRUE;
	574 	+ 	pref->o_supported = b;
	575 	+ 	}
	576 	+ 	if (difference_found) {
	577 	+ 	print_with_symbols(thisAgent,
	578 	+ 	"\n*** O-support difference found in production %y",
	579 	+ 	inst->prod->name);
	580 	+ 	}
	581 	+ 	}
	582 	+ 	} else {
	583 	+ 	/* --- do calc's Doug's way --- */
	584 	+ 	if ((inst->prod->declared_support != DECLARED_O_SUPPORT)
	585 	+ 	&& (inst->prod->declared_support != DECLARED_I_SUPPORT)) {
	586 	+ 	dougs_calculate_support_for_instantiation_preferences(thisAgent,
	587 	+ 	inst);
	588 	+ 	}
	589 	+ 	}
524 	590 		}
525 	591 		
526 	592 		/* =======================================================================
527 	593 		
528 		- 	Main Firer Routines
	594 	+ 	Main Firer Routines
529 	595 		
530 		- 	Init_firer() should be called at startup time. Do_preference_phase()
531 		- 	is called from the top level to run the whole preference phase.
	596 	+ 	Init_firer() should be called at startup time. Do_preference_phase()
	597 	+ 	is called from the top level to run the whole preference phase.
532 	598 		
533 		- 	Preference phase follows this sequence:
	599 	+ 	Preference phase follows this sequence:
534 	600 		
535 		- 	(1) Productions are fired for new matches. As productions are fired,
536 		- 	their instantiations are stored on the list newly_created_instantiations,
537 		- 	linked via the "next" fields in the instantiation structure. No
538 		- 	preferences are actually asserted yet.
	601 	+ 	(1) Productions are fired for new matches. As productions are fired,
	602 	+ 	their instantiations are stored on the list newly_created_instantiations,
	603 	+ 	linked via the "next" fields in the instantiation structure. No
	604 	+ 	preferences are actually asserted yet.
539 	605 		
540 		- 	(2) Instantiations are retracted; their preferences are retracted.
	606 	+ 	(2) Instantiations are retracted; their preferences are retracted.
541 	607 		
542 		- 	(3) Preferences (except o-rejects) from newly_created_instantiations
543 		- 	are asserted, and these instantiations are removed from the
544 		- 	newly_created_instantiations list and moved over to the per-production
545 		- 	lists of instantiations of that production.
	608 	+ 	(3) Preferences (except o-rejects) from newly_created_instantiations
	609 	+ 	are asserted, and these instantiations are removed from the
	610 	+ 	newly_created_instantiations list and moved over to the per-production
	611 	+ 	lists of instantiations of that production.
546 	612 		
547 		- 	(4) Finally, o-rejects are processed.
	613 	+ 	(4) Finally, o-rejects are processed.
548 	614 		
549 		- 	Note: Using the O_REJECTS_FIRST flag, step (4) becomes step (2b)
550 		- 	======================================================================= */
	615 	+ 	Note: Using the O_REJECTS_FIRST flag, step (4) becomes step (2b)
	616 	+ 	======================================================================= */
551 	617 		
552 		- 	void init_firer (agent* thisAgent) {
553 		- 	init_memory_pool (thisAgent, &thisAgent->instantiation_pool, sizeof(instantiation),
554 		- 	"instantiation");
	618 	+ 	void init_firer(agent* thisAgent) {
	619 	+ 	init_memory_pool(thisAgent, &thisAgent->instantiation_pool,
	620 	+ 	sizeof(instantiation), "instantiation");
555 	621 		}
556 	622 		
557 	623 		/* --- Macro returning TRUE iff we're supposed to trace firings for the
558 		- 	given instantiation, which should have the "prod" field filled in. --- */
	624 	+ 	given instantiation, which should have the "prod" field filled in. --- */
559 	625 		#ifdef USE_MACROS
560 	626 		#define trace_firings_of_inst(thisAgent, inst) \
561 	627 		((inst)->prod && \
562 	628 		(thisAgent->sysparams[TRACE_FIRINGS_OF_USER_PRODS_SYSPARAM+(inst)->prod->type] || \
563 	629 		((inst)->prod->trace_firings)))
564 	630 		#else
565 		- 	inline Bool trace_firings_of_inst(agent* thisAgent, instantiation * inst)
566 		- 	{
567 		- 	return ((inst)->prod &&
568 		- 	(thisAgent->sysparams[TRACE_FIRINGS_OF_USER_PRODS_SYSPARAM+(inst)->prod->type] ||
569 		- 	((inst)->prod->trace_firings)));
	631 	+ 	inline Bool trace_firings_of_inst(agent* thisAgent, instantiation * inst) {
	632 	+ 	return ((inst)->prod
	633 	+ 	&& (thisAgent->sysparams[TRACE_FIRINGS_OF_USER_PRODS_SYSPARAM
	634 	+ 	+ (inst)->prod->type] || ((inst)->prod->trace_firings)));
570 	635 		}
571 	636 		#endif
572 	637 		
573 	638 		/* -----------------------------------------------------------------------
574 		- 	Create Instantiation
	639 	+ 	Create Instantiation
575 	640 		
576 		- 	This builds the instantiation for a new match, and adds it to
577 		- 	newly_created_instantiations. It also calls chunk_instantiation() to
578 		- 	do any necessary chunk or justification building.
579 		- 	----------------------------------------------------------------------- */
	641 	+ 	This builds the instantiation for a new match, and adds it to
	642 	+ 	newly_created_instantiations. It also calls chunk_instantiation() to
	643 	+ 	do any necessary chunk or justification building.
	644 	+ 	----------------------------------------------------------------------- */
580 	645 		
581 		- 	void create_instantiation (agent* thisAgent, production *prod, struct token_struct *tok, wme *w) {
	646 	+ 	void create_instantiation(agent* thisAgent, production *prod,
	647 	+ 	struct token_struct *tok, wme *w) {
582 	648 		instantiation *inst;
583 	649 		condition *cond;
584 	650 		preference *pref;
... 			
598 	664 		//}
599 	665 		#endif
600 	666 		
601 		- 	allocate_with_pool (thisAgent, &thisAgent->instantiation_pool, &inst);
	667 	+ 	allocate_with_pool(thisAgent, &thisAgent->instantiation_pool, &inst);
602 	668 		inst->next = thisAgent->newly_created_instantiations;
603 	669 		thisAgent->newly_created_instantiations = inst;
604 	670 		inst->prod = prod;
... 			
609 	675 		
610 	676 		/* REW: begin 09.15.96 */
611 	677 		/* We want to initialize the GDS_evaluated_already flag
612 		- 	* when a new instantiation is created.
613 		- 	*/
	678 	+ 	* when a new instantiation is created.
	679 	+ 	*/
614 	680 		
615 	681 		inst->GDS_evaluated_already = FALSE;
616 	682 		
617 	683 		if (thisAgent->soar_verbose_flag == TRUE) {
618 	684 		print_with_symbols(thisAgent, "\n in create_instantiation: %y",
619 		- 	inst->prod->name);
	685 	+ 	inst->prod->name);
620 	686 		char buf[256];
621 		- 	SNPRINTF(buf, 254, "in create_instantiation: %s", symbol_to_string(thisAgent, inst->prod->name, true, 0, 0));
	687 	+ 	SNPRINTF(buf, 254, "in create_instantiation: %s",
	688 	+ 	symbol_to_string(thisAgent, inst->prod->name, true, 0, 0));
622 	689 		xml_generate_verbose(thisAgent, buf);
623 	690 		}
624 	691 		/* REW: end 09.15.96 */
625 	692 		
626 		- 	
627 	693 		thisAgent->production_being_fired = inst->prod;
628 	694 		prod->firing_count++;
629 	695 		thisAgent->production_firing_count++;
630 	696 		
631 	697 		/* --- build the instantiated conditions, and bind LHS variables --- */
632 		- 	p_node_to_conditions_and_nots (thisAgent, prod->p_node, tok, w,
633 		- 	&(inst->top_of_instantiated_conditions),
634 		- 	&(inst->bottom_of_instantiated_conditions),
635 		- 	&(inst->nots), NIL);
	698 	+ 	p_node_to_conditions_and_nots(thisAgent, prod->p_node, tok, w,
	699 	+ 	&(inst->top_of_instantiated_conditions),
	700 	+ 	&(inst->bottom_of_instantiated_conditions), &(inst->nots), NIL);
636 	701 		
637 	702 		/* --- record the level of each of the wmes that was positively tested --- */
638 		- 	for (cond=inst->top_of_instantiated_conditions; cond!=NIL; cond=cond->next) {
639 		- 	if (cond->type==POSITIVE_CONDITION) {
	703 	+ 	for (cond = inst->top_of_instantiated_conditions; cond != NIL;
	704 	+ 	cond = cond->next) {
	705 	+ 	if (cond->type == POSITIVE_CONDITION) {
640 	706 		cond->bt.level = cond->bt.wme_->id->id.level;
641 	707 		cond->bt.trace = cond->bt.wme_->preference;
642 	708 		}
643 	709 		}
644 	710 		
645 	711 		/* --- print trace info --- */
646 		- 	trace_it = trace_firings_of_inst (thisAgent, inst);
	712 	+ 	trace_it = trace_firings_of_inst(thisAgent, inst);
647 	713 		if (trace_it) {
648 		- 	if (get_printer_output_column(thisAgent)!=1) print (thisAgent, "\n"); /* AGR 617/634 */
649 		- 	print (thisAgent, "Firing ");
650 		- 	print_instantiation_with_wmes
651 		- 	(thisAgent, inst,
652 		- 	static_cast<wme_trace_type>(thisAgent->sysparams[TRACE_FIRINGS_WME_TRACE_TYPE_SYSPARAM]), 0);
	714 	+ 	if (get_printer_output_column(thisAgent) != 1)
	715 	+ 	print(thisAgent, "\n"); /* AGR 617/634 */
	716 	+ 	print(thisAgent, "Firing ");
	717 	+ 	print_instantiation_with_wmes(thisAgent, inst,
	718 	+ 	static_cast<wme_trace_type>(thisAgent->sysparams[TRACE_FIRINGS_WME_TRACE_TYPE_SYSPARAM]),
	719 	+ 	0);
653 	720 		}
654 	721 		
655 	722 		/* --- initialize rhs_variable_bindings array with names of variables
656 		- 	(if there are any stored on the production -- for chunks there won't
657 		- 	be any) --- */
	723 	+ 	(if there are any stored on the production -- for chunks there won't
	724 	+ 	be any) --- */
658 	725 		index = 0;
659 	726 		cell = thisAgent->rhs_variable_bindings;
660 		- 	for (c=prod->rhs_unbound_variables; c!=NIL; c=c->rest) {
	727 	+ 	for (c = prod->rhs_unbound_variables; c != NIL; c = c->rest) {
661 	728 		*(cell++) = static_cast<symbol_union *>(c->first);
662 	729 		index++;
663 	730 		}
... 			
667 	734 		/* --- Before executing the RHS actions, tell the user that the -- */
668 	735 		/* --- phase has changed to output by printing the arrow --- */
669 	736 		if (trace_it && thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
670 		- 	print (thisAgent, " -->\n");
671 		- 	xml_object( thisAgent, kTagActionSideMarker );
	737 	+ 	print(thisAgent, " -->\n");
	738 	+ 	xml_object(thisAgent, kTagActionSideMarker);
672 	739 		}
673 	740 		
674 	741 		/* --- execute the RHS actions, collect the results --- */
675 	742 		inst->preferences_generated = NIL;
676 	743 		need_to_do_support_calculations = FALSE;
677 		- 	for (a=prod->action_list; a!=NIL; a=a->next) {
	744 	+ 	for (a = prod->action_list; a != NIL; a = a->next) {
678 	745 		
679 		- 	if ( prod->type != TEMPLATE_PRODUCTION_TYPE )
680 		- 	{
681 		- 	pref = execute_action (thisAgent, a, tok, w);
682 		- 	}
683 		- 	else
684 		- 	{
	746 	+ 	if (prod->type != TEMPLATE_PRODUCTION_TYPE) {
	747 	+ 	pref = execute_action(thisAgent, a, tok, w);
	748 	+ 	} else {
685 	749 		pref = NIL;
686 		- 	/*Symbol *result = */rl_build_template_instantiation( thisAgent, inst, tok, w );
	750 	+ 	/*Symbol *result = */rl_build_template_instantiation(thisAgent,
	751 	+ 	inst, tok, w);
687 	752 		}
688 	753 		
689 	754 		/* SoarTech changed from an IF stmt to a WHILE loop to support GlobalDeepCpy */
690 	755 		while (pref) {
691 		- 	/* The parser assumes that any rhs preference of the form
692 		- 	*
693 		- 	* (<s> ^operator <o> = <x>)
694 		- 	*
695 		- 	* is a binary indifferent preference, because it assumes <x> is an
696 		- 	* operator. However, it could be the case that <x> is actually bound to
697 		- 	* a number, which would make this a numeric indifferent preference. The
698 		- 	* parser had no way of easily figuring this out, but it's easy to check
699 		- 	* here.
700 		- 	*
701 		- 	* jzxu April 22, 2009
702 		- 	*/
703 		- 	if ((pref->type == BINARY_INDIFFERENT_PREFERENCE_TYPE) &&
704 		- 	((pref->referent->var.common_symbol_info.symbol_type == FLOAT_CONSTANT_SYMBOL_TYPE) ||
705 		- 	(pref->referent->var.common_symbol_info.symbol_type == INT_CONSTANT_SYMBOL_TYPE)))
706 		- 	{
707 		- 	pref->type = NUMERIC_INDIFFERENT_PREFERENCE_TYPE;
708 		- 	}
	756 	+ 	/* The parser assumes that any rhs preference of the form
	757 	+ 	*
	758 	+ 	* (<s> ^operator <o> = <x>)
	759 	+ 	*
	760 	+ 	* is a binary indifferent preference, because it assumes <x> is an
	761 	+ 	* operator. However, it could be the case that <x> is actually bound to
	762 	+ 	* a number, which would make this a numeric indifferent preference. The
	763 	+ 	* parser had no way of easily figuring this out, but it's easy to check
	764 	+ 	* here.
	765 	+ 	*
	766 	+ 	* jzxu April 22, 2009
	767 	+ 	*/
	768 	+ 	if ((pref->type == BINARY_INDIFFERENT_PREFERENCE_TYPE)
	769 	+ 	&& ((pref->referent->var.common_symbol_info.symbol_type
	770 	+ 	== FLOAT_CONSTANT_SYMBOL_TYPE)
	771 	+ 	|| (pref->referent->var.common_symbol_info.symbol_type
	772 	+ 	== INT_CONSTANT_SYMBOL_TYPE))) {
	773 	+ 	pref->type = NUMERIC_INDIFFERENT_PREFERENCE_TYPE;
	774 	+ 	}
709 	775 		
710 	776 		pref->inst = inst;
711 		- 	insert_at_head_of_dll (inst->preferences_generated, pref,
712 		- 	inst_next, inst_prev);
713 		- 	if (inst->prod->declared_support==DECLARED_O_SUPPORT)
	777 	+ 	insert_at_head_of_dll(inst->preferences_generated, pref, inst_next,
	778 	+ 	inst_prev);
	779 	+ 	if (inst->prod->declared_support == DECLARED_O_SUPPORT)
714 	780 		pref->o_supported = TRUE;
715 		- 	else if (inst->prod->declared_support==DECLARED_I_SUPPORT)
716 		- 	{
	781 	+ 	else if (inst->prod->declared_support == DECLARED_I_SUPPORT) {
717 	782 		pref->o_supported = FALSE;
718 		- 	}
719 		- 	else {
	783 	+ 	} else {
720 	784 		
721 	785 		pref->o_supported =
722 		- 	(thisAgent->FIRING_TYPE == PE_PRODS) ? TRUE : FALSE;
	786 	+ 	(thisAgent->FIRING_TYPE == PE_PRODS) ? TRUE : FALSE;
723 	787 		/* REW: end 09.15.96 */
724 	788 		}
725 	789 		

# end irrelevant whitespace changes
# minor comment typo fix

726 	790 		/* TEMPORARY HACK (Ideally this should be doable through
727 		- 	the external kernel interface but for now using a
728 		- 	couple of global STL lists to get this information
729 		- 	from the rhs function to this prefference adding code)
	791 	+ 	the external kernel interface but for now using a
	792 	+ 	couple of global STL lists to get this information
	793 	+ 	from the rhs function to this preference adding code)
730 	794 		
731 		- 	Getting the next pref from the set of possible prefs
732 		- 	added by the deep copy rhs function */

# start irrelevant whitespace changes

733 		- 	if ( glbDeepCopyWMEs != 0 ) {
	795 	+ 	Getting the next pref from the set of possible prefs
	796 	+ 	added by the deep copy rhs function */
	797 	+ 	if (glbDeepCopyWMEs != 0) {
734 	798 		wme* tempwme = glbDeepCopyWMEs;
735 		- 	pref = make_preference(thisAgent,
736 		- 	a->preference_type,
737 		- 	tempwme->id,
738 		- 	tempwme->attr,
739 		- 	tempwme->value, 0);
	799 	+ 	pref = make_preference(thisAgent, a->preference_type,
	800 	+ 	tempwme->id, tempwme->attr, tempwme->value, 0);
740 	801 		glbDeepCopyWMEs = tempwme->next;
741 	802 		deallocate_wme(thisAgent, tempwme);
742 	803 		} else {
... 			
748 	809 		/* --- reset rhs_variable_bindings array to all zeros --- */
749 	810 		index = 0;
750 	811 		cell = thisAgent->rhs_variable_bindings;
751 		- 	while (index++ <= thisAgent->firer_highest_rhs_unboundvar_index) *(cell++) = NIL;
	812 	+ 	while (index++ <= thisAgent->firer_highest_rhs_unboundvar_index)
	813 	+ 	*(cell++) = NIL;
752 	814 		
753 	815 		/* --- fill in lots of other stuff --- */
754 		- 	fill_in_new_instantiation_stuff (thisAgent, inst, need_to_do_support_calculations);
	816 	+ 	fill_in_new_instantiation_stuff(thisAgent, inst,
	817 	+ 	need_to_do_support_calculations);
755 	818 		
756 	819 		/* --- print trace info: printing preferences --- */
757 	820 		/* Note: can't move this up, since fill_in_new_instantiation_stuff gives
758 		- 	the o-support info for the preferences we're about to print */
	821 	+ 	the o-support info for the preferences we're about to print */
759 	822 		if (trace_it && thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
760 		- 	for (pref=inst->preferences_generated; pref!=NIL; pref=pref->inst_next) {
761 		- 	print (thisAgent, " ");
762 		- 	print_preference (thisAgent, pref);
	823 	+ 	for (pref = inst->preferences_generated; pref != NIL;
	824 	+ 	pref = pref->inst_next) {
	825 	+ 	print(thisAgent, " ");
	826 	+ 	print_preference(thisAgent, pref);
763 	827 		}
764 	828 		}
765 	829 	

# end irrelevant whitespace changes
# replace call to build_prohibits_list() with call to build_CDPS()
	
766 		- 	/* mvp 5-17-94 */
767 		- 	build_prohibits_list (thisAgent, inst);
	830 	+ 	/* Copy any context-dependent preferences for conditions of this instantiation */
	831 	+ 	build_CDPS(thisAgent, inst);
768 	832 		

# start irrelevant whitespace changes

769 	833 		thisAgent->production_being_fired = NIL;
770 	834 		
771 	835 		/* --- build chunks/justifications if necessary --- */
772 		- 	chunk_instantiation (thisAgent, inst, false, &(thisAgent->newly_created_instantiations));
	836 	+ 	chunk_instantiation(thisAgent, inst, false,
	837 	+ 	&(thisAgent->newly_created_instantiations));
773 	838 		
774 	839 		/* MVP 6-8-94 */
775 	840 		if (!thisAgent->system_halted) {
776 	841 		/* --- invoke callback function --- */
777 		- 	soar_invoke_callbacks(thisAgent,
778 		- 	FIRING_CALLBACK,
779 		- 	static_cast<soar_call_data>(inst));
	842 	+ 	soar_invoke_callbacks(thisAgent, FIRING_CALLBACK,
	843 	+ 	static_cast<soar_call_data>(inst));
780 	844 		
781 	845 		}
782 	846 		}
... 			
786 	850 		* Returns true if the function create_instantiation should run for this production.
787 	851 		* Used to delay firing of matches in the inner preference loop.
788 	852 		*/
789 		- 	Bool shouldCreateInstantiation (agent* thisAgent, production *prod, struct token_struct *tok, wme *w)
790 		- 	{
	853 	+ 	Bool shouldCreateInstantiation(agent* thisAgent, production *prod,
	854 	+ 	struct token_struct *tok, wme *w) {
791 	855 		if (thisAgent->active_level == thisAgent->highest_active_level) {
792 	856 		return TRUE;
793 	857 		}
... 			
797 	861 		}
798 	862 		
799 	863 		// Scan RHS identifiers for their levels, don't fire those at or higher than the change level
800 		- 	action* a = NIL;
801 		- 	for (a=prod->action_list; a!=NIL; a=a->next) {
802 		- 	if (a->type==FUNCALL_ACTION) {
	864 	+ 	action* a = NIL;
	865 	+ 	for (a = prod->action_list; a != NIL; a = a->next) {
	866 	+ 	if (a->type == FUNCALL_ACTION) {
803 	867 		continue;
804 	868 		}
805 	869 		
... 			
814 	878 		sym = rhs_value_to_symbol(a->id);
815 	879 		} else {
816 	880 		if (rhs_value_is_reteloc(a->id)) {
817 		- 	sym = get_symbol_from_rete_loc (rhs_value_to_reteloc_levels_up(a->id),
818 		- 	rhs_value_to_reteloc_field_num(a->id),
819 		- 	tok, w);
	881 	+ 	sym = get_symbol_from_rete_loc(
	882 	+ 	rhs_value_to_reteloc_levels_up(a->id),
	883 	+ 	rhs_value_to_reteloc_field_num(a->id), tok, w);
820 	884 		}
821 	885 		}
822 	886 		assert(sym != NIL);
823 	887 		
824 	888 		// check level for legal change
825 	889 		if (sym->id.level <= thisAgent->change_level) {
826 	890 		if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
827 		- 	print_with_symbols(thisAgent, "*** Waterfall: aborting firing because (%y * *)", sym);
828 		- 	print(thisAgent, " level %d is on or higher (lower int) than change level %d\n", sym->id.level, thisAgent->change_level);
	891 	+ 	print_with_symbols(thisAgent,
	892 	+ 	"*** Waterfall: aborting firing because (%y * *)", sym);
	893 	+ 	print(thisAgent,
	894 	+ 	" level %d is on or higher (lower int) than change level %d\n",
	895 	+ 	sym->id.level, thisAgent->change_level);
829 	896 		}
830 	897 		return FALSE;
831 	898 		}
832 	899 		}
833 	900 		return TRUE;
834 	901 		}
835 	902 		/* -----------------------------------------------------------------------
836 		- 	Deallocate Instantiation
	903 	+ 	Deallocate Instantiation
837 	904 		
838 		- 	This deallocates the given instantiation. This should only be invoked
839 		- 	via the possibly_deallocate_instantiation() macro.
840 		- 	----------------------------------------------------------------------- */
	905 	+ 	This deallocates the given instantiation. This should only be invoked
	906 	+ 	via the possibly_deallocate_instantiation() macro.
	907 	+ 	----------------------------------------------------------------------- */
841 	908 		
842 		- 	void deallocate_instantiation (agent* thisAgent, instantiation *inst)
843 		- 	{
	909 	+ 	void deallocate_instantiation(agent* thisAgent, instantiation *inst) {
844 	910 		condition *cond;
845 	911 		
846 	912 		/* mvp 5-17-94 */
... 			
849 	915 		goal_stack_level level;
850 	916 		
851 	917 		#ifdef USE_MEM_POOL_ALLOCATORS
852 		- 	cond_mpool_list cond_stack = cond_mpool_list( soar_module::soar_memory_pool_allocator< condition* >( thisAgent ) );
853 		- 	inst_mpool_list inst_list = inst_mpool_list( soar_module::soar_memory_pool_allocator< instantiation* >( thisAgent ) );
	918 	+ 	cond_mpool_list cond_stack = cond_mpool_list(
	919 	+ 	soar_module::soar_memory_pool_allocator<condition*>(thisAgent));
	920 	+ 	inst_mpool_list inst_list = inst_mpool_list(
	921 	+ 	soar_module::soar_memory_pool_allocator<instantiation*>(thisAgent));
854 	922 		#else
855 	923 		cond_mpool_list cond_stack;
856 	924 		inst_mpool_list inst_list;
... 			
859 	927 		inst_list.push_back(inst);
860 	928 		inst_mpool_list::iterator next_iter = inst_list.begin();
861 	929 		
862 		- 	while ( next_iter != inst_list.end() )
863 		- 	{
	930 	+ 	while (next_iter != inst_list.end()) {
864 	931 		inst = *next_iter;
865 	932 		assert(inst);
866 	933 		++next_iter;
867 	934 		
868 	935 		#ifdef DEBUG_INSTANTIATIONS
869 	936 		if (inst->prod)
870 		- 	print_with_symbols (thisAgent, "\nDeallocate instantiation of %y",inst->prod->name);
	937 	+ 	print_with_symbols (thisAgent, "\nDeallocate instantiation of %y",inst->prod->name);
871 	938 		#endif
872 	939 		
873 	940 		level = inst->match_goal_level;
874 	941 		
875 		- 	for (cond=inst->top_of_instantiated_conditions; cond!=NIL; cond=cond->next)
876 		- 	{
877 		- 	if (cond->type==POSITIVE_CONDITION)
878 		- 	{
	942 	+ 	for (cond = inst->top_of_instantiated_conditions; cond != NIL; cond =
	943 	+ 	cond->next) {
	944 	+ 	if (cond->type == POSITIVE_CONDITION) {
879 	945 		
880 		- 	/* mvp 6-22-94, modified 94.01.17 by AGR with lotsa help from GAP */
881 		- 	if (cond->bt.prohibits)
882 		- 	{
883 		- 	c_old = c = cond->bt.prohibits;
884 		- 	cond->bt.prohibits = NIL;
885 		- 	for (; c!=NIL; c=c->rest)
886 		- 	{
887 		- 	pref = static_cast<preference *>(c->first);
	946 	+ 	if (cond->bt.CDPS) {
	947 	+ 	c_old = c = cond->bt.CDPS;
	948 	+ 	cond->bt.CDPS = NIL;
	949 	+ 	for (; c != NIL; c = c->rest) {
	950 	+ 	pref = static_cast<preference *>(c->first);
888 	951 		#ifdef DO_TOP_LEVEL_REF_CTS
889 		- 	if (level > TOP_GOAL_LEVEL)
	952 	+ 	if (level > TOP_GOAL_LEVEL)
890 	953 		#endif
891 		- 	{
892 		- 	preference_remove_ref (thisAgent, pref);
893 		- 	}
894 		- 	}
895 		- 	free_list (thisAgent, c_old);
896 		- 	}
897 		- 	/* mvp done */
	954 	+ 	{
	955 	+ 	preference_remove_ref(thisAgent, pref);
	956 	+ 	}
	957 	+ 	}
	958 	+ 	free_list(thisAgent, c_old);
	959 	+ 	}
898 	960 		
899 	961 		/* voigtjr, nlderbin:
900 		- 	We flattened out the following recursive loop in order to prevent a stack
901 		- 	overflow that happens when the chain of backtrace instantiations is very long:
	962 	+ 	We flattened out the following recursive loop in order to prevent a stack
	963 	+ 	overflow that happens when the chain of backtrace instantiations is very long:
902 	964 		
903 		- 	retract_instantiation
904 		- 	possibly_deallocate_instantiation
905 		- 	loop start:
906 		- 	deallocate_instantiation (here)
907 		- 	preference_remove_ref
908 		- 	possibly_deallocate_preferences_and_clones
909 		- 	deallocate_preference
910 		- 	possibly_deallocate_instantiation
911 		- 	goto loop start
912 		- 	*/
	965 	+ 	retract_instantiation
	966 	+ 	possibly_deallocate_instantiation
	967 	+ 	loop start:
	968 	+ 	deallocate_instantiation (here)
	969 	+ 	preference_remove_ref
	970 	+ 	possibly_deallocate_preferences_and_clones
	971 	+ 	deallocate_preference
	972 	+ 	possibly_deallocate_instantiation
	973 	+ 	goto loop start
	974 	+ 	*/
913 	975 		#ifndef DO_TOP_LEVEL_REF_CTS
914 	976 		if (level > TOP_GOAL_LEVEL)
915 	977 		#endif
916 	978 		{
917 		- 	wme_remove_ref (thisAgent, cond->bt.wme_);
918 		- 	if (cond->bt.trace)
919 		- 	{
920 		- 	cond->bt.trace->reference_count--;
921 		- 	if (cond->bt.trace->reference_count == 0)
922 		- 	{
923 		- 	preference *clone;
	979 	+ 	wme_remove_ref(thisAgent, cond->bt.wme_);
	980 	+ 	if (cond->bt.trace) {
	981 	+ 	cond->bt.trace->reference_count--;
	982 	+ 	if (cond->bt.trace->reference_count == 0) {
	983 	+ 	preference *clone;
924 	984 		
925 		- 	if (cond->bt.trace->reference_count)
926 		- 	{
927 		- 	continue;
928 		- 	}
929 		- 	bool has_active_clones = false;
930 		- 	for (clone=cond->bt.trace->next_clone; clone!=NIL; clone=clone->next_clone)
931 		- 	{
932 		- 	if ( clone->reference_count )
933 		- 	{
934 		- 	has_active_clones = true;
935 		- 	}
936 		- 	}
937 		- 	if ( has_active_clones )
938 		- 	{
939 		- 	continue;
940 		- 	}
941 		- 	for ( clone = cond->bt.trace->prev_clone; clone != NIL; clone = clone->prev_clone )
942 		- 	{
943 		- 	if ( clone->reference_count )
944 		- 	{
945 		- 	has_active_clones = true;
946 		- 	}
947 		- 	}
948 		- 	if ( has_active_clones )
949 		- 	{
950 		- 	continue;
951 		- 	}
	985 	+ 	if (cond->bt.trace->reference_count) {
	986 	+ 	continue;
	987 	+ 	}
	988 	+ 	bool has_active_clones = false;
	989 	+ 	for (clone = cond->bt.trace->next_clone;
	990 	+ 	clone != NIL; clone = clone->next_clone) {
	991 	+ 	if (clone->reference_count) {
	992 	+ 	has_active_clones = true;
	993 	+ 	}
	994 	+ 	}
	995 	+ 	if (has_active_clones) {
	996 	+ 	continue;
	997 	+ 	}
	998 	+ 	for (clone = cond->bt.trace->prev_clone;
	999 	+ 	clone != NIL; clone = clone->prev_clone) {
	1000 	+ 	if (clone->reference_count) {
	1001 	+ 	has_active_clones = true;
	1002 	+ 	}
	1003 	+ 	}
	1004 	+ 	if (has_active_clones) {
	1005 	+ 	continue;
	1006 	+ 	}
952 	1007 		
953 		- 	// The clones are hopefully a simple case so we just call deallocate_preference on them.
954 		- 	// Someone needs to create a test case to push this boundary...
955 		- 	{
956 		- 	preference* clone = cond->bt.trace->next_clone;
957 		- 	preference* next;
958 		- 	while (clone) {
959 		- 	next = clone->next_clone;
960 		- 	deallocate_preference (thisAgent, clone);
961 		- 	clone = next;
962 		- 	}
963 		- 	clone = cond->bt.trace->prev_clone;
964 		- 	while (clone) {
965 		- 	next = clone->prev_clone;
966 		- 	deallocate_preference (thisAgent, clone);
967 		- 	clone = next;
968 		- 	}
969 		- 	}
	1008 	+ 	// The clones are hopefully a simple case so we just call deallocate_preference on them.
	1009 	+ 	// Someone needs to create a test case to push this boundary...
	1010 	+ 	{
	1011 	+ 	preference* clone = cond->bt.trace->next_clone;
	1012 	+ 	preference* next;
	1013 	+ 	while (clone) {
	1014 	+ 	next = clone->next_clone;
	1015 	+ 	deallocate_preference(thisAgent, clone);
	1016 	+ 	clone = next;
	1017 	+ 	}
	1018 	+ 	clone = cond->bt.trace->prev_clone;
	1019 	+ 	while (clone) {
	1020 	+ 	next = clone->prev_clone;
	1021 	+ 	deallocate_preference(thisAgent, clone);
	1022 	+ 	clone = next;
	1023 	+ 	}
	1024 	+ 	}
970 	1025 		
971 		- 	/* --- deallocate pref --- */
972 		- 	/* --- remove it from the list of bt.trace's for its match goal --- */
973 		- 	if ( cond->bt.trace->on_goal_list )
974 		- 	{
975 		- 	remove_from_dll(
976 		- 	cond->bt.trace->inst->match_goal->id.preferences_from_goal,
977 		- 	cond->bt.trace, all_of_goal_next, all_of_goal_prev );
978 		- 	}
	1026 	+ 	/* --- deallocate pref --- */
	1027 	+ 	/* --- remove it from the list of bt.trace's for its match goal --- */
	1028 	+ 	if (cond->bt.trace->on_goal_list) {
	1029 	+ 	remove_from_dll(
	1030 	+ 	cond->bt.trace->inst->match_goal->id.preferences_from_goal,
	1031 	+ 	cond->bt.trace, all_of_goal_next,
	1032 	+ 	all_of_goal_prev);
	1033 	+ 	}
979 	1034 		
980 		- 	/* --- remove it from the list of bt.trace's from that instantiation --- */
981 		- 	remove_from_dll( cond->bt.trace->inst->preferences_generated, cond->bt.trace, inst_next, inst_prev );
982 		- 	if ( ( !cond->bt.trace->inst->preferences_generated ) && ( !cond->bt.trace->inst->in_ms ) )
983 		- 	{
984 		- 	next_iter = inst_list.insert( next_iter, cond->bt.trace->inst );
985 		- 	}
	1035 	+ 	/* --- remove it from the list of bt.trace's from that instantiation --- */
	1036 	+ 	remove_from_dll(
	1037 	+ 	cond->bt.trace->inst->preferences_generated,
	1038 	+ 	cond->bt.trace, inst_next, inst_prev);
	1039 	+ 	if ((!cond->bt.trace->inst->preferences_generated)
	1040 	+ 	&& (!cond->bt.trace->inst->in_ms)) {
	1041 	+ 	next_iter = inst_list.insert(next_iter,
	1042 	+ 	cond->bt.trace->inst);
	1043 	+ 	}
986 	1044 		
987 		- 	cond_stack.push_back( cond );
988 		- 	} // if
989 		- 	} // if
990 		- 	} // if
	1045 	+ 	cond_stack.push_back(cond);
	1046 	+ 	} // if
	1047 	+ 	} // if
	1048 	+ 	} // if
991 	1049 		/* voigtjr, nlderbin end */
992 	1050 		} // if
993 	1051 		} // for
994 	1052 		} // while
995 	1053 		
996 	1054 		// free condition symbols and pref
997 		- 	while( !cond_stack.empty() )
998 		- 	{
	1055 	+ 	while (!cond_stack.empty()) {
999 	1056 		condition* temp = cond_stack.back();
1000 	1057 		cond_stack.pop_back();
1001 	1058 		
1002 	1059 		/* --- dereference component symbols --- */
1003 		- 	symbol_remove_ref( thisAgent, temp->bt.trace->id );
1004 		- 	symbol_remove_ref( thisAgent, temp->bt.trace->attr );
1005 		- 	symbol_remove_ref( thisAgent, temp->bt.trace->value );
1006 		- 	if ( preference_is_binary( temp->bt.trace->type ) )
1007 		- 	{
1008 		- 	symbol_remove_ref( thisAgent, temp->bt.trace->referent );
	1060 	+ 	symbol_remove_ref(thisAgent, temp->bt.trace->id);
	1061 	+ 	symbol_remove_ref(thisAgent, temp->bt.trace->attr);
	1062 	+ 	symbol_remove_ref(thisAgent, temp->bt.trace->value);
	1063 	+ 	if (preference_is_binary(temp->bt.trace->type)) {
	1064 	+ 	symbol_remove_ref(thisAgent, temp->bt.trace->referent);
1009 	1065 		}
1010 	1066 		
1011 		- 	if ( temp->bt.trace->wma_o_set )
1012 		- 	{
1013 		- 	wma_remove_pref_o_set( thisAgent, temp->bt.trace );
	1067 	+ 	if (temp->bt.trace->wma_o_set) {
	1068 	+ 	wma_remove_pref_o_set(thisAgent, temp->bt.trace);
1014 	1069 		}
1015 	1070 		
1016 	1071 		/* --- free the memory --- */
1017 		- 	free_with_pool( &thisAgent->preference_pool, temp->bt.trace );
	1072 	+ 	free_with_pool(&thisAgent->preference_pool, temp->bt.trace);
1018 	1073 		}
1019 	1074 		
1020 	1075 		// free instantiations in the reverse order
1021 	1076 		inst_mpool_list::reverse_iterator riter = inst_list.rbegin();
1022 		- 	while( riter != inst_list.rend() )
1023 		- 	{
	1077 	+ 	while (riter != inst_list.rend()) {
1024 	1078 		instantiation* temp = *riter;
1025 	1079 		++riter;
1026 	1080 		
1027 		- 	deallocate_condition_list( thisAgent, temp->top_of_instantiated_conditions );
1028 		- 	deallocate_list_of_nots( thisAgent, temp->nots );
1029 		- 	if ( temp->prod )
1030 		- 	{
1031 		- 	production_remove_ref( thisAgent, temp->prod );
	1081 	+ 	deallocate_condition_list(thisAgent,
	1082 	+ 	temp->top_of_instantiated_conditions);
	1083 	+ 	deallocate_list_of_nots(thisAgent, temp->nots);
	1084 	+ 	if (temp->prod) {
	1085 	+ 	production_remove_ref(thisAgent, temp->prod);
1032 	1086 		}
1033 		- 	free_with_pool( &thisAgent->instantiation_pool, temp );
	1087 	+ 	free_with_pool(&thisAgent->instantiation_pool, temp);
1034 	1088 		}
1035 	1089 		}
1036 	1090 		
1037 	1091 		/* -----------------------------------------------------------------------
1038 		- 	Retract Instantiation
	1092 	+ 	Retract Instantiation
1039 	1093 		
1040 		- 	This retracts the given instantiation.
1041 		- 	----------------------------------------------------------------------- */
	1094 	+ 	This retracts the given instantiation.
	1095 	+ 	----------------------------------------------------------------------- */
1042 	1096 		
1043 		- 	void retract_instantiation (agent* thisAgent, instantiation *inst) {
1044 		- 	preference *pref, *next;
1045 		- 	Bool retracted_a_preference;
1046 		- 	Bool trace_it;
	1097 	+ 	void retract_instantiation(agent* thisAgent, instantiation *inst) {
	1098 	+ 	preference *pref, *next;
	1099 	+ 	Bool retracted_a_preference;
	1100 	+ 	Bool trace_it;
1047 	1101 		
1048 		- 	/* --- invoke callback function --- */
1049 		- 	soar_invoke_callbacks(thisAgent,
1050 		- 	RETRACTION_CALLBACK,
	1102 	+ 	/* --- invoke callback function --- */
	1103 	+ 	soar_invoke_callbacks(thisAgent, RETRACTION_CALLBACK,
1051 	1104 		static_cast<soar_call_data>(inst));
1052 	1105 		
1053 		- 	retracted_a_preference = FALSE;
	1106 	+ 	retracted_a_preference = FALSE;
1054 	1107 		
1055 		- 	trace_it = trace_firings_of_inst (thisAgent, inst);
	1108 	+ 	trace_it = trace_firings_of_inst(thisAgent, inst);
1056 	1109 		
1057 		- 	/* --- retract any preferences that are in TM and aren't o-supported --- */
1058 		- 	pref = inst->preferences_generated;
	1110 	+ 	/* --- retract any preferences that are in TM and aren't o-supported --- */
	1111 	+ 	pref = inst->preferences_generated;
1059 	1112 		
1060 		- 	while (pref!=NIL) {
1061 		- 	next = pref->inst_next;
1062 		- 	if (pref->in_tm && (! pref->o_supported)) {
	1113 	+ 	while (pref != NIL) {
	1114 	+ 	next = pref->inst_next;
	1115 	+ 	if (pref->in_tm && (!pref->o_supported)) {
1063 	1116 		
1064 		- 	if (trace_it) {
1065 		- 	if (!retracted_a_preference) {
1066 		- 	if (get_printer_output_column(thisAgent)!=1) print (thisAgent, "\n"); /* AGR 617/634 */
1067 		- 	print (thisAgent, "Retracting ");
1068 		- 	print_instantiation_with_wmes (thisAgent, inst,
1069 		- 	static_cast<wme_trace_type>(thisAgent->sysparams[TRACE_FIRINGS_WME_TRACE_TYPE_SYSPARAM]),1);
1070 		- 	if (thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
1071 		- 	print (thisAgent, " -->\n");
1072 		- 	xml_object( thisAgent, kTagActionSideMarker );
	1117 	+ 	if (trace_it) {
	1118 	+ 	if (!retracted_a_preference) {
	1119 	+ 	if (get_printer_output_column(thisAgent) != 1)
	1120 	+ 	print(thisAgent, "\n"); /* AGR 617/634 */
	1121 	+ 	print(thisAgent, "Retracting ");
	1122 	+ 	print_instantiation_with_wmes(thisAgent, inst,
	1123 	+ 	static_cast<wme_trace_type>(thisAgent->sysparams[TRACE_FIRINGS_WME_TRACE_TYPE_SYSPARAM]),
	1124 	+ 	1);
	1125 	+ 	if (thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
	1126 	+ 	print(thisAgent, " -->\n");
	1127 	+ 	xml_object(thisAgent, kTagActionSideMarker);
	1128 	+ 	}
	1129 	+ 	}
	1130 	+ 	if (thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
	1131 	+ 	print(thisAgent, " ");
	1132 	+ 	print_preference(thisAgent, pref);
	1133 	+ 	}
1073 	1134 		}
	1135 	+ 	
	1136 	+ 	remove_preference_from_tm(thisAgent, pref);
	1137 	+ 	retracted_a_preference = TRUE;
1074 	1138 		}
1075 		- 	if (thisAgent->sysparams[TRACE_FIRINGS_PREFERENCES_SYSPARAM]) {
1076 		- 	print (thisAgent, " ");
1077 		- 	print_preference (thisAgent, pref);
1078 		- 	}
1079 		- 	}
	1139 	+ 	pref = next;
	1140 	+ 	}
1080 	1141 		
1081 		- 	remove_preference_from_tm (thisAgent, pref);
1082 		- 	retracted_a_preference = TRUE;
1083 		- 	}
1084 		- 	pref = next;
1085 		- 	}
	1142 	+ 	/* --- remove inst from list of instantiations of this production --- */
	1143 	+ 	remove_from_dll(inst->prod->instantiations, inst, next, prev);
1086 	1144 		
1087 		- 	/* --- remove inst from list of instantiations of this production --- */
1088 		- 	remove_from_dll (inst->prod->instantiations, inst, next, prev);
	1145 	+ 	/* --- if retracting a justification, excise it --- */
	1146 	+ 	/*
	1147 	+ 	* if the reference_count on the production is 1 (or less) then the
	1148 	+ 	* only thing supporting this justification is the instantiation, hence
	1149 	+ 	* it has already been excised, and doing it again is wrong.
	1150 	+ 	*/
	1151 	+ 	production* prod = inst->prod;
	1152 	+ 	if (prod->type == JUSTIFICATION_PRODUCTION_TYPE
	1153 	+ 	&& prod->reference_count > 1) {
	1154 	+ 	excise_production(thisAgent, prod, FALSE);
	1155 	+ 	} else if (prod->type == CHUNK_PRODUCTION_TYPE) {
	1156 	+ 	rl_param_container::apoptosis_choices apoptosis =
	1157 	+ 	thisAgent->rl_params->apoptosis->get_value();
1089 	1158 		
1090 		- 	/* --- if retracting a justification, excise it --- */
1091 		- 	/*
1092 		- 	* if the reference_count on the production is 1 (or less) then the
1093 		- 	* only thing supporting this justification is the instantiation, hence
1094 		- 	* it has already been excised, and doing it again is wrong.
1095 		- 	*/
1096 		- 	production* prod = inst->prod;
1097 		- 	if ( prod->type==JUSTIFICATION_PRODUCTION_TYPE && prod->reference_count > 1 )
1098 		- 	{
1099 		- 	excise_production (thisAgent, prod, FALSE);
1100 		- 	}
1101 		- 	else if ( prod->type == CHUNK_PRODUCTION_TYPE )
1102 		- 	{
1103 		- 	rl_param_container::apoptosis_choices apoptosis = thisAgent->rl_params->apoptosis->get_value();
1104 		- 	
1105 		- 	// we care about production history of chunks if...
1106 		- 	// - we are dealing with a non-RL rule and all chunks are subject to apoptosis OR
1107 		- 	// - we are dealing with an RL rule that...
1108 		- 	// - has not been updated by RL AND
1109 		- 	// - is not in line to be updated by RL
1110 		- 	if ( apoptosis != rl_param_container::apoptosis_none )
1111 		- 	{
1112 		- 	if ( ( !prod->rl_rule && ( apoptosis == rl_param_container::apoptosis_chunks ) ) ||
1113 		- 	( prod->rl_rule && ( static_cast<int64_t>( prod->rl_update_count ) == 0 ) && ( prod->rl_ref_count == 0 ) ) )
1114 		- 	{
1115 		- 	thisAgent->rl_prods->reference_object( prod, 1 );
1116 		- 	}
	1159 	+ 	// we care about production history of chunks if...
	1160 	+ 	// - we are dealing with a non-RL rule and all chunks are subject to apoptosis OR
	1161 	+ 	// - we are dealing with an RL rule that...
	1162 	+ 	// - has not been updated by RL AND
	1163 	+ 	// - is not in line to be updated by RL
	1164 	+ 	if (apoptosis != rl_param_container::apoptosis_none) {
	1165 	+ 	if ((!prod->rl_rule
	1166 	+ 	&& (apoptosis == rl_param_container::apoptosis_chunks))
	1167 	+ 	|| (prod->rl_rule
	1168 	+ 	&& (static_cast<int64_t>(prod->rl_update_count) == 0)
	1169 	+ 	&& (prod->rl_ref_count == 0))) {
	1170 	+ 	thisAgent->rl_prods->reference_object(prod, 1);
	1171 	+ 	}
	1172 	+ 	}
1117 	1173 		}
1118 		- 	}
1119 	1174 		
1120 		- 	/* --- mark as no longer in MS, and possibly deallocate --- */
1121 		- 	inst->in_ms = FALSE;
1122 		- 	possibly_deallocate_instantiation (thisAgent, inst);
	1175 	+ 	/* --- mark as no longer in MS, and possibly deallocate --- */
	1176 	+ 	inst->in_ms = FALSE;
	1177 	+ 	possibly_deallocate_instantiation(thisAgent, inst);
1123 	1178 		}
1124 	1179 		

# end irrelevant whitespace changes
# minor comment typo fix

1125 	1180 		/* -----------------------------------------------------------------------
1126 		- 	Assert New Preferences
	1181 	+ 	Assert New Preferences
1127 	1182 		
1128 		- 	This routine scans through newly_created_instantiations, asserting
1129 		- 	each preference generated except for o-rejects. It also removes
1130 		- 	each instantiation from newly_created_instantiations, linking each
1131 		- 	onto the list of instantiations for that particular production.
1132 		- 	O-rejects are bufferred and handled after everything else.
	1183 	+ 	This routine scans through newly_created_instantiations, asserting
	1184 	+ 	each preference generated except for o-rejects. It also removes
	1185 	+ 	each instantiation from newly_created_instantiations, linking each
	1186 	+ 	onto the list of instantiations for that particular production.
	1187 	+ 	O-rejects are buffered and handled after everything else.
1133 	1188 		
1134 		- 	Note that some instantiations on newly_created_instantiations are not
1135 		- 	in the match set--for the initial instantiations of chunks/justifications,
1136 		- 	if they don't match WM, we have to assert the o-supported preferences
1137 		- 	and throw away the rest.
1138 		- 	----------------------------------------------------------------------- */
	1189 	+ 	Note that some instantiations on newly_created_instantiations are not
	1190 	+ 	in the match set--for the initial instantiations of chunks/justifications,
	1191 	+ 	if they don't match WM, we have to assert the o-supported preferences
	1192 	+ 	and throw away the rest.
	1193 	+ 	----------------------------------------------------------------------- */
1139 	1194 	

# start irrelevant whitespace changes (to end of file)
	
1140 		- 	void assert_new_preferences (agent* thisAgent, pref_buffer_list& bufdeallo)
1141 		- 	{
	1195 	+ 	void assert_new_preferences(agent* thisAgent, pref_buffer_list& bufdeallo) {
1142 	1196 		instantiation *inst, *next_inst;
1143 	1197 		preference *pref, *next_pref;
1144 	1198 		preference *o_rejects;
1145 	1199 		
1146 	1200 		o_rejects = NIL;
1147 	1201 		
1148 		- 	
1149 	1202 		/* REW: begin 09.15.96 */
1150 	1203 		if (thisAgent->soar_verbose_flag == TRUE) {
1151 	1204 		printf("\n in assert_new_preferences:");
... 			
1160 	1213 		//preference *p, *next_p;
1161 	1214 		
1162 	1215 		/* Do an initial loop to process o-rejects, then re-loop
1163 		- 	to process normal preferences.
1164 		- 	*/
1165 		- 	for (inst = thisAgent->newly_created_instantiations; inst != NIL; inst = next_inst) {
	1216 	+ 	to process normal preferences.
	1217 	+ 	*/
	1218 	+ 	for (inst = thisAgent->newly_created_instantiations; inst != NIL; inst =
	1219 	+ 	next_inst) {
1166 	1220 		next_inst = inst->next;
1167 	1221 		
1168 		- 	for (pref = inst->preferences_generated; pref != NIL; pref = next_pref) {
	1222 	+ 	for (pref = inst->preferences_generated; pref != NIL; pref =
	1223 	+ 	next_pref) {
1169 	1224 		next_pref = pref->inst_next;
1170 		- 	if ((pref->type == REJECT_PREFERENCE_TYPE) && (pref->o_supported)) {
	1225 	+ 	if ((pref->type == REJECT_PREFERENCE_TYPE)
	1226 	+ 	&& (pref->o_supported)) {
1171 	1227 		/* --- o-reject: just put it in the buffer for later --- */
1172 	1228 		pref->next = o_rejects;
1173 	1229 		o_rejects = pref;
... 			
1176 	1232 		}
1177 	1233 		
1178 	1234 		if (o_rejects)
1179 		- 	process_o_rejects_and_deallocate_them (thisAgent, o_rejects, bufdeallo);
	1235 	+ 	process_o_rejects_and_deallocate_them(thisAgent, o_rejects,
	1236 	+ 	bufdeallo);
1180 	1237 		
1181 	1238 		// s = find_slot(pref->id, pref->attr);
1182 	1239 		// if (s) {
... 			
1197 	1254 		}
1198 	1255 		#endif
1199 	1256 		
1200 		- 	for (inst=thisAgent->newly_created_instantiations;
1201 		- 	inst!=NIL;
1202 		- 	inst=next_inst)
1203 		- 	{
	1257 	+ 	for (inst = thisAgent->newly_created_instantiations; inst != NIL; inst =
	1258 	+ 	next_inst) {
1204 	1259 		next_inst = inst->next;
1205 	1260 		if (inst->in_ms)
1206 		- 	insert_at_head_of_dll (inst->prod->instantiations, inst, next, prev);
	1261 	+ 	insert_at_head_of_dll(inst->prod->instantiations, inst, next, prev);
1207 	1262 		
1208 	1263 		/* REW: begin 09.15.96 */
1209 	1264 		if (thisAgent->soar_verbose_flag == TRUE) {
1210 		- 	print_with_symbols(thisAgent, "\n asserting instantiation: %y\n",
1211 		- 	inst->prod->name);
	1265 	+ 	print_with_symbols(thisAgent,
	1266 	+ 	"\n asserting instantiation: %y\n", inst->prod->name);
1212 	1267 		char buf[256];
1213 		- 	SNPRINTF(buf, 254, "asserting instantiation: %s", symbol_to_string(thisAgent, inst->prod->name, true, 0, 0));
	1268 	+ 	SNPRINTF(buf, 254, "asserting instantiation: %s",
	1269 	+ 	symbol_to_string(thisAgent, inst->prod->name, true, 0, 0));
1214 	1270 		xml_generate_verbose(thisAgent, buf);
1215 	1271 		}
1216 	1272 		/* REW: end 09.15.96 */
1217 	1273 		
1218 		- 	for (pref=inst->preferences_generated; pref!=NIL; pref=next_pref)
1219 		- 	{
	1274 	+ 	for (pref = inst->preferences_generated; pref != NIL; pref =
	1275 	+ 	next_pref) {
1220 	1276 		next_pref = pref->inst_next;
1221 		- 	if ((pref->type==REJECT_PREFERENCE_TYPE) && (pref->o_supported))
1222 		- 	{
	1277 	+ 	if ((pref->type == REJECT_PREFERENCE_TYPE) && (pref->o_supported)) {
1223 	1278 		#ifndef O_REJECTS_FIRST
1224 	1279 		/* --- o-reject: just put it in the buffer for later --- */
1225 	1280 		pref->next = o_rejects;
... 			
1230 	1285 		/* No knowledge retrieval necessary in Operand2 */
1231 	1286 		/* REW: end 09.15.96 */
1232 	1287 		
1233 		- 	}
1234 		- 	else if (inst->in_ms || pref->o_supported)
1235 		- 	{
	1288 	+ 	} else if (inst->in_ms || pref->o_supported) {
1236 	1289 		/* --- normal case --- */
1237 		- 	if ( add_preference_to_tm (thisAgent, pref) )
1238 		- 	{
	1290 	+ 	if (add_preference_to_tm(thisAgent, pref)) {
1239 	1291 		/* REW: begin 09.15.96 */
1240 	1292 		/* No knowledge retrieval necessary in Operand2 */
1241 	1293 		/* REW: end 09.15.96 */
1242 	1294 		
1243 		- 	
1244 		- 	if ( wma_enabled( thisAgent ) )
1245 		- 	{
1246 		- 	wma_activate_wmes_in_pref( thisAgent, pref );
	1295 	+ 	if (wma_enabled(thisAgent)) {
	1296 	+ 	wma_activate_wmes_in_pref(thisAgent, pref);
1247 	1297 		}
1248 		- 	}
1249 		- 	else
1250 		- 	{
	1298 	+ 	} else {
1251 	1299 		// NLD: the preference was o-supported, at
1252 	1300 		// the top state, and was asserting an acceptable
1253 	1301 		// preference for a WME that was already
1254 	1302 		// o-supported. hence unnecessary.
1255 	1303 		
1256 		- 	preference_add_ref( pref );
1257 		- 	preference_remove_ref( thisAgent, pref );
	1304 	+ 	preference_add_ref(pref);
	1305 	+ 	preference_remove_ref(thisAgent, pref);
1258 	1306 		}
1259 		- 	}
1260 		- 	else
1261 		- 	{
	1307 	+ 	} else {
1262 	1308 		/* --- inst. is refracted chunk, and pref. is not o-supported:
1263 		- 	remove the preference --- */
	1309 	+ 	remove the preference --- */
1264 	1310 		
1265 	1311 		/* --- first splice it out of the clones list--otherwise we might
1266 		- 	accidentally deallocate some clone that happens to have refcount==0
1267 		- 	just because it hasn't been asserted yet --- */
	1312 	+ 	accidentally deallocate some clone that happens to have refcount==0
	1313 	+ 	just because it hasn't been asserted yet --- */
1268 	1314 		
1269 	1315 		if (pref->next_clone)
1270 	1316 		pref->next_clone->prev_clone = pref->prev_clone;
... 			
1273 	1319 		pref->next_clone = pref->prev_clone = NIL;
1274 	1320 		
1275 	1321 		/* --- now add then remove ref--this should result in deallocation */
1276 		- 	preference_add_ref (pref);
1277 		- 	preference_remove_ref (thisAgent, pref);
	1322 	+ 	preference_add_ref(pref);
	1323 	+ 	preference_remove_ref(thisAgent, pref);
1278 	1324 		}
1279 	1325 		}
1280 	1326 		}
1281 	1327 		#ifndef O_REJECTS_FIRST
1282 	1328 		if (o_rejects)
1283 		- 	process_o_rejects_and_deallocate_them (thisAgent, o_rejects, bufdeallo);
	1329 	+ 	process_o_rejects_and_deallocate_them (thisAgent, o_rejects, bufdeallo);
1284 	1330 		#endif
1285 	1331 		}
1286 	1332 		
1287 	1333 		/* -----------------------------------------------------------------------
1288 		- 	Do Preference Phase
	1334 	+ 	Do Preference Phase
1289 	1335 		
1290 		- 	This routine is called from the top level to run the preference phase.
1291 		- 	----------------------------------------------------------------------- */
	1336 	+ 	This routine is called from the top level to run the preference phase.
	1337 	+ 	----------------------------------------------------------------------- */
1292 	1338 		
1293 		- 	void do_preference_phase (agent* thisAgent) {
1294 		- 	instantiation *inst = 0;
	1339 	+ 	void do_preference_phase(agent* thisAgent) {
	1340 	+ 	instantiation *inst = 0;
1295 	1341 		
	1342 	+ 	/* AGR 617/634: These are 2 bug reports that report the same problem,
	1343 	+ 	namely that when 2 chunk firings happen in succession, there is an
	1344 	+ 	extra newline printed out. The simple fix is to monitor
	1345 	+ 	get_printer_output_column and see if it's at the beginning of a line
	1346 	+ 	or not when we're ready to print a newline. 94.11.14 */
1296 	1347 		
1297 		- 	/* AGR 617/634: These are 2 bug reports that report the same problem,
1298 		- 	namely that when 2 chunk firings happen in succession, there is an
1299 		- 	extra newline printed out. The simple fix is to monitor
1300 		- 	get_printer_output_column and see if it's at the beginning of a line
1301 		- 	or not when we're ready to print a newline. 94.11.14 */
	1348 	+ 	if (thisAgent->sysparams[TRACE_PHASES_SYSPARAM]) {
	1349 	+ 	if (thisAgent->current_phase == APPLY_PHASE) { /* it's always IE for PROPOSE */
	1350 	+ 	xml_begin_tag(thisAgent, kTagSubphase);
	1351 	+ 	xml_att_val(thisAgent, kPhase_Name,
	1352 	+ 	kSubphaseName_FiringProductions);
	1353 	+ 	switch (thisAgent->FIRING_TYPE) {
	1354 	+ 	case PE_PRODS:
	1355 	+ 	print(thisAgent,
	1356 	+ 	"\t--- Firing Productions (PE) For State At Depth %d ---\n",
	1357 	+ 	thisAgent->active_level); // SBW 8/4/2008: added active_level
	1358 	+ 	xml_att_val(thisAgent, kPhase_FiringType, kPhaseFiringType_PE);
	1359 	+ 	break;
	1360 	+ 	case IE_PRODS:
	1361 	+ 	print(thisAgent,
	1362 	+ 	"\t--- Firing Productions (IE) For State At Depth %d ---\n",
	1363 	+ 	thisAgent->active_level); // SBW 8/4/2008: added active_level
	1364 	+ 	xml_att_val(thisAgent, kPhase_FiringType, kPhaseFiringType_IE);
	1365 	+ 	break;
	1366 	+ 	}
	1367 	+ 	std::string levelString;
	1368 	+ 	to_string(thisAgent->active_level, levelString);
	1369 	+ 	xml_att_val(thisAgent, kPhase_LevelNum, levelString.c_str()); // SBW 8/4/2008: active_level for XML output mode
	1370 	+ 	xml_end_tag(thisAgent, kTagSubphase);
	1371 	+ 	}
	1372 	+ 	}
1302 	1373 		
	1374 	+ 	if (wma_enabled(thisAgent)) {
	1375 	+ 	wma_activate_wmes_tested_in_prods(thisAgent);
	1376 	+ 	}
1303 	1377 		
1304 		- 	if (thisAgent->sysparams[TRACE_PHASES_SYSPARAM]) {
1305 		- 	if (thisAgent->current_phase == APPLY_PHASE) { /* it's always IE for PROPOSE */
1306 		- 	xml_begin_tag( thisAgent, kTagSubphase );
1307 		- 	xml_att_val( thisAgent, kPhase_Name, kSubphaseName_FiringProductions );
1308 		- 	switch (thisAgent->FIRING_TYPE) {
1309 		- 	case PE_PRODS:
1310 		- 	print (thisAgent, "\t--- Firing Productions (PE) For State At Depth %d ---\n", thisAgent->active_level); // SBW 8/4/2008: added active_level
1311 		- 	xml_att_val( thisAgent, kPhase_FiringType, kPhaseFiringType_PE );
1312 		- 	break;
1313 		- 	case IE_PRODS:
1314 		- 	print (thisAgent, "\t--- Firing Productions (IE) For State At Depth %d ---\n", thisAgent->active_level); // SBW 8/4/2008: added active_level
1315 		- 	xml_att_val( thisAgent, kPhase_FiringType, kPhaseFiringType_IE );
1316 		- 	break;
1317 		- 	}
1318 		- 	std::string levelString;
1319 		- 	to_string(thisAgent->active_level, levelString);
1320 		- 	xml_att_val( thisAgent, kPhase_LevelNum, levelString.c_str()); // SBW 8/4/2008: active_level for XML output mode
1321 		- 	xml_end_tag( thisAgent, kTagSubphase );
1322 		- 	}
1323 		- 	}
	1378 	+ 	/* New waterfall model: */
	1379 	+ 	// Save previous active level for usage on next elaboration cycle.
	1380 	+ 	thisAgent->highest_active_level = thisAgent->active_level;
	1381 	+ 	thisAgent->highest_active_goal = thisAgent->active_goal;
1324 	1382 		
1325 		- 	if ( wma_enabled( thisAgent ) )
1326 		- 	{
1327 		- 	wma_activate_wmes_tested_in_prods( thisAgent );
1328 		- 	}
1329 		- 	
1330 		- 	/* New waterfall model: */
1331 		- 	// Save previous active level for usage on next elaboration cycle.
1332 		- 	thisAgent->highest_active_level = thisAgent->active_level;
1333 		- 	thisAgent->highest_active_goal = thisAgent->active_goal;
1334 		- 	
1335 		- 	thisAgent->change_level = thisAgent->highest_active_level;
1336 		- 	thisAgent->next_change_level = thisAgent->highest_active_level;
	1383 	+ 	thisAgent->change_level = thisAgent->highest_active_level;
	1384 	+ 	thisAgent->next_change_level = thisAgent->highest_active_level;
1337 	1385 		
1338 		- 	// Temporary list to buffer deallocation of some preferences until
1339 		- 	// the inner elaboration loop is over.
	1386 	+ 	// Temporary list to buffer deallocation of some preferences until
	1387 	+ 	// the inner elaboration loop is over.
1340 	1388 		#ifdef USE_MEM_POOL_ALLOCATORS
1341 		- 	pref_buffer_list bufdeallo = pref_buffer_list( soar_module::soar_memory_pool_allocator< preference* >( thisAgent ) );
	1389 	+ 	pref_buffer_list bufdeallo = pref_buffer_list(
	1390 	+ 	soar_module::soar_memory_pool_allocator<preference*>(thisAgent));
1342 	1391 		#else
1343 		- 	pref_buffer_list bufdeallo;
	1392 	+ 	pref_buffer_list bufdeallo;
1344 	1393 		#endif
1345 	1394 		
1346 		- 	// inner elaboration cycle
1347 		- 	for (;;) {
1348 		- 	thisAgent->change_level = thisAgent->next_change_level;
	1395 	+ 	// inner elaboration cycle
	1396 	+ 	for (;;) {
	1397 	+ 	thisAgent->change_level = thisAgent->next_change_level;
1349 	1398 		
1350 		- 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
1351 		- 	print (thisAgent, "\n--- Inner Elaboration Phase, active level %d", thisAgent->active_level);
1352 		- 	if (thisAgent->active_goal) {
1353 		- 	print_with_symbols (thisAgent, " (%y)", thisAgent->active_goal);
1354 		- 	}
1355 		- 	print (thisAgent, " ---\n");
1356 		- 	}
	1399 	+ 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
	1400 	+ 	print(thisAgent, "\n--- Inner Elaboration Phase, active level %d",
	1401 	+ 	thisAgent->active_level);
	1402 	+ 	if (thisAgent->active_goal) {
	1403 	+ 	print_with_symbols(thisAgent, " (%y)", thisAgent->active_goal);
	1404 	+ 	}
	1405 	+ 	print(thisAgent, " ---\n");
	1406 	+ 	}
1357 	1407 		
1358 		- 	thisAgent->newly_created_instantiations = NIL;
	1408 	+ 	thisAgent->newly_created_instantiations = NIL;
1359 	1409 		
1360 		- 	Bool assertionsExist = FALSE;
1361 		- 	production *prod = 0;
1362 		- 	struct token_struct *tok = 0;
1363 		- 	wme *w = 0;
1364 		- 	Bool once = TRUE;
1365 		- 	while (postpone_assertion (thisAgent, &prod, &tok, &w)) {
1366 		- 	assertionsExist = TRUE;
	1410 	+ 	Bool assertionsExist = FALSE;
	1411 	+ 	production *prod = 0;
	1412 	+ 	struct token_struct *tok = 0;
	1413 	+ 	wme *w = 0;
	1414 	+ 	Bool once = TRUE;
	1415 	+ 	while (postpone_assertion(thisAgent, &prod, &tok, &w)) {
	1416 	+ 	assertionsExist = TRUE;
1367 	1417 		
1368 		- 	if (thisAgent->max_chunks_reached) {
1369 		- 	consume_last_postponed_assertion(thisAgent);
1370 		- 	thisAgent->system_halted = TRUE;
1371 		- 	soar_invoke_callbacks(thisAgent,
1372 		- 	AFTER_HALT_SOAR_CALLBACK,
1373 		- 	0);
1374 		- 	return;
1375 		- 	}
	1418 	+ 	if (thisAgent->max_chunks_reached) {
	1419 	+ 	consume_last_postponed_assertion(thisAgent);
	1420 	+ 	thisAgent->system_halted = TRUE;
	1421 	+ 	soar_invoke_callbacks(thisAgent, AFTER_HALT_SOAR_CALLBACK, 0);
	1422 	+ 	return;
	1423 	+ 	}
1376 	1424 		
1377 		- 	if (prod->type == JUSTIFICATION_PRODUCTION_TYPE) {
1378 		- 	consume_last_postponed_assertion(thisAgent);
	1425 	+ 	if (prod->type == JUSTIFICATION_PRODUCTION_TYPE) {
	1426 	+ 	consume_last_postponed_assertion(thisAgent);
1379 	1427 		
1380 		- 	// don't fire justifications
1381 		- 	continue;
1382 		- 	}
	1428 	+ 	// don't fire justifications
	1429 	+ 	continue;
	1430 	+ 	}
1383 	1431 		
1384 		- 	if (shouldCreateInstantiation(thisAgent, prod, tok, w)) {
1385 		- 	once = FALSE;
1386 		- 	consume_last_postponed_assertion(thisAgent);
1387 		- 	create_instantiation (thisAgent, prod, tok, w);
1388 		- 	}
1389 		- 	}
	1432 	+ 	if (shouldCreateInstantiation(thisAgent, prod, tok, w)) {
	1433 	+ 	once = FALSE;
	1434 	+ 	consume_last_postponed_assertion(thisAgent);
	1435 	+ 	create_instantiation(thisAgent, prod, tok, w);
	1436 	+ 	}
	1437 	+ 	}
1390 	1438 		
1391 		- 	// New waterfall model: something fired or is pending to fire at this level,
1392 		- 	// so this active level becomes the next change level.
1393 		- 	if (assertionsExist) {
1394 		- 	if (thisAgent->active_level > thisAgent->next_change_level) {
1395 		- 	thisAgent->next_change_level = thisAgent->active_level;
1396 		- 	}
1397 		- 	}
	1439 	+ 	// New waterfall model: something fired or is pending to fire at this level,
	1440 	+ 	// so this active level becomes the next change level.
	1441 	+ 	if (assertionsExist) {
	1442 	+ 	if (thisAgent->active_level > thisAgent->next_change_level) {
	1443 	+ 	thisAgent->next_change_level = thisAgent->active_level;
	1444 	+ 	}
	1445 	+ 	}
1398 	1446 		
1399 		- 	// New waterfall model: push unfired matches back on to the assertion lists
1400 		- 	restore_postponed_assertions(thisAgent);
	1447 	+ 	// New waterfall model: push unfired matches back on to the assertion lists
	1448 	+ 	restore_postponed_assertions(thisAgent);
1401 	1449 		
1402 		- 	assert_new_preferences (thisAgent, bufdeallo);
	1450 	+ 	assert_new_preferences(thisAgent, bufdeallo);
1403 	1451 		
1404 		- 	// Update accounting
1405 		- 	thisAgent->inner_e_cycle_count++;
	1452 	+ 	// Update accounting
	1453 	+ 	thisAgent->inner_e_cycle_count++;
1406 	1454 		
1407 		- 	if (thisAgent->active_goal == NIL) {
1408 		- 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
1409 		- 	print(thisAgent, " inner elaboration loop doesn't have active goal.\n");
1410 		- 	}
1411 		- 	break;
1412 		- 	}
	1455 	+ 	if (thisAgent->active_goal == NIL) {
	1456 	+ 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
	1457 	+ 	print(thisAgent,
	1458 	+ 	" inner elaboration loop doesn't have active goal.\n");
	1459 	+ 	}
	1460 	+ 	break;
	1461 	+ 	}
1413 	1462 		
1414 		- 	if (thisAgent->active_goal->id.lower_goal == NIL) {
1415 		- 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
1416 		- 	print(thisAgent, " inner elaboration loop at bottom goal.\n");
1417 		- 	}
1418 		- 	break;
1419 		- 	}
	1463 	+ 	if (thisAgent->active_goal->id.lower_goal == NIL) {
	1464 	+ 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
	1465 	+ 	print(thisAgent, " inner elaboration loop at bottom goal.\n");
	1466 	+ 	}
	1467 	+ 	break;
	1468 	+ 	}
1420 	1469 		
1421 		- 	if (thisAgent->current_phase == APPLY_PHASE) {
1422 		- 	thisAgent->active_goal = highest_active_goal_apply(thisAgent, thisAgent->active_goal->id.lower_goal, TRUE);
1423 		- 	} else {
1424 		- 	assert(thisAgent->current_phase == PROPOSE_PHASE);
1425 		- 	thisAgent->active_goal = highest_active_goal_propose(thisAgent, thisAgent->active_goal->id.lower_goal, TRUE);
1426 		- 	}
	1470 	+ 	if (thisAgent->current_phase == APPLY_PHASE) {
	1471 	+ 	thisAgent->active_goal = highest_active_goal_apply(thisAgent,
	1472 	+ 	thisAgent->active_goal->id.lower_goal, TRUE);
	1473 	+ 	} else {
	1474 	+ 	assert(thisAgent->current_phase == PROPOSE_PHASE);
	1475 	+ 	thisAgent->active_goal = highest_active_goal_propose(thisAgent,
	1476 	+ 	thisAgent->active_goal->id.lower_goal, TRUE);
	1477 	+ 	}
1427 	1478 		
1428 		- 	if (thisAgent->active_goal != NIL)
1429 		- 	{
1430 		- 	thisAgent->active_level = thisAgent->active_goal->id.level;
1431 		- 	} else {
1432 		- 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
1433 		- 	print(thisAgent, " inner elaboration loop finished but not at quiescence.\n");
1434 		- 	}
1435 		- 	break;
1436 		- 	}
1437 		- 	} // end inner elaboration loop
	1479 	+ 	if (thisAgent->active_goal != NIL) {
	1480 	+ 	thisAgent->active_level = thisAgent->active_goal->id.level;
	1481 	+ 	} else {
	1482 	+ 	if (thisAgent->sysparams[TRACE_WATERFALL_SYSPARAM]) {
	1483 	+ 	print(thisAgent,
	1484 	+ 	" inner elaboration loop finished but not at quiescence.\n");
	1485 	+ 	}
	1486 	+ 	break;
	1487 	+ 	}
	1488 	+ 	} // end inner elaboration loop
1438 	1489 		
1439 		- 	// Deallocate preferences delayed during inner elaboration loop.
1440 		- 	for ( pref_buffer_list::iterator iter=bufdeallo.begin(); iter!=bufdeallo.end(); ++iter )
1441 		- 	{
1442 		- 	preference_remove_ref( thisAgent, *iter );
1443 		- 	}
	1490 	+ 	// Deallocate preferences delayed during inner elaboration loop.
	1491 	+ 	for (pref_buffer_list::iterator iter = bufdeallo.begin();
	1492 	+ 	iter != bufdeallo.end(); ++iter) {
	1493 	+ 	preference_remove_ref(thisAgent, *iter);
	1494 	+ 	}
1444 	1495 		
1445 		- 	// Restore previous active level
1446 		- 	thisAgent->active_level = thisAgent->highest_active_level;
1447 		- 	thisAgent->active_goal = thisAgent->highest_active_goal;
1448 		- 	/* End new waterfall model */
	1496 	+ 	// Restore previous active level
	1497 	+ 	thisAgent->active_level = thisAgent->highest_active_level;
	1498 	+ 	thisAgent->active_goal = thisAgent->highest_active_goal;
	1499 	+ 	/* End new waterfall model */
1449 	1500 		
1450 		- 	while (get_next_retraction (thisAgent, &inst))
1451 		- 	retract_instantiation (thisAgent, inst);
	1501 	+ 	while (get_next_retraction(thisAgent, &inst))
	1502 	+ 	retract_instantiation(thisAgent, inst);
1452 	1503 		
1453 		- 	/* REW: begin 08.20.97 */
1454 		- 	/* In Waterfall, if there are nil goal retractions, then we want to
1455 		- 	retract them as well, even though they are not associated with any
1456 		- 	particular goal (because their goal has been deleted). The
1457 		- 	functionality of this separate routine could have been easily
1458 		- 	combined in get_next_retraction but I wanted to highlight the
1459 		- 	distinction between regualr retractions (those that can be
1460 		- 	mapped onto a goal) and nil goal retractions that require a
1461 		- 	special data strucutre (because they don't appear on any goal)
1462 		- 	REW. */
	1504 	+ 	/* REW: begin 08.20.97 */
	1505 	+ 	/* In Waterfall, if there are nil goal retractions, then we want to
	1506 	+ 	retract them as well, even though they are not associated with any
	1507 	+ 	particular goal (because their goal has been deleted). The
	1508 	+ 	functionality of this separate routine could have been easily
	1509 	+ 	combined in get_next_retraction but I wanted to highlight the
	1510 	+ 	distinction between regualr retractions (those that can be
	1511 	+ 	mapped onto a goal) and nil goal retractions that require a
	1512 	+ 	special data strucutre (because they don't appear on any goal)
	1513 	+ 	REW. */
1463 	1514 		
1464 		- 	if (thisAgent->nil_goal_retractions) {
1465 		- 	while (get_next_nil_goal_retraction (thisAgent, &inst))
1466 		- 	retract_instantiation (thisAgent, inst);
1467 		- 	}
1468 		- 	/* REW: end 08.20.97 */
	1515 	+ 	if (thisAgent->nil_goal_retractions) {
	1516 	+ 	while (get_next_nil_goal_retraction(thisAgent, &inst))
	1517 	+ 	retract_instantiation(thisAgent, inst);
	1518 	+ 	}
	1519 	+ 	/* REW: end 08.20.97 */
1469 	1520 		
1470 	1521 		}
1471 	1522 		
...

################################################################################
# initialize CDPS instead of prohibits

Modify	/trunk/SoarSuite/Core/SoarKernel/src/soar_module.cpp	diff	

# make_fake_instantiation()
... 			
162 	162 		}
163 	163 		}
164 	164 		
165 		- 	cond->bt.prohibits = NULL;
	165 	+ 	cond->bt.CDPS = NULL;
166 	166 		
167 	167 		prev_cond = cond;
168 	168 		}
... 	

################################################################################
# slot stuff

Modify	/trunk/SoarSuite/Core/SoarKernel/src/tempmem.cpp	diff	

# make_slot()
... 			
99 	99 		symbol_add_ref (attr);
100 	100 		s->wmes = NIL;
101 	101 		s->all_preferences = NIL;
	102 	+ 	s->CDPS = NIL;
102 	103 		
103 	104 		/* JC: This is the same as all_preferences
104 	105 		* except they are indexed by type.
... 			

# clear_CDPS()

159 	160 		s->marked_for_possible_removal = TRUE;
160 	161 		push (thisAgent, s, thisAgent->slots_for_possible_removal);
161 	162 		}
	163 	+ 	
	164 	+ 	/* MMA 8-2012: Clear out and deallocate the CDPS. */
	165 	+ 	void clear_CDPS (agent* thisAgent, slot *s) {
	166 	+ 	
	167 	+ 	list *cond_current, *cond_old;
	168 	+ 	preference *pref;
	169 	+ 	
	170 	+ 	/* The CDPS should never exist on a top-level slot, so we do
	171 	+ 	* not need to worry about checking for DO_TOP_LEVEL_REF_CTS. */
	172 	+ 	
	173 	+ 	cond_old = cond_current = s->CDPS;
	174 	+ 	s->CDPS = NIL;
	175 	+ 	for (; cond_current != NIL; cond_current = cond_current->rest) {
	176 	+ 	pref = static_cast<preference *>(cond_current->first);
	177 	+ 	preference_remove_ref(thisAgent, pref);
	178 	+ 	}
	179 	+ 	free_list(thisAgent, cond_old);
	180 	+ 	
	181 	+ 	}
	182 	+ 	/* MMA 8-2012 end */
162 	183 		
163 	184 		void remove_garbage_slots (agent* thisAgent) {
164 	185 		cons *c;
... 			

# remove_garbage_slots()

181 	202 		print_with_symbols (thisAgent, "\nDeallocate slot %y ^%y", s->id, s->attr);
182 	203 		#endif
183 	204 		
184 		- 	if (s->changed && (! s->isa_context_slot)) {
185 		- 	remove_from_dll (thisAgent->changed_slots, s->changed, next, prev);
186 		- 	free_with_pool (&thisAgent->dl_cons_pool, s->changed);
	205 	+ 	/* MMA 9-2012 */
	206 	+ 	if (s->CDPS && thisAgent->sysparams[CHUNK_THROUGH_EVALUATION_RULES_SYSPARAM])
	207 	+ 	clear_CDPS(thisAgent, s);
	208 	+ 	/* MMA 9-2012 end */
	209 	+ 	
	210 	+ 	if (s->changed && (!s->isa_context_slot)) {
	211 	+ 	remove_from_dll(thisAgent->changed_slots, s->changed, next, prev);
	212 	+ 	free_with_pool(&thisAgent->dl_cons_pool, s->changed);
	213 	+ 	}
	214 	+ 	remove_from_dll(s->id->id.slots, s, next, prev);
	215 	+ 	symbol_remove_ref(thisAgent, s->id);
	216 	+ 	symbol_remove_ref(thisAgent, s->attr);
	217 	+ 	if (s->wma_val_references != NIL) {
	218 	+ 	s->wma_val_references->~wma_sym_reference_map();
	219 	+ 	free_with_pool(&(thisAgent->wma_slot_refs_pool), s->wma_val_references);
	220 	+ 	s->wma_val_references = NIL;
187 	221 		}
188 		- 	remove_from_dll (s->id->id.slots, s, next, prev);
189 		- 	symbol_remove_ref (thisAgent, s->id);
190 		- 	symbol_remove_ref (thisAgent, s->attr);
191 		- 	if ( s->wma_val_references != NIL )
192 		- 	{
193 		- 	s->wma_val_references->~wma_sym_reference_map();
194 		- 	free_with_pool( &( thisAgent->wma_slot_refs_pool ), s->wma_val_references );
195 		- 	s->wma_val_references = NIL;
196 		- 	}
197 		- 	free_with_pool (&thisAgent->slot_pool, s);
	222 	+ 	free_with_pool(&thisAgent->slot_pool, s);
198 	223 		}
199 	224 		}
200 	225 		
... 	

################################################################################
# testing possibilities
# TestSoarPerformance.cpp refers to test_agents/cdps1.soar and test_agents/cdps2.soar
# Maybe can make these into unit tests